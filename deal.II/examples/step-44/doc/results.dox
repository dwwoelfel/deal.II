<h1>Results</h1>

Firstly, we present a comparison of a series of results with those 
in the literature (see Reese et al (2000)) to demonstrate that the program works as expected.

We begin with a comparison of the convergence with mesh refinement for the $Q_1-DGPM_0-DGPM_0$ and
$Q_2-DGPM_1-DGPM_1$ formulations, as summarised in the figure below.
The vertical displacement of the midpoint of the upper surface of the block is used to assess convergence.
Both schemes demonstrate good convergence properties for varying values of the load parameter $p/p_0$. 
The results agree with those in the literature.
The lower-order formulation typically overestimates the displacement for low levels of refinement, 
while the higher-order interpolation scheme underestimates it, but be a lesser degree.
This benchmark, and a series of others not shown here, give us confidence that the code is working
as it should

<table align="center" class="tutorial" cellspacing="3" cellpadding="3">
  <tr>
     <td align="center">
        @image html "step-44.Q1-P0_convergence.png"
	<p align="center">
        Convergence of the $Q_1-DGPM_0-DGPM_0$ formulation.
	</p>
    </td>
    <td align="center">
        @image html "step-44.Q2-P1_convergence.png"
	<p align="center">
        Convergence of the $Q_2-DGPM_1-DGPM_1$ formulation.
	</p>
    </td>
  </tr>
</table>


A typical screen output generated by running the problem is shown below. 
The particular case demonstrated is that of the $Q_2-DGPM_1-DGPM_1$ formulation.
It is clear that, using the Newton-Raphson method, quadratic convergence of the solution is obtained. 
Other than in the first time step, solution convergence is achieved within 5 Newton increments. 
The converged displacement's $L_2$-norm is several orders of magnitude less than the geometry scale.

@code
Grid:
	 Reference volume: 1e-09
Triangulation:
	 Number of active cells: 64
	 Number of degrees of freedom: 2699
    Setting up quadrature point data...

Timestep 1 @ 0.1s
___________________________________________________________________________________________________________________________________________________________
                 SOLVER STEP                   |  LIN_IT   LIN_RES    RES_NORM     RES_U     RES_P      RES_J     NU_NORM      NU_U       NU_P       NU_J 
___________________________________________________________________________________________________________________________________________________________
  0  ASM_R  ASM_K  CST  ASM_SC  SLV  PP  UQPH  |     516  2.432e-06  1.000e+00  1.000e+00  0.000e+00  0.000e+00  1.000e+00  1.000e+00  1.000e+00  1.000e+00  
  1  ASM_R  ASM_K  CST  ASM_SC  SLV  PP  UQPH  |     290  4.660e-03  5.446e+00  8.554e-02  2.602e-10  1.437e+01  4.191e+00  2.550e+00  4.191e+00  1.456e+04  
  2  ASM_R  ASM_K  CST  ASM_SC  SLV  PP  UQPH  |     339  7.754e-03  2.780e+00  1.901e+00  7.310e-12  5.352e+00  3.597e+00  2.129e+00  3.597e+00  1.316e+03  
  3  ASM_R  ASM_K  CST  ASM_SC  SLV  PP  UQPH  |     325  2.931e-03  1.443e+00  1.380e+00  4.568e-12  1.115e+00  9.874e-01  4.266e-01  9.874e-01  1.250e+03  
  4  ASM_R  ASM_K  CST  ASM_SC  SLV  PP  UQPH  |     390  2.072e-04  8.894e-02  8.523e-02  2.469e-13  6.711e-02  4.998e-02  2.656e-02  4.998e-02  1.237e+02  
  5  ASM_R  ASM_K  CST  ASM_SC  SLV  PP  UQPH  |     506  8.187e-07  4.081e-04  3.921e-04  8.575e-16  2.980e-04  2.522e-04  1.344e-04  2.522e-04  5.493e-01  
  6  ASM_R  ASM_K  CST  ASM_SC  SLV  PP  UQPH  |     613  1.665e-11  3.105e-07  3.105e-07  2.613e-20  5.834e-09  3.108e-07  3.428e-08  3.108e-07  1.066e-05  
  7  ASM_R  CONVERGED! 
___________________________________________________________________________________________________________________________________________________________
Relative errors:
Displacement:	3.428e-08
Force: 		6.310e-12
Dilatation:	1.353e-07
v / V_0:	1.000e-09 / 1.000e-09 = 1.000e+00


[...]

Timestep 10 @ 1.000e+00s
___________________________________________________________________________________________________________________________________________________________
                 SOLVER STEP                   |  LIN_IT   LIN_RES    RES_NORM     RES_U     RES_P      RES_J     NU_NORM      NU_U       NU_P       NU_J 
___________________________________________________________________________________________________________________________________________________________
  0  ASM_R  ASM_K  CST  ASM_SC  SLV  PP  UQPH  |     556  2.542e-06  1.000e+00  1.000e+00  1.000e+00  1.000e+00  1.000e+00  1.000e+00  1.000e+00  1.000e+00  
  1  ASM_R  ASM_K  CST  ASM_SC  SLV  PP  UQPH  |     455  8.017e-05  1.538e-01  1.538e-01  3.522e+11  4.617e+07  6.010e-02  7.396e-02  6.010e-02  6.011e-02  
  2  ASM_R  ASM_K  CST  ASM_SC  SLV  PP  UQPH  |     554  4.012e-07  2.896e-03  2.896e-03  2.127e+09  5.117e+04  2.720e-03  1.430e-03  2.720e-03  2.724e-03  
  3  ASM_R  ASM_K  CST  ASM_SC  SLV  PP  UQPH  |     620  4.946e-10  1.728e-06  1.728e-06  1.315e+06  9.778e+01  1.150e-06  6.268e-07  1.150e-06  1.150e-06  
  4  ASM_R  CONVERGED! 
___________________________________________________________________________________________________________________________________________________________
Relative errors:
Displacement:	6.268e-07
Force: 		1.873e-10
Dilatation:	1.525e-06
v / V_0:	9.999e-10 / 1.000e-09 = 9.999e-01
@endcode



Using the Timer class, we can discern which parts of the code require the highest computational expense. 
For a case with a large number of degrees-of-freedom (i.e. a high level of refinement), a typical output of the Timer is given below.
Much of the code in the tutorial has been developed based on the optimisations described, 
discussed and demonstrated in Step-18 and others. 
With over 93% of the time being spent in the linear solver, it is obvious that it may be necessary 
to invest in a better solver for large three-dimensional problems. 
The SSOR preconditioner is not multi-threaded but is effective for this class of solid problems. 
It may be beneficial to investigate the use of another solver such as those available through the Trilinos library.


@code
+---------------------------------------------+------------+------------+
| Total wallclock time elapsed since start    | 9.874e+02s |            |
|                                             |            |            |
| Section                         | no. calls |  wall time | % of total |
+---------------------------------+-----------+------------+------------+
| Assemble system right-hand side |        53 | 1.727e+00s |  1.75e-01% |
| Assemble tangent matrix         |        43 | 2.707e+01s |  2.74e+00% |
| Linear solver                   |        43 | 9.248e+02s |  9.37e+01% |
| Linear solver postprocessing    |        43 | 2.743e-02s |  2.78e-03% |
| Perform static condensation     |        43 | 1.437e+01s |  1.46e+00% |
| Setup system                    |         1 | 3.897e-01s |  3.95e-02% |
| Update QPH data                 |        43 | 5.770e-01s |  5.84e-02% |
+---------------------------------+-----------+------------+------------+
@endcode


We then used ParaView to visualise the results for two cases.
The first was for the coarsest grid and the lowest-order interpolation method: $Q_1-DGPM_0-DGPM_0$.
The second was on a refined grid using a $Q_2-DGPM_1-DGPM_1$ formulation.
The vertical component of the displacement, the pressure $\widetilde{p}$ and the dilatation $\widetilde{J}$ fields
are shown below. 


For the first case it is clear that the coarse spatial discretisation coupled with large displacements leads to a low quality solution
(the loading ratio is  $p/p_0=80$).
Additionally, the pressure difference between elements is very large. 
The constant pressure field on the element means that the large pressure gradient is not captured. 
However, it should be noted that locking, which would be present in a standard $Q_1$ displacement formulation does not arise
even in this poorly discretised case. 
The final vertical displacement of the tracked node on the top surface of the block is still within 12.5% of the converged solution. 
The pressure solution is very coarse and has large jumps between adjacent cells. 
It is clear that the volume nearest to the applied traction undergoes compression while the outer extents 
of the domain are in a state of expansion. 
The dilatation solution field and pressure field are clearly linked, 
with positive dilatation indicating regions of positive hyprodstatic pressure and negative showing regions placed in compression.
As discussed in the Introduction, a compressive pressure has a negative sign 
while an expansive pressure takes a positive sign. 
This stems from the definition of the volumetric strain energy function 
and is opposite to the physically realistic interpretation of pressure.


<table align="center" class="tutorial" cellspacing="3" cellpadding="3">
  <tr>
    <td align="center">
        @image html "step-44.Q1-P0_gr_1_p_ratio_80-displacement.png"
	<p align="center">
        Z-displacement solution.
	</p>
    </td>
    <td align="center">
        @image html "step-44.Q1-P0_gr_1_p_ratio_80-pressure.png"
	<p align="center">
        Discontinuous piece-wise constant pressure field.
	</p>
    </td>
     <td align="center">
        @image html "step-44.Q1-P0_gr_1_p_ratio_80-dilatation.png"
	<p align="center">
        Discontinuous piece-wise constant dilatation field.
	</p>
    </td>
  </tr>
</table>

Combining spatial refinement and a higher-order interpolation scheme results in a high-quality solution. 
Three grid refinements coupled with a $Q_2-DGPM_1-DGPM_1$ formulation produces 
a result that clearly captures the mechanics of the problem. 
The deformation of the traction surface is well resolved. 
We can now observe the actual extent of the applied traction, with the maximum force being applied
at the central point of the surface causing the largest compression. 
Even though very high strains are experienced in the domain, 
especially at the boundary of the region of applied traction, 
the solution remains accurate. 
The pressure field is captured in far greater detail than before. 
There is a clear distinction and transition between regions of compression and expansion, 
and the linear approximation of the pressure field allows a refined visualisation 
of the pressure at the sub-element scale. 
It should however be noted that the pressure field remains discontinuous
 and could be smoothed on a continuous grid for the post-processing purposes.



<table align="center" class="tutorial" cellspacing="3" cellpadding="3">

  <tr>
    <td align="center">
        @image html "step-44.Q2-P1_gr_3_p_ratio_80-displacement.png"
	<p align="center">
        Z-displacement solution.
	</p>
    </td>
    <td align="center">
        @image html "step-44.Q2-P1_gr_3_p_ratio_80-pressure.png"
	<p align="center">
        Discontinuous linear pressure field.
	</p>
    </td>
    <td align="center">
        @image html "step-44.Q2-P1_gr_3_p_ratio_80-dilatation.png"
	<p align="center">
        Discontinuous linear dilatation field.
	</p>
    </td>
  </tr>
</table>

This brief analysis of the results demonstrates that the three-field formulation is effective 
in circumventing volumetric locking for highly-incompressible media. 
The mixed formulation is able to accurately simulate the displacement of a 
near-incompressible block under compression. 
The command-line output indicates that the volumetric change under extreme compression resulted in 
less than 0.01% volume change for a Poisson's ratio of 0.4999.

In terms of run-time, the $Q_2-DGPM_1-DGPM_1$ formulation tends to be a bit more computationally expensive 
than the $Q_1-DGPM_0-DGPM_0$ for a similar number of degree-of-freedom 
(produced by adding an extra grid refinement level for the lower-order interpolation). 
This is shown in the graph below for a batch of tests run serially on a single 4-core (8-thread) machine.
The increase in computational time for the higher-order method is likely due to 
the increased band-width required for the higher-order elements. 
As previously mentioned, the use of a better solver and precondtioner may mitigate the 
expense of using a higher-order formulation. 
It was observed that using the multithreaded Jacobi preconditioner does reduce the 
computational runtime by up to 25% in comparison to the single-thread SSOR preconditioner. 
However, it is the author's experience that the Jacobi method of preconditioning may not
 be suitable for some finite-strain problems involving alternative constitutive models.


<table align="center" class="tutorial" cellspacing="3" cellpadding="3">
  <tr>
     <td align="center">
        @image html "step-44.Normalised_runtime.png"
	<p align="center">
        Runtime on a 4-core machine, normalised against the lowest grid resolution Q1-P0 solution that utilised a SSOR preconditioner.
	</p>
    </td>
  </tr>
</table>

<a name="extensions"></a>
<h3>Possibilities for extensions</h3>

There are a number of obvious extensions for this work:

- Firstly, an additional constraint could be added to the free-energy
  function in order to enforce a high degree of incompressibility in
  materials. An additional Lagrange multiplier would be introduced,
  but this could most easily be dealt with using the principle of
  augmented Lagrange multipliers. This is demonstrated in <em>Simo and
  Taylor (1991) </em>.
- The constitutive relationship used in this
  model is relatively basic. It may be beneficial to split the material
  class into two separate classes, one dealing with the volumetric
  response and the other the isochoric response, and produce a generic
  materials class (i.e. having abstract virtual functions that derived
  classes have to implement) that would allow for the addition of more complex
  material models. Such models could include other hyperelastic
  materials, plasticity and viscoelastic materials and others.
- The program has been developed for solving problems on single-node
  multicore machines. With a little effort, the program could be
  extended to a large-scale computing environment through the use of
  Petsc or Trilinos, using a similar technique to that demonstrated in
  step-40. This would mostly involve changes to the setup, assembly,
  <code>PointHistory</code> and linear solver routines.
- As this program assumes quasi-static equilibrium, extensions to
  include dynamic effects would be necessary to study problems where
  inertial effects are important, e.g. problems involving impact.
- Load and solution limiting procedures may be necessary for highly
  nonlinear problems. It is possible to add a linesearch algorithm to
  limit the step size within a Newton increment to ensure optimum
  convergence. It may also be necessary to use a load limiting method,
  such as the Riks method, to solve unstable problems involving
  geometric instability such as buckling and snap-through.

- Many physical problems involve contact. It is possible to include
  the effect of frictional or frictionless contact between objects
  into this program. This would involve the addition of an extra term
  in the free-energy functional and therefore an addition to the
  assembly routine. One would also need to manage the contact problem
  (detection and stress calculations) itself. An alternative to
  additional penalty terms in the free-energy functional would be to
  use active set methods such as the one used in step-41.

- Finally, adaptive mesh refinement, as demonstrated in step-18, could
  provide additional solution accuracy.
