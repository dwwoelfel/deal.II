<a name="Intro"></a>
<h1>Introduction</h1>

<h2>The Boussinesq equations</h2>

This program deals with an interesting physical problem: how does a
fluid (i.e. a liquid or gas) behave if it experiences differences in
buoyance caused by temperature differences? It is clear that those
parts of the fluid that are hotter (and therefore lighter) are going
to rise up and those that are cooler (and denser) are going to sink
down against gravity.

In cases where the fluid moves slowly enough such that inertia effects
can be neglected, the equations that describe such behavior are the
Boussinesq equations that read as follows:
@f{eqnarray*}
  -\nabla \cdot \eta \varepsilon ({\mathbf u}) + \nabla p &=& 
  \mathrm{Ra} \; T \mathbf{g},
  \\
  \nabla \cdot {\mathbf u} &=& 0,
  \\
  \frac{\partial T}{\partial t}
  +
  {\mathbf u} \cdot \nabla T
  -
  \nabla \cdot \kappa \nabla T &=& \gamma.
@f}
Here, ${\mathbf u}$ is the velocity field, $p$ the pressure, and $T$
the temperature of the fluid. $\varepsilon ({\mathbf u}) = \frac 12
[(\nabla{\mathbf u}) + (\nabla {\mathbf u})^T]$ is the symmetric
gradient of the velocity. As can be seen, velocity and pressure
solve a Stokes equation describing the motion of an incompressible
fluid. The forcing term of the fluid motion is the buoyancy of the
fluid, expressed as the product of the Rayleigh number $\mathrm{Ra}$,
the temperature $T$ and the gravity vector ${\mathbf g}$. (A possibly
more intuitive formulation would use $\mathrm{Ra} \; (T-\bar T)
\mathbf{g}$ as right hand side where $\bar T$ is the average
temperature, and the right hand side then describes the forces due to
local deviations from the average density; this formulation is
entirely equivalent if the gravity vector results from a gravity
potential $\phi$, i.e. $\mathbf{g}=-\nabla\phi$, and yields the exact
same solution except for the pressure which will now be $p+\mathrm{Ra}
\;\bar T \phi$.)

While the first two equations describe how the fluid reacts to
temperature differences by moving around, the third equation states
how the fluid motion affects the temperature field: it is an advection
diffusion equation, i.e. the temperature is attached to the fluid
particles and advected along in the flow field, with an additional
diffusion (heat conduction) term.

In these equations, $\eta$ and $\kappa$ denote the viscosity and
diffusivity coefficients. In the more general case and in many
physical applications, they may and $\eta$ often will depend on the
temperature, but we will neglect this dependence for the purpose of
this tutorial program. The term $\gamma$ on the right hand side
denotes the heat sources and may be a spatially and temporally varying
function. 

$\mathrm{Ra}$, called the <a
href="http://en.wikipedia.org/wiki/Rayleigh_number">Rayleigh
number</a> is a dimensionless number that describes the ratio of heat
transport due to convection induced by buoyancy changes from
temperature differences, and of heat transport due to thermal
diffusion. A small Rayleigh number implies that buoyancy is not strong
relative to viscosity and fluid motion $\mathbf u$ is slow enough so
that heat diffusion $\kappa\Delta T$ is the dominant heat transport
term. On the other hand, a fluid with a high Rayleigh number will show
vigorous convection that dominates heat conduction. 

For most fluids for which we are interested in computing thermal
convection, the Rayleigh number is very large, often $10^6$ or
larger. From the structure of the equations, we see that this will
lead to large pressure differences and large velocities. Consequently,
the convection term in the convection-diffusion equation for $T$ will
also be very large and an accurate solution of this equation will
require us to choose small time steps. Problems with large Rayleigh
numbers are therefore hard to solve numerically for similar reasons
that make solving the <a
href="http://en.wikipedia.org/wiki/Navier-stokes_equations">Navier-Stokes
equations</a> hard to solve when the <a
href="http://en.wikipedia.org/wiki/Reynolds_number">Reynolds number
$\mathrm{Re}$</a> is large.

Note that a large Rayleigh number does not necessarily involve large
velocities in absolute terms. For example, the Rayleigh number in the
earth mantle has a Rayleigh number larger than $10^6$. Yet the
velocities are small: the material is in fact solid rock but it is so
hot and under pressure that it can flow very slowly, on the order of
at most a few centimeters per year. Nevertheless, the can lead to
mixing over time scales of many million years, a time scale much
shorter than for the same amount of heat to be distributed by thermal
conductivity. 


<h2>%Boundary and initial conditions</h2>

Since the Boussinesq equations are derived under the assumption that
inertia of the fluid's motion does not play a role, the flow field is
at each time entirely determined by buoyancy difference at that time,
not by the flow field at previous times. This is reflected by the fact
that the first two equations above are the steady state Stokes
equation. Consequently, we do not need initial conditions for either
velocities or pressure. On the other hand, the temperature field does
satisfy an equation with a time derivative, so we need initial
conditions for $T$.

As for boundary conditions: if $\kappa>0$ then the temperature
satisfies a second order differential equation that requires
temperature data all around the boundary for all times. Similarly, the
velocity field requires us to pose boundary conditions. These may be
no-slip no-flux conditions $\mathbf u=0$ on $\partial\Omega$ if the
fluid sticks to the boundary, or no normal flux conditions $\mathbf n
\cdot \mathbf u = 0$ if the fluid can flow along but not across the
boundary, or any number of other conditions that are physically
reasonable. In this program, we will use no normal flux conditions.


<h2>Solution approach</h2>

Like the equations solved in @ref step_21 "step-21", we here have a
system of differential-algebraic equations (DAE): with respect to the time
variable, only the temperature equation is a differential equation
whereas the Stokes system for $\mathbf u$ and $p$ has no
time-derivatives and is therefore of the sort of an algebraic
constraint that has to hold at each time instant. The main difference
to @ref step_21 "step-21" is that the algebraic constraint there was a
mixed Laplace system of the form
@f{eqnarray*}
  \mathbf u + {\mathbf K}\lambda \nabla p &=& 0, \\
  \nabla\cdot \mathbf u &=& f,
@f}
where now we have a Stokes system
@f{eqnarray*}
  -\nabla \cdot \eta \varepsilon ({\mathbf u}) + \nabla p &=& f, \\
  \nabla\cdot \mathbf u &=& 0,
@f}
where $\nabla \cdot \varepsilon (\cdot)$ is an operator similar to the
Laplacian $\Delta$ applied to a vector field.

Given the similarity to what we have done in @ref step_21 "step-21",
it may not come as a surprise that we choose a similar approach,
although we will have to make adjustments for the change in operator
in the top-left corner of the differential operator. As it will turn
out, it is actually a lot easier to solve the Stokes problem than it
is to solve the mixed Laplacian, and we will make full use of this
fact! 


<h3>Time stepping</h3>

The structure of the problem as a DAE allows us to use the same
strategy as we have already used in @ref step_21 "step-21", i.e. we
use time lag scheme: first solve the Stokes equations for velocity and
pressure using the temperature field from the previous time step, then
with the new velocities update the temperature field for the current
time step. In other words, in time step $n$ we first solve the Stokes
system
@f{eqnarray*}
  -\nabla \cdot \eta \varepsilon ({\mathbf u}^n) + \nabla p^n &=& 
  \mathrm{Ra} \; T^{n-1} \mathbf{g},
  \\
  \nabla \cdot {\mathbf u}^n &=& 0,
@f}
and then 
@f{eqnarray*}
  T^n
  -
  k_n\nabla \cdot \kappa \nabla T^n 
  &=& 
  T^{n-1}
  +
  k_n\gamma
  -
  k_n{\mathbf u}^n \cdot \nabla T^{n-1},
@f}
where $k_n$ is the time step size. Note how the temperature equation is
solved semi-explicitly: diffusion is treated implicitly whereas
advection is treated explicitly using the just-computed velocity
field. 


<h3>Weak form and space discretization</h3>

Like solving the mixed Laplace equations, solving the Stokes equations
requires us to choose particular pairs of finite elements for
velocities and pressure variables. In the current program, we use the
stable pair $Q_{p+1}^d \times Q_p, p\ge 1$. These are continuous
elements, so we can form the weak form of the Stokes equation without
problem by integrating by parts and substituting continuous functions
by their discrete counterparts:
@f{eqnarray*}
  (\nabla {\mathbf v}_h, \eta \varepsilon ({\mathbf u}^n_h))
  -
  (\nabla \cdot {\mathbf v}_h, p^n_h) 
  &=& 
  ({\mathbf v}_h, \mathrm{Ra} \; T^{n-1}_h \mathbf{g}),
  \\
  (q_h, \nabla \cdot {\mathbf u}^n_h) &=& 0,
@f}
for all test functions $\mathbf v_h, q_h$. The first term of the first
equation is considered as the scalar product between tensors, i.e.
$(\nabla {\mathbf v}_h, \eta \varepsilon ({\mathbf u}^n_h))_\Omega
 = \int_\Omega \sum_{i,j=1}^d [\nabla {\mathbf v}_h]_{ij}
           \eta [\varepsilon ({\mathbf u}^n_h)]_{ij}$.
Because the second tensor in this product is symmetric, the
anti-symmetric component of $\nabla {\mathbf v}_h$ plays no role and
it leads to the entirely same form if we use the symmetric gradient of
$\mathbf v_h$ instead. Consequently, the formulation we consider and
that we implement is
@f{eqnarray*}
  (\varepsilon({\mathbf v}_h), \eta \varepsilon ({\mathbf u}^n_h))
  -
  (\nabla \cdot {\mathbf v}_h, p^n_h) 
  &=& 
  ({\mathbf v}_h, \mathrm{Ra} \; T^{n-1}_h \mathbf{g}),
  \\
  (q_h, \nabla \cdot {\mathbf u}^n_h) &=& 0.
@f}

The more interesting question is what we do with the temperature
equation. By default, not all discretizations of this equation are
equally stable unless we either do something like upwinding,
stabilization, or all of this. <b>XXXXXXXXXX TALK ABOUT CHOICE OF FE
AND DG/CG XXXXX</b>

@f{eqnarray*}
  (\tau_h,T^n_h)
  +
  k_n(\nabla \tau_h, \kappa \nabla T^n_h) 
  &=& 
  (\tau_h,T^{n-1}_h+k_n\gamma)
  -
  k_n (\tau_h, {\mathbf u}^n \cdot \nabla T^{n-1}_h),
@f}
for all discrete test functions $\tau_h$. One typically integrated the
last term on the right hand side by parts on each cell, yielding the
following taking into account that the velocity field is assumed to be
divergence-free: 
@f{eqnarray*}
  (\tau_h,T^n_h)
  +
  k_n(\nabla \tau_h, \kappa \nabla T^n_h) 
  &=& 
  (\tau_h,T^{n-1}_h+k_n\gamma)
  +
  k_n \sum_K \left\{ ({\mathbf u}^n \cdot \nabla \tau_h, T^{n-1}_h)_K -
             (\tau_h, (\mathbf n \cdot {\mathbf u}^n) T^{n-1}_h)_{\partial K} \right\}.
@f}
<b>XXXXXXXXXX WHAT DO I DO WITH THE DIV U TERM? XXXXX</b>



<h3>Linear solvers</h3>

As explained above, our approach to solving the joint system for
velocities/pressure on the one hand and temperature on the other is to use an
operator splitting where we first solve the Stokes system for the velocities
and pressures using the old temperature field, and then solve for the new
temperature field using the just computed velocity field. In other words, we
first have to solve the following system resulting from discretization of the
Stokes system:
@f{eqnarray*}
  \left(\begin{array}{cc}
    A & B^T \\ B & 0
  \end{array}\right)
  \left(\begin{array}{cc}
    U \\ P
  \end{array}\right)
  =
  \left(\begin{array}{cc}
    F \\ G
  \end{array}\right),
@f}
Like in @ref step_20 "step-20" and @ref step_21 "step-21", we will solve this
system of equations by forming the Schur complement, i.e. we will first find
the solution $P$ of 
@f{eqnarray*}
  BA^{-1}B^T P &=& BM^{-1} F - G, \\
@f}
and then
@f{eqnarray*}
  MU &=& F - B^TP.
@f}
The way we do this is pretty much exactly like we did in these previous
tutorial programs, i.e. we use the same classes <code>SchurComplement</code>
and <code>InverseMatrix</code> again. There are slight differences,
however:

First, in the mixed Laplace equation we had to deal with the question of how
to precondition the Schur complement $B^TM^{-1}B$, which was spectrally
equivalent to the Laplace operator on the pressure space (because $B$
represents the gradient operator, $B^T$ its adjoint $-\textrm{div}$, and $M$
the identity (up to the material parameter $K^{-1}$), so $B^TM^{-1}B$ is
something like $-\textrm{div} 1 \nabla = -\Delta$) and consequently badly
conditioned for small mesh sizes. To this end, we had to come up with an
elaborate preconditioning scheme for the Schur complement.

Second, every time we multiplied with $B^TM^{-1}B$ we had to solve with the
mass matrix $M$. This wasn't particularly difficult, however, since the mass
matrix is always well conditioned and so simple to invert using CG and a
little bit of preconditioning.

Here, the situation is pretty much exactly the opposite. The difference stems
from the fact that the matrix at the heart of the Schur complement does not
stem from the identity operator but from a variant of the Laplace operator,
$-\textrm{div} \eta \nabla^s$ (where $\nabla^s$ is the symmetric gradient)
acting on a vector field. This makes the outer preconditioner simple: the
Schur complement corresponds to the operator $-\textrm{div} (-\textrm{div}
\eta \nabla^s)^{-1} \nabla$ on the pressure space; forgetting about the
viscosity $\eta$ and ignoring the fact that we deal with symmetric gradients
instead of the regular one, the Schur complement is something like
$-\textrm{div} (-\textrm{div} \nabla)^{-1} \nabla = -\textrm{div}
(-\Delta)^{-1} \nabla$, which even if not mathematically entirely concise, is
spectrally equivalent to the identity operator. It turns out that it isn't
easy to solve this Schur complement in a straight forward way with the CG
method: using no preconditioner, the condition number of the Schur complement
matrix depends on the size ratios of the largest to the smallest cells, and
one still needs on the order of 50-100 CG iterations. However, there is a
simple cure: precondition with the mass matrix on the pressure space and we
get down to a number between 5-10 CG iterations, pretty much independently of
the structure of the mesh. 

So all we need in addition to what we already have is the mass matrix on the
pressure variables. Now, it turns out that the pressure-pressure block in the
system matrix is empty because the weak form of the equations have no term
that would couple the pressure variable to the pressure test functions.
...

Inner preconditioner.





@code
template <int dim>
Tensor<1,dim>
extract_u (const FEValuesBase<dim> &fe_values,
           const unsigned int i,
           const unsigned int q)
{
  Tensor<1,dim> tmp;

  const unsigned int component
    = fe_values.get_fe().system_to_component_index(i).first;

  if (component < dim)
    tmp[component] = fe_values.shape_value (i,q);

  return tmp;
}



template <int dim>
double
extract_div_u (const FEValuesBase<dim> &fe_values,
               const unsigned int i,
               const unsigned int q)
{
  const unsigned int component
    = fe_values.get_fe().system_to_component_index(i).first;

  if (component < dim)
    return fe_values.shape_grad (i,q)[component];
  else
    return 0;
}



template <int dim>
Tensor<2,dim>
extract_grad_s_u (const FEValuesBase<dim> &fe_values,
		  const unsigned int i,
		  const unsigned int q)
{
  Tensor<2,dim> tmp;

  const unsigned int component
    = fe_values.get_fe().system_to_component_index(i).first;
  
  if (component < dim)
    {
      const Tensor<1,dim> grad_phi_over_2 = fe_values.shape_grad (i,q) / 2;
      
      for (unsigned int e=0; e<dim; ++e)
	tmp[component][e] += grad_phi_over_2[e];
      for (unsigned int d=0; d<dim; ++d)
	tmp[d][component] += grad_phi_over_2[d];
    }
  
  return tmp;
}


  
template <int dim>
double extract_p (const FEValuesBase<dim> &fe_values,
                  const unsigned int i,
                  const unsigned int q)
{
  const unsigned int component
    = fe_values.get_fe().system_to_component_index(i).first;

  if (component == dim)
    return fe_values.shape_value (i,q);
  else
    return 0;
}



template <int dim>
double extract_T (const FEValuesBase<dim> &fe_values,
                  const unsigned int i,
                  const unsigned int q)
{
  const unsigned int component
    = fe_values.get_fe().system_to_component_index(i).first;

  if (component == dim+1)
    return fe_values.shape_value (i,q);
  else
    return 0;
}



template <int dim>
Tensor<1,dim>
extract_grad_T (const FEValuesBase<dim> &fe_values,
                const unsigned int i,
                const unsigned int q)
{
  Tensor<1,dim> tmp;

  const unsigned int component
    = fe_values.get_fe().system_to_component_index(i).first;

  if (component == dim+1)
    tmp = fe_values.shape_grad (i,q);

  return tmp;
}
@endcode

@code
  {
    Vector<double> xx(dof_handler.n_dofs());
    std::vector<bool> p_component (dof_handler.n_dofs());
    std::vector<bool> p_boundary (dof_handler.n_dofs());
    std::vector<bool> component_mask (dim+2, false);
    component_mask[dim] = true;
    DoFTools::extract_dofs (dof_handler, component_mask, p_component);
    DoFTools::extract_boundary_dofs (dof_handler, component_mask, p_boundary);
    
    QGauss<dim>   quadrature_formula(degree+2); 
    FEValues<dim> fe_values (fe, quadrature_formula, 
			     update_values | update_gradients  | update_JxW_values);
    std::vector<std::vector<Tensor<1,dim> > >  solution_grads(fe_values.n_quadrature_points,
							      std::vector<Tensor<1,dim> > (dim+2));
    std::vector<unsigned int> local_dof_indices (fe.dofs_per_cell);
    
    typename DoFHandler<dim>::active_cell_iterator
      cell = dof_handler.begin_active(),
      endc = dof_handler.end();
    for (; cell!=endc; ++cell)
      { 
	fe_values.reinit (cell);
	fe_values.get_function_gradients (solution, solution_grads);

	cell->get_dof_indices (local_dof_indices);
	
	for (unsigned int q=0; q<fe_values.n_quadrature_points; ++q)
	  for (unsigned int i=0; i<fe.dofs_per_cell; ++i)
	    if (p_component[local_dof_indices[i]] == true)
	      { 
		double divergence(solution_grads[q][0][0] +
				  solution_grads[q][1][1]);
		xx(local_dof_indices[i]) += divergence * fe_values.shape_value(i,q) *
					    fe_values.JxW(q);
	      }
      }
    hanging_node_constraints.condense (xx);
    
    for (unsigned int i=0; i<dof_handler.n_dofs(); ++i)
      if ((p_component[i] == true) && (hanging_node_constraints.is_constrained(i) == false)
	  && (p_boundary[i] == false))
	Assert (std::fabs(xx(i)) < 1e-11, ExcInternalError());
  }
@endcode
