<a name="Intro"></a>
<h1>Introduction</h1>

<h2>The Boussinesq equations</h2>

This program deals with an interesting physical problem: how does a
fluid (i.e. a liquid or gas) behave if it experiences differences in
buoyance caused by temperature differences? It is clear that those
parts of the fluid that are hotter (and therefore lighter) are going
to rise up and those that are cooler (and denser) are going to sink
down against gravity.

In cases where the fluid moves slowly enough such that inertia effects
can be neglected, the equations that describe such behavior are the
Boussinesq equations that read as follows:
@f{eqnarray*}
  -\nabla \cdot \eta \varepsilon ({\mathbf u}) + \nabla p &=& 
  \mathrm{Ra} \; T \mathbf{g},
  \\
  \nabla \cdot {\mathbf u} &=& 0,
  \\
  \frac{\partial T}{\partial t}
  +
  {\mathbf u} \cdot \nabla T
  -
  \nabla \cdot \kappa \nabla T &=& \gamma.
@f}
Here, ${\mathbf u}$ is the velocity field, $p$ the pressure, and $T$
the temperature of the fluid. $\varepsilon ({\mathbf u}) = \frac 12
[(\nabla{\mathbf u}) + (\nabla {\mathbf u})^T]$ is the symmetric
gradient of the velocity. As can be seen, velocity and pressure
solve a Stokes equation describing the motion of an incompressible
fluid. The forcing term of the fluid motion is the buoyancy of the
fluid, expressed as the product of the Rayleigh number $\mathrm{Ra}$,
the temperature $T$ and the gravity vector ${\mathbf g}$. (A possibly
more intuitive formulation would use $\mathrm{Ra} \; (T-\bar T)
\mathbf{g}$ as right hand side where $\bar T$ is the average
temperature, and the right hand side then describes the forces due to
local deviations from the average density; this formulation is
entirely equivalent if the gravity vector results from a gravity
potential $\phi$, i.e. $\mathbf{g}=-\nabla\phi$, and yields the exact
same solution except for the pressure which will now be $p+\mathrm{Ra}
\;\bar T \phi$.)

While the first two equations describe how the fluid reacts to
temperature differences by moving around, the third equation states
how the fluid motion affects the temperature field: it is an advection
diffusion equation, i.e. the temperature is attached to the fluid
particles and advected along in the flow field, with an additional
diffusion (heat conduction) term.

In these equations, $\eta$ and $\kappa$ denote the viscosity and
diffusivity coefficients. In the more general case and in many
physical applications, they may and $\eta$ often will depend on the
temperature, but we will neglect this dependence for the purpose of
this tutorial program. The term $\gamma$ on the right hand side
denotes the heat sources and may be a spatially and temporally varying
function. 

$\mathrm{Ra}$, called the <a
href="http://en.wikipedia.org/wiki/Rayleigh_number">Rayleigh
number</a> is a dimensionless number that describes the ratio of heat
transport due to convection induced by buoyancy changes from
temperature differences, and of heat transport due to thermal
diffusion. A small Rayleigh number implies that buoyancy is not strong
relative to viscosity and fluid motion $\mathbf u$ is slow enough so
that heat diffusion $\kappa\Delta T$ is the dominant heat transport
term. On the other hand, a fluid with a high Rayleigh number will show
vigorous convection that dominates heat conduction. 

For most fluids for which we are interested in computing thermal
convection, the Rayleigh number is very large, often $10^6$ or
larger. From the structure of the equations, we see that this will
lead to large pressure differences and large velocities. Consequently,
the convection term in the convection-diffusion equation for $T$ will
also be very large and an accurate solution of this equation will
require us to choose small time steps. Problems with large Rayleigh
numbers are therefore hard to solve numerically for similar reasons
that make solving the <a
href="http://en.wikipedia.org/wiki/Navier-stokes_equations">Navier-Stokes
equations</a> hard to solve when the <a
href="http://en.wikipedia.org/wiki/Reynolds_number">Reynolds number
$\mathrm{Re}$</a> is large.


<h2>Solution approach</h2>

Like the equations solved in @ref step_21 "step-21", we here have a
system of differential-algebraic equations: with respect to the time
variable, only the temperature equation is a differential equation
whereas the Stokes system for $\mathbf u$ and $p$ has no
time-derivatives and is therefore of the sort of an algebraic
constraint that has to hold at each time instant. The main difference
to @ref step_21 "step-21" is that the algebraic constraint there was a
mixed Laplace system of the form
@f{eqnarray*}
  \mathbf u + {\mathbf K}\lambda \nabla p &=& 0, \\
  \nabla\cdot \mathbf u &=& f,
@f}
where now we have a Stokes system
@f{eqnarray*}
  -\nabla \cdot \eta \varepsilon ({\mathbf u}) + \nabla p &=& f, \\
  \nabla\cdot \mathbf u &=& 0,
@f}
where $\nabla \cdot \varepsilon (\cdot)$ is an operator similar to the
Laplacian $\Delta$ applied to a vector field.

Given the similarity to what we have done in @ref step_21 "step-21",
it may not come as a surprise that we choose a similar approach,
although we will have to make adjustments for the change in operator
in the top-left corner of the differential operator. As it will turn
out, it is actually a lot easier to solve the Stokes problem than it
is to solve the mixed Laplacian, and we will make full use of this
fact! 





@code
template <int dim>
Tensor<1,dim>
extract_u (const FEValuesBase<dim> &fe_values,
           const unsigned int i,
           const unsigned int q)
{
  Tensor<1,dim> tmp;

  const unsigned int component
    = fe_values.get_fe().system_to_component_index(i).first;

  if (component < dim)
    tmp[component] = fe_values.shape_value (i,q);

  return tmp;
}



template <int dim>
double
extract_div_u (const FEValuesBase<dim> &fe_values,
               const unsigned int i,
               const unsigned int q)
{
  const unsigned int component
    = fe_values.get_fe().system_to_component_index(i).first;

  if (component < dim)
    return fe_values.shape_grad (i,q)[component];
  else
    return 0;
}



template <int dim>
Tensor<2,dim>
extract_grad_s_u (const FEValuesBase<dim> &fe_values,
		  const unsigned int i,
		  const unsigned int q)
{
  Tensor<2,dim> tmp;

  const unsigned int component
    = fe_values.get_fe().system_to_component_index(i).first;
  
  if (component < dim)
    {
      const Tensor<1,dim> grad_phi_over_2 = fe_values.shape_grad (i,q) / 2;
      
      for (unsigned int e=0; e<dim; ++e)
	tmp[component][e] += grad_phi_over_2[e];
      for (unsigned int d=0; d<dim; ++d)
	tmp[d][component] += grad_phi_over_2[d];
    }
  
  return tmp;
}


  
template <int dim>
double extract_p (const FEValuesBase<dim> &fe_values,
                  const unsigned int i,
                  const unsigned int q)
{
  const unsigned int component
    = fe_values.get_fe().system_to_component_index(i).first;

  if (component == dim)
    return fe_values.shape_value (i,q);
  else
    return 0;
}



template <int dim>
double extract_T (const FEValuesBase<dim> &fe_values,
                  const unsigned int i,
                  const unsigned int q)
{
  const unsigned int component
    = fe_values.get_fe().system_to_component_index(i).first;

  if (component == dim+1)
    return fe_values.shape_value (i,q);
  else
    return 0;
}



template <int dim>
Tensor<1,dim>
extract_grad_T (const FEValuesBase<dim> &fe_values,
                const unsigned int i,
                const unsigned int q)
{
  Tensor<1,dim> tmp;

  const unsigned int component
    = fe_values.get_fe().system_to_component_index(i).first;

  if (component == dim+1)
    tmp = fe_values.shape_grad (i,q);

  return tmp;
}
@endcode

@code
  {
    Vector<double> xx(dof_handler.n_dofs());
    std::vector<bool> p_component (dof_handler.n_dofs());
    std::vector<bool> p_boundary (dof_handler.n_dofs());
    std::vector<bool> component_mask (dim+2, false);
    component_mask[dim] = true;
    DoFTools::extract_dofs (dof_handler, component_mask, p_component);
    DoFTools::extract_boundary_dofs (dof_handler, component_mask, p_boundary);
    
    QGauss<dim>   quadrature_formula(degree+2); 
    FEValues<dim> fe_values (fe, quadrature_formula, 
			     update_values | update_gradients  | update_JxW_values);
    std::vector<std::vector<Tensor<1,dim> > >  solution_grads(fe_values.n_quadrature_points,
							      std::vector<Tensor<1,dim> > (dim+2));
    std::vector<unsigned int> local_dof_indices (fe.dofs_per_cell);
    
    typename DoFHandler<dim>::active_cell_iterator
      cell = dof_handler.begin_active(),
      endc = dof_handler.end();
    for (; cell!=endc; ++cell)
      { 
	fe_values.reinit (cell);
	fe_values.get_function_gradients (solution, solution_grads);

	cell->get_dof_indices (local_dof_indices);
	
	for (unsigned int q=0; q<fe_values.n_quadrature_points; ++q)
	  for (unsigned int i=0; i<fe.dofs_per_cell; ++i)
	    if (p_component[local_dof_indices[i]] == true)
	      { 
		double divergence(solution_grads[q][0][0] +
				  solution_grads[q][1][1]);
		xx(local_dof_indices[i]) += divergence * fe_values.shape_value(i,q) *
					    fe_values.JxW(q);
	      }
      }
    hanging_node_constraints.condense (xx);
    
    for (unsigned int i=0; i<dof_handler.n_dofs(); ++i)
      if ((p_component[i] == true) && (hanging_node_constraints.is_constrained(i) == false)
	  && (p_boundary[i] == false))
	Assert (std::fabs(xx(i)) < 1e-11, ExcInternalError());
  }
@endcode
