<a name="Intro"></a>
<h1>Introduction</h1>

<h2>The Boussinesq equations</h2>

This program deals with an interesting physical problem: how does a
fluid (i.e. a liquid or gas) behave if it experiences differences in
buoyance caused by temperature differences? It is clear that those
parts of the fluid that are hotter (and therefore lighter) are going
to rise up and those that are cooler (and denser) are going to sink
down against gravity.

In cases where the fluid moves slowly enough such that inertia effects
can be neglected, the equations that describe such behavior are the
Boussinesq equations that read as follows:
@f{eqnarray*}
  -\nabla \cdot \eta \varepsilon ({\mathbf u}) + \nabla p &=& 
  \mathrm{Ra} \; T \mathbf{g},
  \\
  \nabla \cdot {\mathbf u} &=& 0,
  \\
  \frac{\partial T}{\partial t}
  +
  {\mathbf u} \cdot \nabla T
  -
  \nabla \cdot \kappa \nabla T &=& \gamma.
@f}
Here, ${\mathbf u}$ is the velocity field, $p$ the pressure, and $T$
the temperature of the fluid. As can be seen, velocity and pressure
solve a Stokes equation describing the motion of an incompressible
fluid. The forcing term of the fluid motion is the buoyancy of the
fluid, expressed as the product of the Raleigh number $\mathrm{Ra}$,
the temperature $T$ and the gravity vector ${\mathbf g}$. (A possibly
more intuitive formulation would use $\mathrm{Ra} \; (T-\bar T)
\mathbf{g}$ as right hand side where $\bar T$ is the average
temperature, and the right hand side then describes the forces due to
local deviations from the average density; this formulation is
entirely equivalent if the gravity vector results from a gravity
potential $\phi$, i.e. $\mathbf{g}=-\nabla\phi$, and yields the exact
same solution except for the pressure which will now be $p+\mathrm{Ra}
\;\bar T \phi$.)

While the first two equations describe how the fluid reacts to
temperature differences by moving around, the third equation states
how the fluid motion affects the temperature field: it is an advection
diffusion equation, i.e. the temperature is attached to the fluid
particles and advected along in the flow field, with an additional
diffusion (heat conduction) term.

In these equations, $\eta$ and $\kappa$ denote the viscosity and
diffusivity coefficients. In the more general case and in many
physical applications, they may and $\eta$ often will depend
on the temperature, but we will neglect this dependence for the
purpose of this tutorial program. The term $\gamma$ on the right hand
side denotes the heat sources and may be a spatially and temporally
varying function.







@code
template <int dim>
Tensor<1,dim>
extract_u (const FEValuesBase<dim> &fe_values,
           const unsigned int i,
           const unsigned int q)
{
  Tensor<1,dim> tmp;

  const unsigned int component
    = fe_values.get_fe().system_to_component_index(i).first;

  if (component < dim)
    tmp[component] = fe_values.shape_value (i,q);

  return tmp;
}



template <int dim>
double
extract_div_u (const FEValuesBase<dim> &fe_values,
               const unsigned int i,
               const unsigned int q)
{
  const unsigned int component
    = fe_values.get_fe().system_to_component_index(i).first;

  if (component < dim)
    return fe_values.shape_grad (i,q)[component];
  else
    return 0;
}



template <int dim>
Tensor<2,dim>
extract_grad_s_u (const FEValuesBase<dim> &fe_values,
		  const unsigned int i,
		  const unsigned int q)
{
  Tensor<2,dim> tmp;

  const unsigned int component
    = fe_values.get_fe().system_to_component_index(i).first;
  
  if (component < dim)
    {
      const Tensor<1,dim> grad_phi_over_2 = fe_values.shape_grad (i,q) / 2;
      
      for (unsigned int e=0; e<dim; ++e)
	tmp[component][e] += grad_phi_over_2[e];
      for (unsigned int d=0; d<dim; ++d)
	tmp[d][component] += grad_phi_over_2[d];
    }
  
  return tmp;
}


  
template <int dim>
double extract_p (const FEValuesBase<dim> &fe_values,
                  const unsigned int i,
                  const unsigned int q)
{
  const unsigned int component
    = fe_values.get_fe().system_to_component_index(i).first;

  if (component == dim)
    return fe_values.shape_value (i,q);
  else
    return 0;
}



template <int dim>
double extract_T (const FEValuesBase<dim> &fe_values,
                  const unsigned int i,
                  const unsigned int q)
{
  const unsigned int component
    = fe_values.get_fe().system_to_component_index(i).first;

  if (component == dim+1)
    return fe_values.shape_value (i,q);
  else
    return 0;
}



template <int dim>
Tensor<1,dim>
extract_grad_T (const FEValuesBase<dim> &fe_values,
                const unsigned int i,
                const unsigned int q)
{
  Tensor<1,dim> tmp;

  const unsigned int component
    = fe_values.get_fe().system_to_component_index(i).first;

  if (component == dim+1)
    tmp = fe_values.shape_grad (i,q);

  return tmp;
}
@endcode

@code
  {
    Vector<double> xx(dof_handler.n_dofs());
    std::vector<bool> p_component (dof_handler.n_dofs());
    std::vector<bool> p_boundary (dof_handler.n_dofs());
    std::vector<bool> component_mask (dim+2, false);
    component_mask[dim] = true;
    DoFTools::extract_dofs (dof_handler, component_mask, p_component);
    DoFTools::extract_boundary_dofs (dof_handler, component_mask, p_boundary);
    
    QGauss<dim>   quadrature_formula(degree+2); 
    FEValues<dim> fe_values (fe, quadrature_formula, 
			     update_values | update_gradients  | update_JxW_values);
    std::vector<std::vector<Tensor<1,dim> > >  solution_grads(fe_values.n_quadrature_points,
							      std::vector<Tensor<1,dim> > (dim+2));
    std::vector<unsigned int> local_dof_indices (fe.dofs_per_cell);
    
    typename DoFHandler<dim>::active_cell_iterator
      cell = dof_handler.begin_active(),
      endc = dof_handler.end();
    for (; cell!=endc; ++cell)
      { 
	fe_values.reinit (cell);
	fe_values.get_function_gradients (solution, solution_grads);

	cell->get_dof_indices (local_dof_indices);
	
	for (unsigned int q=0; q<fe_values.n_quadrature_points; ++q)
	  for (unsigned int i=0; i<fe.dofs_per_cell; ++i)
	    if (p_component[local_dof_indices[i]] == true)
	      { 
		double divergence(solution_grads[q][0][0] +
				  solution_grads[q][1][1]);
		xx(local_dof_indices[i]) += divergence * fe_values.shape_value(i,q) *
					    fe_values.JxW(q);
	      }
      }
    hanging_node_constraints.condense (xx);
    
    for (unsigned int i=0; i<dof_handler.n_dofs(); ++i)
      if ((p_component[i] == true) && (hanging_node_constraints.is_constrained(i) == false)
	  && (p_boundary[i] == false))
	Assert (std::fabs(xx(i)) < 1e-11, ExcInternalError());
  }
@endcode
