/*
    Implementation of the classes that represent the exact solution
    and external force.

    There's not much to say here. All these classes just represent
    mathematical formulae

    by Abner Salgado.
*/



#include "../include/EqData.h"



// Force function methods
template<int dim> Force<dim>::Force( const double initial_time ): Multi_Component_Function<dim>( initial_time ){
}



template<int dim> void  Force<dim>::value_list( const std::vector<Point<dim> > &points, std::vector<double> &values,
                                                  const unsigned int ) const{
  const unsigned int n_points = points.size();
  Assert( values.size() == n_points, ExcDimensionMismatch( values.size(), n_points ) );
  for (unsigned int i=0; i<n_points; ++i)
    values[i] = Force<dim>::value( points[i] );
}



template<int dim> inline double Force<dim>::value(const Point<dim> &p, const unsigned int) const{
  double t = FunctionTime::get_time(),
         sin_2pi_x  = std::sin( 2.*PI*p(0) ),
         sin_2pi_y  = std::sin( 2.*PI*p(1) ),
         cos_2pi_x  = std::cos( 2.*PI*p(0) ),
         cos_2pi_y  = std::cos( 2.*PI*p(1) ),
         sin_pi_x   = std::sin( PI*p(0) ),
         sin_pi_y   = std::sin( PI*p(1) ),
         cos_pi_x   = std::cos( PI*p(0) ),
         cos_pi_y   = std::cos( PI*p(1) ),
         cos_t      = std::cos( t ),
         sin_t      = std::sin( t ),
         return_value = 0.;
  switch( Multi_Component_Function<dim>::component ){
    case 0:
    // Pi*sin(2*Pi*y)*sin(Pi*x)^2*cos(t)
    // -2*Pi^3*sin(2*Pi*y)*cos(Pi*x)^2*sin(t)
    // +6*Pi^3*sin(2*Pi*y)*sin(Pi*x)^2*sin(t)
    // +2*Pi^3*sin(2*Pi*y)^2*sin(Pi*x)^3*sin(t)^2*cos(Pi*x)
    // -2*Pi^3*sin(2*Pi*x)*sin(Pi*y)^2*sin(t)^2*cos(2*Pi*y)*sin(Pi*x)^2
    // -Pi*sin(Pi*x)*sin(Pi*y)*sin(t)
      return_value = PI*sin_2pi_y*sin_pi_x*sin_pi_x*cos_t
                   - 2.*PI*PI*PI*sin_2pi_y*cos_pi_x*cos_pi_x*sin_t
                   + 6.*PI*PI*PI*sin_2pi_y*sin_pi_x*sin_pi_x*sin_t
                   + 2.*PI*PI*PI*sin_2pi_y*sin_2pi_y*sin_pi_x*sin_pi_x*sin_pi_x*sin_t*sin_t*cos_pi_x
                   - 2.*PI*PI*PI*sin_2pi_x*sin_pi_y*sin_pi_y*sin_t*sin_t*cos_2pi_y*sin_pi_x*sin_pi_x
                   - PI*sin_pi_x*sin_pi_y*sin_t;

      break;
    case 1:
    // -Pi*sin(2*Pi*x)*sin(Pi*y)^2*cos(t)
    // -6*Pi^3*sin(2*Pi*x)*sin(Pi*y)^2*sin(t)
    // +2*Pi^3*sin(2*Pi*x)*cos(Pi*y)^2*sin(t)
    // +Pi*cos(Pi*x)*cos(Pi*y)*sin(t)
    // -2*Pi^3*sin(2*Pi*y)*sin(Pi*x)^2*sin(t)^2*cos(2*Pi*x)*sin(Pi*y)^2
    // +2*Pi^3*sin(2*Pi*x)^2*sin(Pi*y)^3*sin(t)^2*cos(Pi*y)
      return_value = -PI*sin_2pi_x*sin_pi_y*sin_pi_y*cos_t
                   - 6.*PI*PI*PI*sin_2pi_x*sin_pi_y*sin_pi_y*sin_t
                   + 2.*PI*PI*PI*sin_2pi_x*cos_pi_y*cos_pi_y*sin_t
                   + PI*cos_pi_x*cos_pi_y*sin_t
                   - 2.*PI*PI*PI*sin_2pi_y*sin_pi_x*sin_pi_x*sin_t*sin_t*cos_2pi_x*sin_pi_y*sin_pi_y
                   + 2.*PI*PI*PI*sin_2pi_x*sin_2pi_x*sin_pi_y*sin_pi_y*sin_pi_y*sin_t*sin_t*cos_pi_y;

      break;
    default:
      Assert( false, ExcNotImplemented() );
  };
  return return_value;
}



// Velocity function methods
template<int dim> Velocity<dim>::Velocity(const double initial_time): Multi_Component_Function<dim>( initial_time ){
}



template<int dim> void  Velocity<dim>::value_list( const std::vector<Point<dim> > &points, std::vector<double> &values,
                                                  const unsigned int ) const{
  const unsigned int n_points = points.size();
  Assert( values.size() == n_points, ExcDimensionMismatch( values.size(), n_points ) );
  for (unsigned int i=0; i<n_points; ++i)
    values[i] = Velocity<dim>::value( points[i] );
}



template<int dim> inline double Velocity<dim>::value(const Point<dim> &p, const unsigned int) const{
  double sin_2pi_x  = std::sin( 2.*PI*p(0) ),
         sin_2pi_y  = std::sin( 2.*PI*p(1) ),
         sin_pi_x   = std::sin( PI*p(0) ),
         sin_pi_y   = std::sin( PI*p(1) ),
         sin_t      = std::sin( Function<dim>::get_time() ),
         return_value = 0.;
  switch( Multi_Component_Function<dim>::component ){
    case 0:
     // pi*sin(2*pi*y)*sin(pi*x)^2*sin(t)
       return_value = PI*sin_2pi_y*sin_pi_x*sin_pi_x*sin_t;
      break;
    case 1:
      // -pi*sin(2*pi*x)*sin(pi*y)^2*sin(t)
      return_value = -PI*sin_2pi_x*sin_pi_y*sin_pi_y*sin_t;
      break;
    default:
      Assert( false, ExcNotImplemented() );
  };
  return return_value;
}



template<int dim> inline Tensor<1,dim> Velocity<dim>::gradient(const Point<dim> &p, const unsigned int) const{
  Tensor<1,dim> return_value;
  double sin_2pi_x = std::sin( 2.*PI*p(0) ),
         sin_2pi_y = std::sin( 2.*PI*p(1) ),
         cos_2pi_x = std::cos( 2.*PI*p(0) ),
         cos_2pi_y = std::cos( 2.*PI*p(1) ),
         sin_pi_x  = std::sin( PI*p(0) ),
         sin_pi_y  = std::sin( PI*p(1) ),
         cos_pi_x  = std::cos( PI*p(0) ),
         cos_pi_y  = std::cos( PI*p(1) ),
         sin_t     = std::sin( Function<dim>::get_time() );
  switch( Multi_Component_Function<dim>::component ){
    // [2*Pi^2*sin(2*Pi*y)*sin(Pi*x)*sin(t)*cos(Pi*x),
    //     2*Pi^2*cos(2*Pi*y)*sin(Pi*x)^2*sin(t)]
    case 0:
     return_value[0] = 2.*PI*PI*sin_2pi_y*sin_pi_x*sin_t*cos_pi_x;
     return_value[1] = 2.*PI*PI*cos_2pi_y*sin_pi_x*sin_pi_x*sin_t;
      break;
    case 1:
    // [-2*Pi^2*cos(2*Pi*x)*sin(Pi*y)^2*sin(t),
    // -2*Pi^2*sin(2*Pi*x)*sin(Pi*y)*sin(t)*cos(Pi*y)]
     return_value[0] = -2.*PI*PI*cos_2pi_x*sin_pi_y*sin_pi_y*sin_t;
     return_value[1] = -2.*PI*PI*sin_2pi_x*sin_pi_y*sin_t*cos_pi_y;
      break;
    default:
      Assert( false, ExcNotImplemented() );
  };
  return return_value;
}



template<int dim> void Velocity<dim>::gradient_list( const std::vector<Point<dim> > &points, std::vector< Tensor<1,dim> > &gradients,
                                                        const unsigned int ) const{
  const unsigned int n_points = points.size();
  Assert( gradients.size() == n_points, ExcDimensionMismatch( gradients.size(), n_points ) );
  for (unsigned int i=0; i<n_points; ++i)
    gradients[i] = Velocity<dim>::gradient( points[i] );
}



// Pressure function methods
template<int dim> Pressure<dim>::Pressure(const double initial_time): Function<dim>(1,initial_time){}



template<int dim> inline double Pressure<dim>::value(const Point<dim> &p, const unsigned int) const{
  // cos(pi*x)*sin(pi*y)*sin(t)
  return std::cos( PI*p(0) )*std::sin( PI*p(1) )*std::sin( Function<dim>::get_time() );
}



template<int dim> inline Tensor<1,dim> Pressure<dim>::gradient(const Point<dim> &p, const unsigned int) const{
  // || -sin(Pi*x)*Pi*sin(Pi*y)*sin(t) ||
  // || cos(Pi*x)*cos(Pi*y)*Pi*sin(t)  ||
  return ( PI*std::sin( Function<dim>::get_time() ) )* Point<dim>( -std::sin( PI*p(0) )*std::sin( PI*p(1) ),
                                                                    std::cos( PI*p(0) )*std::cos( PI*p(1) ) ) ;
}



template<int dim> void Pressure<dim>::value_list( const std::vector<Point<dim> > &points, std::vector<double> &values,
                                                    const unsigned int ) const{
  const unsigned int n_points = points.size();
  Assert( values.size() == n_points, ExcDimensionMismatch( values.size(), n_points ) );
  for (unsigned int i=0; i<n_points; ++i)
    values[i] = Pressure<dim>::value( points[i] );
}



template<int dim> inline void Pressure<dim>::gradient_list( const std::vector<Point<dim> > &points, std::vector< Tensor<1,dim> > &gradients,
                                                                const unsigned int ) const{
  const unsigned int n_points = points.size();
  Assert( gradients.size() == n_points, ExcDimensionMismatch( gradients.size(), n_points ) );
  for (unsigned int i=0; i<n_points; ++i)
    gradients[i] = Pressure<dim>::gradient( points[i] );
}



// explicit template instantiation
template class Force<deal_II_dimension>;
template class Velocity<deal_II_dimension>;
template class Pressure<deal_II_dimension>;
