<br>

<i>
This program grew out of a student project by Abner Salgado at Texas A&M
University. Most of the work for this program is by him.
</i>

<a name="Intro"></a>
<h1> Introduction </h1>

<a name="Motivation"></a>
<h3> Motivation </h3>
The purpose of this program is to show how to effectively solve the incompressible time-dependent
Navier-Stokes equations. These equations describe the flow of a viscous incompressible fluid and read
@f{align*}
  u_t + u \cdot \nabla u - \nu \Delta u + \nabla p = f, \\
  \nabla \cdot u = 0,
@f}
where $u$ represents the velocity of the flow and $p$ the pressure. This system of equations is supplemented by
the initial condition
@f[
  u |_{t=0} = u_0,
@f]
with $u_0$ sufficiently smooth and solenoidal, and suitable boundary conditions. For instance, an admissible boundary
condition, is
@f[
  u|_{\partial\Omega} = u_b.
@f]
It is possible to prescribe other boundary conditions as well. In the test case that we solve here the boundary
is partitioned into two disjoint subsets $\partial\Omega = \Gamma_1 \cup \Gamma_2$ and we have
@f[
  u|_{\Gamma_1} = u_b, \qquad u\times n|_{\Gamma_2} = 0.
@f]
where $n$ is the outer unit normal. The boundary condition on $\Gamma_2$ is used to model outflow conditions.

In previous tutorial programs (see for instance @ref step_20 "step-20" and
@ref step_22 "step-22") we have seen
how to solve the time-independent Stokes equations using a Schur complement approach. For the
time-dependent case, after time discretization, we would arrive at a system like
@f{align*}
  \frac1\tau u^k - \nu \Delta u^k + \nabla p^k = F^k, \\
  \nabla \cdot u^k = 0,
@f}
where $\tau$ is the time-step. Although the structure of this system is similar to the Stokes system and thus
it could be solved using a Schur complement approach, it turns out that the condition number of the
Schur complement is proportional to $\tau^{-2}$. This makes the system very
difficult to solve, and means that for the Navier-Stokes equations, this is
not a useful avenue to the solution.

<a name="Projection"></a>
<h3> Projection methods </h3>

Rather, we need to come up with a different approach to solve the time-dependent Navier-Stokes
equations. The difficulty in their solution comes from the fact that the velocity and the pressure are coupled
through the constraint
@f[
  \nabla \cdot u = 0,
@f]
for which the pressure is the Lagrange multiplier.
Projection methods aim at decoupling this constraint from the diffusion (Laplace) operator.

Let us shortly describe how the projection methods look like in a semi-discrete setting. The objective is to
obtain a sequence of velocities $\{u^k\}$ and pressures $\{p^k\}$. We will
also obtain a sequence $\{\phi^k\}$ of auxiliary variables.
Suppose that from the initial conditions, and an application of a first order method we have found
$(u^0,p^0,\phi^0=0)$ and $(u^1,p^1,\phi^1=p^1-p^0)$. Then the projection method consists of three steps:

<ul>
  <li> <b>Step 0</b>: Extrapolation. Define:
  @f[
    u^\star = 2u^k - u^{k-1}, \quad p^\sharp = p^k + \frac43 \phi^k - \frac13 \phi^{k-1}.
  @f]
  <li> <b>Step 1</b>: Diffusion step. We find $u^{k+1}$ that solves the single
  linear equation
  @f[
    \frac1{2\tau}\left( 3u^{k+1} - 4u^k + u^{k-1} \right)
    + u^\star \cdot\nabla u^{k+1} + \frac12 \left( \nabla \cdot u^\star \right) u^{k+1}
    -\nu \Delta u^{k+1} + \nabla p^\sharp
    = f^{k+1},
    \quad
    u^{k+1}|_{\partial\Omega} = 0.
  @f]
  Note in particular that this formulation completely decouples the velocity
  components from each other. As a consequence, rather than having to solve a
  coupled system for all $d$ velocities together, we can solve $d$ independent
  equations which, conveniently also all share the same system matrix.

  <li> <b>Step 2</b>: Projection. Find $\phi^{k+1}$ that solves
  @f[
    \Delta \phi^{k+1} = \frac3{2\tau} \nabla \cdot u^{k+1},
    \quad
    \partial_n \phi^{k+1} = 0.
  @f]
  <li> <b>Step 3</b>: Pressure correction. Here we have two options:
    <ul>
      <li> <i>Incremental Method in Standard Form</i>. The pressure is updated by:
      @f[
        p^{k+1} = p^k + \phi^{k+1}.
      @f]
      <li> <i>Incremental Method in Rotational Form</i>. In this case
      @f[
        p^{k+1} = p^k + \phi^{k+1} - \nu \nabla \cdot u^{k+1}.
      @f]
    </ul>
</ul>

Without going into details, which can be found in the corresponding literature, let us remark a few things about the
projection methods that we have just described:
<ul>
  <li> The advection term $u\cdot\nabla u$ is replaced by its <i>skew symmetric form</i>
  @f[
    u \cdot \nabla u + \frac12 \left( \nabla\cdot u \right) u.
  @f]
  This is consistent with the continuous equation (because $\nabla\cdot u$,
  though this is not true pointwise for the discrete solution) and it is needed to guarantee unconditional stability of the
  time-stepping scheme. Moreover, to linearize the term we use the second order extrapolation $u^\star$ of
  $u^{k+1}$.
  <li> The projection step is a realization of the Helmholtz decomposition
  @f[
    L^2(\Omega)^d = H \oplus \nabla H^1(\Omega),
  @f]
  where
  @f[
    H = \left\{ v \in L^2(\Omega)^d:\  \nabla\cdot v =0, \  v\cdot n|_{\partial\Omega} = 0 \right\}.
  @f]
  Indeed, if we use this decomposition on $u^{k+1}$ we obtain
  @f[
    u^{k+1} = v^{k+1} + \nabla \left( \frac{2\tau}{3}  \phi^{k+1} \right),
  @f]
  with $v^{k+1}\in H$. Taking the divergence of this equation we arrive at the projection equation.
  <li> The more accurate of the two variants outlined above is the rotational
  one. However, the program below implements both variants. Moreover, in the author's experience,
  the standard form is the one that should be used if, for instance, the viscosity $\nu$ is variable.
</ul>

<a name = "implementation"></a>
<h3> Implementation </h3>

Our implementation of the projection methods follows <i>verbatim</i> the description given above. We must note,
however, that as opposed to most other problems that have several solution components, we do not use
vector-valued finite elements. Instead, we use separate finite elements the components of the velocity
and the pressure, respectively, and use different <code>DoFHandler</code>'s for those as well. The main
reason for doing this is that, as we see from the description of the scheme, the <code>dim</code> components
of the velocity and the pressure are decoupled. As a consequence, the equations for all the velocity components
look all the same, have the same system matrix, and can be solved in %parallel. Obviously, this approach
has also its disadvantages. For instance, we need to keep several <code>DoFHandler</code>s and iterators
synchronized when assembling matrices and right hand sides; obtaining quantities that are inherent to
vector-valued functions (e.g. divergences) becomes a little awkward, and others.

<a name ="testcase"></a>
<h3> The Testcase </h3>

The testcase that we use for this program consists of the flow around a square obstacle. The geometry is
as follows:

@image html geometry.png

with $H=4.1$, making the geometry slightly non-symmetric.

We impose no-slip boundary conditions on both the top and bottom walls and the obstacle. On the left side we
have the inflow boundary condition
@f[
  u =
  \left( \begin{array}{c} 4 U_m y (H-y)/H^2 \\ 0 \end{array} \right),
@f]
with $U_m = 1.5$, i.e. the inflow boundary conditions correspond to Poiseuille flow for this configuration. Finally, on the right
vertical wall we impose the condition that the vertical component of the velocity should be zero.
The Reynolds number is $Re=\frac{1}{\nu}=100$ and the final time $T=10$.


