<a name="Intro"></a>
<h1>Introduction</h1>


<h3>Overview</h3>

This example is devoted to the <em>discontinuous Galerkin method</em>, or
in short: DG method. It includes the following topics.
<ol>
<li> Discretization of the linear transport equation with the DG method
<li> Two different assembling routines for the system matrix based on
  face terms given as a sum of integrals that
\begin{enumerate}
<li> loops over all cell and all their faces, or that
<li> loops over all faces, whereas each face is treated only once.
\end{enumerate}
<li> Time comparison of the two assembling routines.
</ol>


<h3>Problem</h3>

The DG method was first introduced to discretize simple transport
equations. Over the past years DG methods have been applied to a
variety of problems and many different schemes were introduced
employing a big zoo of different convective and diffusive fluxes.  As
this example's purpose is to illustrate some implementational issues
of the DG discretization only, here we simply consider the linear
transport equation
<a name="step-12.transport-equation">@f[
  \nabla\cdot \left({\mathbf \beta} u\right)=f  \qquad\mbox{in }\Omega,
\qquad\qquad\qquad\mathrm{[transport-equation]}@f]</a>
subject to the boundary conditions
@f[
u=g\quad\mbox{on }\Gamma_-,
@f]
on the inflow part $\Gamma_-$ of the boundary $\Gamma=\partial\Omega$
of the domain.  Here, ${\mathbf \beta}={\mathbf \beta}({\bf x})$ denotes a
vector field, $f$ a source function, $u$ the (scalar) solution
function, $g$ a boundary value function,
@f[
\Gamma_-:=\{{\bf x}\in\Gamma, {\mathbf \beta}({\bf x})\cdot{\bf n}({\bf x})<0\}
@f]
the inflow part of the boundary of the domain and ${\bf n}$ denotes
the unit outward normal to the boundary $\Gamma$. Equation
<a href="#step-12.transport-equation">[transport-equation]</a> is the conservative version of the
transport equation already considered in step 9 of this tutorial.

In particular, we consider problem <a href="#step-12.transport-equation">[transport-equation]</a> on
$\Omega=[0,1]^2$ with ${\mathbf \beta}=\frac{1}{|x|}(-x_2, x_1)$
representing a circular counterclockwise flow field, $f=0$ and $g=1$
on ${\bf x}\in\Gamma_-^1:=[0,0.5]\times\{0\}$ and $g=0$ on ${\bf x}\in
\Gamma_-\setminus \Gamma_-^1$.


<h3>Discretization</h3>

Following the general paradigm of deriving DG discretizations for
purely hyperbolic equations, we first consider the general hyperbolic
problem
@f[
  \nabla\cdot {\mathcal F}(u)=f  \qquad\mbox{in }\Omega,
@f]
subject to appropriate boundary conditions. Here ${\mathcal F}$
denotes the flux function of the equation under consideration that in
our case, see equation <a href="#step-12.transport-equation">[transport-equation]</a>, is represented by
${\mathcal F}(u)={\mathbf \beta} u$.  For deriving the DG
discretization we start with a variational, mesh-dependent
formulation of the problem,
@f[
  \sum_\kappa\left\{-({\mathcal F}(u),\nabla v)_\kappa+({\mathcal
  F}(u)\cdot{\bf n}, v)_{\partial\kappa}\right\}=(f,v)_\Omega,
@f]
that originates from <a href="#step-12.transport-equation">[transport-equation]</a> by multiplication with
a test function $v$ and integration by parts on each cell $\kappa$ of
the triangulation. Here $(\cdot, \cdot)_\kappa$ and $(\cdot,
\cdot)_{\partial\kappa}$ simply denote the integrals over the cell
$\kappa$ and the boundary $\partial\kappa$ of the cell,
respectively. To discretize the problem, the functions $u$ and $v$ are
replaced by discrete functions $u_h$ and $v_h$ that in the case of
discontinuous Galerkin methods belong to the space $V_h$ of
discontinuous piecewise polynomial functions of some degree $p$. Due
to the discontinuity of the discrete function $u_h$ on interelement
faces, the flux ${\mathcal F}(u)\cdot{\bf n}$ must be replaced by a
<em>numerical flux</em> function ${\mathcal H}(u_h^+, u_h^-, {\bf n})$,
where $u_h^+|_{\partial\kappa}$ denotes the inner trace (w.r.t.  the
cell $\kappa$) of $u_h$ and $u_h^-|_{\partial\kappa}$ the outer trace,
i.e. the value of $u_h$ on the neighboring cell. Furthermore the
numerical flux function ${\mathcal H}$, among other things, must be
consistent, i.e.
@f[
{\mathcal H}(u,u,{\bf n})={\mathcal F}(u)\cdot{\bf n},
@f]
and conservative, i.e.
<a name="step-12.conservativity">@f[
{\mathcal H}(v,w,{\bf n})=-{\mathcal H}(w,v,-{\bf n}).
\qquad\qquad\qquad\mathrm{[conservative]}@f]</a>
This yields the following <em>discontinuous Galerkin
  discretization</em>: find $u_h\in V_h$ such that
<a name="step-12.dg-general1">@f[
  \sum_\kappa\left\{-({\mathcal F}(u_h),\nabla v_h)_\kappa+({\mathcal H}(u_h^+,u_h^-,{\bf n}), v_h)_{\partial\kappa}\right\}=(f,v_h)_\Omega, \quad\forall v_h\in V_h.
\qquad\qquad\qquad\mathrm{[dg-general1]}@f]</a>
%Boundary conditions are realized by replacing $u_h^-$ on the inflow boundary $\Gamma_-$ by the boundary function $g$.
In the special case of the transport equation
<a href="#step-12.transport-equation">[transport-equation]</a> the numerical flux in its simplest form
is given by
<a name="step-12.upwind-flux">@f[
  {\mathcal H}(u_h^+,u_h^-,{\bf n})({\bf x})=\left\{\begin{array}{ll}
      ({\mathbf \beta}\cdot{\bf n}\, u_h^-)({\bf x}),&\mbox{for } {\mathbf \beta}({\bf x})\cdot{\bf n}({\bf x})<0,\\
      ({\mathbf \beta}\cdot{\bf n}\, u_h^+)({\bf x}),&\mbox{for } {\mathbf \beta}({\bf x})\cdot{\bf n}({\bf x})\geq 0,
\end{array}
\right.
\qquad\qquad\qquad\mathrm{[upwind-flux]}@f]</a>
where on the inflow part of the cell the value is taken from the
neighboring cell, $u_h^-$, and on the outflow part the value is
taken from the current cell, $u_h^+$.  Hence, the discontinuous Galerkin
scheme for the transport equation <a href="#step-12.transport-equation">[transport-equation]</a> is given
by: find $u_h\in V_h$ such that for all $v_h\in V_h$ following
equation holds:
<a name="step-12.dg-transport1">@f[
  \sum_\kappa\left\{-(u_h,{\mathbf \beta}\cdot\nabla v_h)_\kappa
  +({\mathbf \beta}\cdot{\bf n}\, u_h, v_h)_{\partial\kappa_+}
  +({\mathbf \beta}\cdot{\bf n}\, u_h^-, v_h)_{\partial\kappa_-\setminus\Gamma}\right\}
  =(f,v_h)_\Omega-({\mathbf \beta}\cdot{\bf n}\, g, v_h)_{\Gamma_-},
\qquad\qquad\qquad\mathrm{[dg-transport1]}@f]</a>
where $\partial\kappa_-:=\{{\bf x}\in\partial\kappa,
{\mathbf \beta}({\bf x})\cdot{\bf n}({\bf x})<0\}$ denotes the inflow boundary
and $\partial\kappa_+=\partial\kappa\setminus \partial \kappa_-$ the
outflow part of cell $\kappa$. Below, this equation will be referred
to as <em>first version</em> of the DG method. We note that after a
second integration by parts, we obtain: find $u_h\in V_h$ such that
@f[
  \sum_\kappa\left\{(\nabla\cdot\{{\mathbf \beta} u_h\},v_h)_\kappa
  -({\mathbf \beta}\cdot{\bf n} [u_h], v_h)_{\partial\kappa_-}\right\}
  =(f,v_h)_\Omega, \quad\forall v_h\in V_h,
@f]
where $[u_h]=u_h^+-u_h^-$ denotes the jump of the discrete function
between two neighboring cells and is defined to be $[u_h]=u_h^+-g$ on
the boundary of the domain. This is the discontinuous Galerkin scheme
for the transport equation given in its original notation.
Nevertheless, we will base the implementation of the scheme on the
form given by <a href="#step-12.dg-general1">[dg-general1]</a> and <a href="#step-12.upwind-flux">[upwind-flux]</a>,
or <a href="#step-12.dg-transport1">[dg-transport1]</a>, respectively.

Finally, we rewrite <a href="#step-12.dg-general1">[dg-general1]</a> in terms of a summation over all
faces where each face $e=\partial \kappa\cap\partial \kappa'$
between two neighboring cells $\kappa$ and $\kappa'$ occurs twice:
Find $u_h\in V_h$ such that
<a name="step-12.dg-general2">@f[
  -\sum_\kappa({\mathcal F}(u_h),\nabla v_h)_\kappa+\sum_e\left\{({\mathcal H}(u_h^+,u_h^-,{\bf n}), v_h)_e+({\mathcal H}(u_h^-, u_h^+,-{\bf n}), v_h^-)_{e\setminus\Gamma}\right\}=(f,v_h)_\Omega \quad\forall v_h\in V_h,
\qquad\qquad\qquad\mathrm{[dg-general2]}@f]</a>
By employing <a href="#step-12.conservativity">[conservativity]</a> of the numerical flux
this equation simplifies to: find $u_h\in V_h$ such that
<a name="step-12.dg-general3">@f[
  -\sum_\kappa({\mathcal F}(u_h),\nabla v_h)_\kappa+\sum_e({\mathcal H}(u_h^+,u_h^-,{\bf n}), [v_h])_{e\setminus\Gamma}+({\mathcal H}(u_h,g,{\bf n}), v_h)_{\Gamma}=(f,v_h)_\Omega \quad\forall v_h\in V_h.
\qquad\qquad\qquad\mathrm{[dg-general3]}@f]</a>
Whereas the outer unit normal ${\bf n}|_{\partial\kappa}$ is uniquely
defined this is not so for ${\bf n}_e$ as the latter might be the
normal from either side of the face. Hence, we need to fix the normal
${\bf n}$ on the face to be one of the two normals and denote the
other normal by $-{\bf n}$.  This way we get $-{\bf n}$ in the second
face term in <a href="#step-12.dg-general2">[dg-general2]</a> that finally produces the
minus sign in the jump $[v_h]$ in equation <a href="#step-12.dg-general3">[dg-general3]</a>.

For the linear transport equation <a href="#step-12.transport-equation">[transport-equation]</a>
equation <a href="#step-12.dg-general3">[dg-general3]</a> simplifies to
<a name="step-12.dg-transport2">@f[
  -\sum_\kappa(u_h,{\mathbf \beta}\cdot\nabla v_h)_\kappa+\sum_e\left\{({\mathbf \beta}\cdot{\bf n}\, u_h, [v_h])_{e_+\setminus\Gamma}+({\mathbf \beta}\cdot{\bf n}\, u_h^-, [v_h])_{e_-\setminus\Gamma}\right\}=(f,v_h)_\Omega-({\mathbf \beta}\cdot{\bf n}\, g, v_h)_{\Gamma_-},
\qquad\qquad\qquad\mathrm{[dg-transport2]}@f]</a>
which will be refered to as <em>second version</em> of the DG method.


<h3>Implementation</h3>


As already mentioned at the beginning of this example we will
implement assembling the system matrix in two different ways.
The first one will be based on the first version <a href="#step-12.dg-transport1">[dg-transport1]</a>
of the DG method that includes a sum of integrals over all cell
boundaries $\partial\kappa$. This is realized by a loop over all cells and
a nested loop over all faces of each cell.  Thereby each inner face
$e=\partial\kappa\cap\partial \kappa'$ is treated twice, the first
time when the outer loop treats cell $\kappa$ and the second time when it
treats cell $\kappa'$. This way some values like the shape function
values at quadrature points on faces need to be computed twice.

To overcome this overhead and for comparison, we implement
assembling of matrix also in a second and different way. This will
be based on the second version <a href="#step-12.dg-transport2">[dg-transport2]</a> that
includes a sum of integrals over all faces $e$. Here, several
difficulties occurs.
<ol>
<li> As degrees of freedom are associated with cells (and not to faces)
  and as a normal is only defined w.r.t. a cell adjacent to the face we
  cannot simply run over all faces of the triangulation but need to
  perform the nested loop over all cells and all faces of each cell
  like in the first implementation.  This, because in <code>deal.II</code>
  faces are accessible from cells but not visa versa.
<li> Due to the nested loop we arrive twice at each face. In order to
  assemble face terms only once we either need to track which
  faces we have treated before, or we introduce a simple rule that decides
  which of the two adjacent cells the face should be accessed and
  treated from.  Here, we employ the second approach and define the
  following rule:
  <ol>
  <li> If the two cells adjacent to a face are of the same refinement level we access and treat the face from the cell with lower index on this level.
  <li> If the two cells are of different refinement levels we access
    and treat the face from the coarser cell.
  </ol>
</ol>
Before we start with the description of the code we first introduce
its main ingredients. The main class is called
<code>DGMethod</code>. It comprises all basic objects like the
triangulation, the dofhandler, the system matrix and solution vectors.
Furthermore it has got some member functions, the most prominent of
which are the <code>assemble_system1</code> and <code>assemble_system2</code>
functions that implement the two different ways mentioned above for
assembling the system matrix. Within these assembling routines several
different cases must be distinguished while performing the nested
loops over all cells and all faces of each cell and assembling the
respective face terms. While sitting on the current cell and looking
at a specific face there are the cases
<ol>
<li> face is at boundary,
<li> neighboring cell is finer,
<li> neighboring cell is of the same refinement level, and
<li> neighboring cell is coarser
</ol>
where the `neighboring cell' and the current cell have the mentioned
faces in common. In last three cases the assembling of the face terms
are almost the same. Hence, we can implement the assembling of the
face terms either by `copy and paste' (the lazy way, whose
disadvantages come up when the scheme or the equation might want to be
changed afterwards) or by calling a separate function that covers all
three cases. To be kind of educational within this tutorial we perform
the latter approach, of course. We go even further and encapsulate
this function and everything that is needed for assembling the
specific equation under consideration within a class called
<code>DGTransportEquation</code>. This class includes objects of all
equation--specific functions, the <code>RHS</code> and the
<code>BoundaryValues</code> class, both derived from the <code>Function</code>
class, and the <code>Beta</code> class representing the vector field.
Furthermore, the <code>DGTransportEquation</code> class comprises member
functions <code>assemble_face_terms1</code> and
<code>assemble_face_terms2</code> that are invoked by the
<code>assemble_system1</code> and <code>assemble_system2</code> functions of the
<code>DGMethod</code>, respectively, and the functions
<code>assemble_cell_term</code> and <code>assemble_boundary_term</code> that
are the same for both assembling routines. Due to the encapsulation of
all equation- and scheme-specific functions, the
<code>DGTransportEquation</code> class can easily be replaced by a similar
class that implements a different equation and a different DG method.
Indeed, the implementation of the <code>assemble_system1</code> and
<code>assemble_system2</code> functions of the <code>DGMethod</code> class will
be general enough to serve for different DG methods, different
equations, even for systems of equations (!) and, under small
modifications, for nonlinear problems. Finally, we note that the
program is dimension independent, i.e. after replacing
<code>DGMethod<2></code> by <code>DGMethod<3></code> the code runs in 3d.







