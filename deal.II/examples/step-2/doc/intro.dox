<a name="Intro"></a>
<h1>Introduction</h1>

After we have created a grid in the previous example, we now show how
to define degrees of freedom on this mesh. For this example, we
will use the lowest order ($Q_1$) finite elements, for which the degrees
of freedom are associated with the vertices of the mesh. Later
examples will demonstrate higher order elements where degrees of freedom are
not necessarily associated with vertices any more, but can be associated
with edges, faces, or cells.

Defining degrees of freedom ("DoF"s in short) on a mesh is a rather
simple task, since the library does all the work for you. Essentially,
all you have to do is create a finite element object (from one of the
many finite element classes deal.II already has, see for example the
@ref fe documentation) and give it to a DoFHandler object through the
DoFHandler::distribute_dofs function. The DoFHandler is a class that
manages which degrees of freedom live where, i.e. it can answer
questions like "how many degrees of freedom are there globally" and
"on this cell, give me the global indices of the shape functions that
live here". This is the sort of information you need when determining
how big your system matrix should be, and when copying the
contributions of a single cell into the global matrix.

The next step would then be to compute a matrix and right hand side
corresponding to a particular differential equation using this finite element
and mesh. We will keep this step for the step-3 program and rather talk about
one practical aspect of a finite element program, namely that finite element
matrices are almost always very sparse, i.e. almost all entries in these
matrices are zero. (To be more precise, we say a discretization leads to a
sparse matrix if the number of nonzero entries <i>per row</i> in the matrix is
bounded by a number that is independent of the overall number of degrees of
freedom. For example, the simple 5-point stencil of a finite difference
approximation of the Laplace equation leads to a sparse matrix since the
number of nonzero entries per row is five, and therefore independent of the
total size of the matrix.)  Sparsity is one of the distinguishing feature of
the finite element method compared to, say, approximating the solution of a
partial differential equation using a Taylor expension and matching
coefficients, or using a Fourier basis. In practical terms, it is the sparsity
of matrices that enables us to solve problems with millions or billions of
unknowns.

The sparsity is generated by the fact that finite element shape
functions are defined locally on individual cells, rather than
globally, and that the local differential operators in the bilinear
form only couple shape functions that have some overlap. By default,
the DoFHandler class enumerates degrees of freedom on a mesh in a
rather random way; consequently, the sparsity pattern is also not
optimized for any particular purpose. However, for
some algorithms, especially for some linear solvers and preconditioners, it is
advantageous to have the degrees of freedom numbered in a certain
order, and we will use the algorithm of Cuthill and McKee to do
so. The results are written to a file and visualized using GNUPLOT; you get to
see the outcome in the <a href="#Results">results section below</a>.
