/* $Id: step-4.cc,v 1.34 2006/02/06 21:33:10 wolf Exp $ */
/* Author: Wolfgang Bangerth, Texas A&M University, 2006 */

/*    $Id: step-4.cc,v 1.34 2006/02/06 21:33:10 wolf Exp $       */
/*    Version: $Name:  $                                          */
/*                                                                */
/*    Copyright (C) 2006 by the deal.II authors */
/*                                                                */
/*    This file is subject to QPL and may not be  distributed     */
/*    without copyright and license information. Please refer     */
/*    to the file deal.II/doc/license.html for the  text  and     */
/*    further information on this license.                        */


				 // @sect3{Include files}

				 // We start with the usual assortment
				 // of include files that we've seen
				 // in so many of the previous tests:
#include <base/quadrature_lib.h>
#include <base/function.h>
#include <base/logstream.h>

#include <lac/vector.h>
#include <lac/full_matrix.h>
#include <lac/sparse_matrix.h>
#include <lac/solver_cg.h>
#include <lac/precondition.h>

#include <grid/tria.h>
#include <grid/grid_generator.h>
#include <grid/tria_accessor.h>
#include <grid/tria_iterator.h>

#include <dofs/dof_handler.h>
#include <dofs/dof_accessor.h>
#include <dofs/dof_tools.h>
#include <dofs/dof_constraints.h>

#include <fe/fe_q.h>
#include <fe/fe_values.h>

#include <numerics/data_out.h>

#include <fstream>
#include <iostream>
#include <sstream>

				 // Here are the only three include
				 // files of some new interest: The
				 // first one is already used, for
				 // example, for the
				 // VectorTools::interpolate_boundary_values
				 // and
				 // VectorTools::apply_boundary_values
				 // functions. However, we here use
				 // another function in that class,
				 // VectorTools::project to compute
				 // our initial values as the $L^2$
				 // projection of the continuous
				 // initial values. Furthermore, we
				 // use
				 // VectorTools::create_right_hand_side
				 // to generate the integrals
				 // $(f^n,\phi^n_i)$. These were
				 // previously always generated by
				 // hand in
				 // <code>assemble_system</code> or
				 // similar functions in application
				 // code. However, we're too lazy to
				 // do that here, so simply use a
				 // library function:
#include <numerics/vectors.h>

				 // In a very similar vein, we are
				 // also too lazy to write the code to
				 // assemble mass and Laplace
				 // matrices, although it would have
				 // only taken copying the relevant
				 // code from any number of previous
				 // tutorial programs. Rather, we want
				 // to focus on the things that are
				 // truly new to this program and
				 // therefore use the
				 // MatrixTools::create_mass_matrix
				 // and
				 // MatrixTools::create_laplace_matrix
				 // functions. They are declared here:
#include <numerics/matrices.h>

				 // Finally, here is an include file
				 // that contains all sorts of tool
				 // functions that one sometimes
				 // needs. In particular, we need the
				 // Utilities::int_to_string class
				 // that, given an integer argument,
				 // returns a string representation of
				 // it. It is particularly useful
				 // since it allows for a second
				 // parameter indicating the number of
				 // digits to which we want the result
				 // padded with leading zeros. We will
				 // use this to write output files
				 // that have the form
				 // <code>solution-XXX.gnuplot</code>
				 // where <code>XXX</code> denotes the
				 // number of the time step and always
				 // consists of three digits even if
				 // we are still in the single or
				 // double digit time steps.
#include <base/utilities.h>


				 // @sect3{The <code>WaveEquation</code> class}

				 // Next comes the declaration of the
				 // main class. It's public interface
				 // of functions is like in most of
				 // the other tutorial programs. Worth
				 // mentioning is that we now have to
				 // store three matrices instead of
				 // one: the mass matrix $M$, the
				 // Laplace matrix $A$, and the system
				 // matrix $M+k^2\theta^2A$ used when
				 // solving for $U^n$. Likewise, we
				 // need solution vectors for
				 // $U^n,V^n$ as well as for the
				 // corresponding vectors at the
				 // previous time step,
				 // $U^{n-1},V^{n-1}$. The
				 // <code>system_rhs</code> will be
				 // used for whatever right hand side
				 // vector we have when solving one of
				 // the two linear systems we have to
				 // solve in each time step. These
				 // will be solved in the two
				 // functions <code>solve_u</code> and
				 // <code>solve_v</code>.
				 //
				 // Finally, the variable
				 // <code>theta</code> is used to
				 // indicate the parameter $\theta$
				 // that is used to define which time
				 // stepping scheme to use. The rest
				 // is self-explanatory.
template <int dim>
class WaveEquation 
{
  public:
    WaveEquation ();
    void run ();
    
  private:
    void setup_system ();
    void solve_u ();
    void solve_v ();
    void output_results () const;

    Triangulation<dim>   triangulation;
    FE_Q<dim>            fe;
    DoFHandler<dim>      dof_handler;

    ConstraintMatrix constraints;
    
    SparsityPattern      sparsity_pattern;
    SparseMatrix<double> system_matrix;
    SparseMatrix<double> mass_matrix;
    SparseMatrix<double> laplace_matrix;

    Vector<double>       solution_u, solution_v;
    Vector<double>       old_solution_u, old_solution_v;
    Vector<double>       system_rhs;

    double time, time_step;
    unsigned int timestep_number;
    const double theta;
};



				 // @sect3{Equation data}

				 // Before we go on filling in the
				 // details of the main class, let us
				 // define the equation data
				 // corresponding to the problem,
				 // i.e. initial and boundary values
				 // as well as a right hand side
				 // class. We do so using classes
				 // derived from the Function class
				 // template that has been used many
				 // times before, so the following
				 // should not be a surprise.
				 //
				 // Let's start with initial values
				 // and choose zero for both the value
				 // $u$ as well as its time
				 // derivative, the velocity $v$:
template <int dim>
class InitialValuesU : public Function<dim> 
{
  public:
    InitialValuesU () : Function<dim>() {};
    
    virtual double value (const Point<dim>   &p,
			  const unsigned int  component = 0) const;
};


template <int dim>
class InitialValuesV : public Function<dim> 
{
  public:
    InitialValuesV () : Function<dim>() {};
    
    virtual double value (const Point<dim>   &p,
			  const unsigned int  component = 0) const;
};



template <int dim>
double InitialValuesU<dim>::value (const Point<dim>  &/*p*/,
				   const unsigned int component) const 
{
  Assert (component == 0, ExcInternalError());
  return 0;
}



template <int dim>
double InitialValuesV<dim>::value (const Point<dim>  &/*p*/,
				   const unsigned int component) const 
{
  Assert (component == 0, ExcInternalError());
  return 0;
}



				 // Secondly, we have the right hand
				 // side forcing term. Boring as we
				 // are, we choose zero here as well:
template <int dim>
class RightHandSide : public Function<dim> 
{
  public:
    RightHandSide () : Function<dim>() {};
    
    virtual double value (const Point<dim>   &p,
			  const unsigned int  component = 0) const;
};



template <int dim>
double RightHandSide<dim>::value (const Point<dim>  &/*p*/,
				  const unsigned int component) const 
{
  Assert (component == 0, ExcInternalError());
  return 0;
}



				 // Finally, we have boundary
				 // values. They are as described in
				 // the introduction:
template <int dim>
class BoundaryValues : public Function<dim> 
{
  public:
    BoundaryValues () : Function<dim>() {};
    
    virtual double value (const Point<dim>   &p,
			  const unsigned int  component = 0) const;
};




template <int dim>
double BoundaryValues<dim>::value (const Point<dim> &p,
				   const unsigned int component) const 
{
  Assert (component == 0, ExcInternalError());

  if ((this->get_time() <= 0.5) &&
      (p[0] < 0) &&
      (p[1] < 1./3) &&
      (p[1] > -1./3))
    return std::sin (this->get_time() * 4 * deal_II_numbers::PI);
  else
    return 0;
}




				 // @sect3{Implementation of the <code>WaveEquation</code> class}

				 // The implementation of the actual logic is
				 // actually fairly short, since we relegate
				 // things like assembling the matrices and
				 // right hand side vectors to the
				 // library. The rest boils down to not much
				 // more than 130 lines of actual code, a
				 // significant fraction of which is
				 // boilerplate code that can be taken from
				 // previous example programs (e.g. the
				 // functions that solve linear systems, or
				 // that generate output).
				 //
				 // Let's start with the constructor:
template <int dim>
WaveEquation<dim>::WaveEquation () :
                fe (1),
		dof_handler (triangulation),
		time_step (1./64),
		theta (0.5)
{}


				 // @sect4{WaveEquation::setup_system}

				 // The next function is the one that sets up
				 // the mesh, DoFHandler, and matrices and
				 // vectors at the beginning of the program,
				 // i.e. before the first time step. The first
				 // few lines are pretty much standard if
				 // you've read at least to step-6:
template <int dim>
void WaveEquation<dim>::setup_system ()
{
  GridGenerator::hyper_cube (triangulation, -1, 1);
  triangulation.refine_global (7);
  
  std::cout << "Number of active cells: "
	    << triangulation.n_active_cells()
	    << std::endl
	    << "Total number of cells: "
	    << triangulation.n_cells()
	    << std::endl
  	    << std::endl;

  dof_handler.distribute_dofs (fe);

  std::cout << "   Number of degrees of freedom: "
	    << dof_handler.n_dofs()
	    << std::endl;

  sparsity_pattern.reinit (dof_handler.n_dofs(),
			   dof_handler.n_dofs(),
			   dof_handler.max_couplings_between_dofs());
  DoFTools::make_sparsity_pattern (dof_handler, sparsity_pattern);
  sparsity_pattern.compress();

				   // Then comes a block where we have to
				   // initialize the 3 matrices we need in the
				   // course of the program: the mass matrix,
				   // the laplace matrix, and the matrix
				   // $M+k^2\theta^2A$ used when solving for
				   // $U^n$ in each time step.
				   //
				   // When setting up these matrices, note
				   // that they all make use of the same
				   // sparsity pattern object. Finally, the
				   // reason why matrices and sparsity
				   // patterns are separate objects in deal.II
				   // (unlike in many other finite element or
				   // linear algebra classes) becomes clear:
				   // in a significant fraction of
				   // applications, one has to hold several
				   // matrices that happen to have the same
				   // sparsity pattern, and there is no reason
				   // for them not to share this information,
				   // rather than re-building and wasting
				   // memory on it several times.
				   //
				   // After initializing all of these
				   // matrices, we call library functions that
				   // build the Laplace and mass matrices. All
				   // they need is a DoFHandler object and a
				   // quadrature formula object that is to be
				   // used for numerical integration. Note
				   // that in many respect these functions are
				   // better than what we would usually do in
				   // application programs, as these functions
				   // for example automatically parallelize
				   // building the matrices if multiple
				   // processors are available in a
				   // machine. When we have both of these
				   // matrices, we form the third one by
				   // copying and adding the first two in
				   // appropriate multiples:
  system_matrix.reinit (sparsity_pattern);
  mass_matrix.reinit (sparsity_pattern);
  laplace_matrix.reinit (sparsity_pattern);

  MatrixCreator::create_mass_matrix (dof_handler, QGauss<dim>(3),
				     mass_matrix);
  MatrixCreator::create_laplace_matrix (dof_handler, QGauss<dim>(3),
					laplace_matrix);
  
  system_matrix.copy_from (mass_matrix);
  system_matrix.add (theta * theta * time_step * time_step, laplace_matrix);

				   // The rest of the function is spent on
				   // setting vector sizes to the correct
				   // value. The final line closes the hanging
				   // node constraints object. Since we work
				   // on a uniformly refined mesh, no
				   // constraints exist or have been computed
				   // (i.e. there was no need to call
				   // DoFTools::make_hanging_nod_constraints
				   // as in other programs), but we need a
				   // constraints object in one place further
				   // down below anyway.
  solution_u.reinit (dof_handler.n_dofs());
  solution_v.reinit (dof_handler.n_dofs());
  old_solution_u.reinit (dof_handler.n_dofs());
  old_solution_v.reinit (dof_handler.n_dofs());
  system_rhs.reinit (dof_handler.n_dofs());

  constraints.close ();
}


				 // @sect4{WaveEquation::solve_u and WaveEquation::solve_u}

				 // The next two functions deal with solving
				 // the linear systems associated with the
				 // equations for $U^n$ and $V^n$. Both are
				 // not particularly interesting as they
				 // pretty much follow the scheme used in all
				 // the previous tutorial programs.
				 //
				 // One can make little experiments with
				 // preconditioners for the two matrices we
				 // have to invert. As it turns out, however,
				 // for the matrices at hand here, using
				 // Jacobi or SSOR preconditioners reduces the
				 // number of iterations necessary to solve
				 // the linear system slightly, but due to the
				 // cost of applying the preconditioner it is
				 // no win in terms of run-time. It is not
				 // much of a loss either, but let's keep it
				 // simple and just do without:
template <int dim>
void WaveEquation<dim>::solve_u () 
{
  SolverControl           solver_control (1000, 1e-8*system_rhs.l2_norm());
  SolverCG<>              cg (solver_control);

  cg.solve (system_matrix, solution_u, system_rhs,
	    PreconditionIdentity());

  std::cout << "   u-equation: " << solver_control.last_step()
	    << " CG iterations."
	    << std::endl;
}


template <int dim>
void WaveEquation<dim>::solve_v () 
{
  SolverControl           solver_control (1000, 1e-8*system_rhs.l2_norm());
  SolverCG<>              cg (solver_control);

  cg.solve (mass_matrix, solution_v, system_rhs,
	    PreconditionIdentity());

  std::cout << "   v-equation: " << solver_control.last_step()
	    << " CG iterations."
	    << std::endl;
}



				 // @sect4{WaveEquation::output_results}

				 // Likewise, the following function is pretty
				 // much what we've done before. The only
				 // thing worth mentioning is how here we
				 // generate a string representation of the
				 // time step number padded with leading zeros
				 // to 3 character length using the
				 // Utilities::int_to_string function's second
				 // argument.
template <int dim>
void WaveEquation<dim>::output_results () const
{
  DataOut<dim> data_out;

  data_out.attach_dof_handler (dof_handler);
  data_out.add_data_vector (solution_u, "U");
  data_out.add_data_vector (solution_v, "V");

  data_out.build_patches ();

  std::ostringstream filename;
  filename << "solution-"
	   << Utilities::int_to_string (timestep_number, 3)
	   << ".gnuplot";
  std::ofstream output (filename.str().c_str());
  data_out.write_gnuplot (output);
}




				 // @sect4{WaveEquation::run}

				 // The following is really the only
				 // interesting function of the program. It
				 // contains the loop over all time steps, but
				 // before we get to that we have to set up
				 // the grid, DoFHandler, and matrices. In
				 // addition, we have to somehow get started
				 // with initial values. To this end, we use
				 // the VectorTools::project function that
				 // takes an object that describes a
				 // continuous function and computes the $L^2$
				 // projection of this function onto the
				 // finite element space described by the
				 // DoFHandler object. Can't be any simpler
				 // than that:
template <int dim>
void WaveEquation<dim>::run () 
{
  setup_system();

  VectorTools::project (dof_handler, constraints, QGauss<dim>(3),
			InitialValuesU<dim>(),
			old_solution_u);
  VectorTools::project (dof_handler, constraints, QGauss<dim>(3),
			InitialValuesV<dim>(),
			old_solution_v);

				   // The next thing is to loop over all the
				   // time steps until we reach the end time
				   // ($T=5$ in this case). In each time step,
				   // we first have to solve for $U^n$, using
				   // the equation $(M^n + k^2\theta^2 A^n)U^n
				   // = M^{n,n-1}U^{n-1} - k^2\theta^2
				   // A^{n,n-1}U^{n-1} + kM^{n,n-1}V^{n-1} -
				   // k^2\theta \left[ \theta F^n + (1-\theta)
				   // F^{n-1} \right]$. Note that we use the
				   // same mesh for all time steps, so that
				   // $M^n=M^{n,n-1}=M$ and
				   // $A^n=A^{n,n-1}=A$. What we therefore
				   // have to do first is to add up $MU^{n-1}
				   // - k^2\theta^2 AU^{n-1} + kMV^{n-1}$ and
				   // put the result into the
				   // <code>system_rhs</code> vector. (For
				   // these additions, we need a temporary
				   // vector that we declare before the loop
				   // to avoid repeated memory allocations in
				   // each time step.)
				   //
				   // The one thing to realize here is how we
				   // communicate the time variable to the
				   // object describing the right hand side:
				   // each object derived from the Function
				   // class has a time field that can be set
				   // using the Function::set_time and read by
				   // Function::get_time. In essence, using
				   // this mechanism, all functions of space
				   // and time are therefore considered
				   // functions of space evaluated at a
				   // particular time. This matches well what
				   // we typically need in finite element
				   // programs, where we almost always work on
				   // a single time step at a time, and where
				   // it never happens that, for example, one
				   // would like to evaluate a space-time
				   // function for all times at any given
				   // spatial location.
  Vector<double> tmp (solution_u.size());
  
  for (timestep_number=1, time=time_step;
       time<=5;
       time+=time_step, ++timestep_number)
    {
      std::cout << "Time step " << timestep_number
		<< " at t=" << time
		<< std::endl;
      
      mass_matrix.vmult (system_rhs, old_solution_u);

      mass_matrix.vmult (tmp, old_solution_v);
      system_rhs.add (time_step, tmp);

      laplace_matrix.vmult (tmp, old_solution_u);
      system_rhs.add (-theta * (1-theta) * time_step * time_step, tmp);

      RightHandSide<dim> rhs_function;
      rhs_function.set_time (time);
      VectorTools::create_right_hand_side (dof_handler, QGauss<dim>(2),
					   rhs_function, tmp);
      system_rhs.add (theta * theta * time_step * time_step, tmp);

      rhs_function.set_time (time-time_step);
      VectorTools::create_right_hand_side (dof_handler, QGauss<dim>(2),
					   rhs_function, tmp);
      system_rhs.add (theta * (1-theta) * time_step * time_step, tmp);

				       // After so constructing the right hand
				       // side vector of the first equation,
				       // all we have to do is apply the
				       // correct boundary values. As for the
				       // right hand side, this is a
				       // space-time function evaluated at a
				       // particular time, which we
				       // interpolate at boundary nodes and
				       // then use the result to apply
				       // boundary values as we usually
				       // do. The result is then handed off to
				       // the solve_u() function:
      BoundaryValues<dim> boundary_values_function;
      boundary_values_function.set_time (time);
      
      std::map<unsigned int,double> boundary_values;
      VectorTools::interpolate_boundary_values (dof_handler,
						0,
						boundary_values_function,
						boundary_values);
      MatrixTools::apply_boundary_values (boundary_values,
					  system_matrix,
					  solution_u,
					  system_rhs);
      solve_u ();


				       // The second step -- solving for $V^n$
				       // works similarly, except that this
				       // time the matrix on the left is the
				       // mass matrix, the right hand side is
				       // $MV^{n-1} - k\left[ \theta A U^n +
				       // (1-\theta) AU^{n-1}\right]$, and
				       // there are no boundary values to be
				       // applied.
      laplace_matrix.vmult (system_rhs, solution_u);
      system_rhs *= -theta * time_step;

      mass_matrix.vmult (tmp, old_solution_v);
      system_rhs += tmp;

      laplace_matrix.vmult (tmp, old_solution_u);
      system_rhs.add (-time_step * (1-theta), tmp);

      rhs_function.set_time (time);
      VectorTools::create_right_hand_side (dof_handler, QGauss<dim>(2),
					   rhs_function, tmp);
      system_rhs.add (theta * time_step, tmp);

      rhs_function.set_time (time-time_step);
      VectorTools::create_right_hand_side (dof_handler, QGauss<dim>(2),
					   rhs_function, tmp);
      system_rhs.add ((1-theta) * time_step, tmp);

      solve_v ();

				       // Finally, after both solution
				       // components have been computed, we
				       // output the result, and go on to the
				       // next time step after shifting the
				       // present solution into the vectors
				       // that hold the solution at the
				       // previous time step:
      output_results ();

      old_solution_u = solution_u;
      old_solution_v = solution_v;
    }
}


				 // @sect3{The <code>main</code> function}

				 // What remains is the main function of the
				 // program. There is nothing here that hasn't
				 // been shown in several of the previous
				 // programs:
int main () 
{
  try
    {
      deallog.depth_console (0);
      WaveEquation<2> wave_equation_solver;
      wave_equation_solver.run ();
    }
  catch (std::exception &exc)
    {
      std::cerr << std::endl << std::endl
		<< "----------------------------------------------------"
		<< std::endl;
      std::cerr << "Exception on processing: " << std::endl
		<< exc.what() << std::endl
		<< "Aborting!" << std::endl
		<< "----------------------------------------------------"
		<< std::endl;

      return 1;
    }
				   // If the exception that was thrown
				   // somewhere was not an object of a
				   // class derived from the standard
				   // <code>exception</code> class, then we
				   // can't do anything at all. We
				   // then simply print an error
				   // message and exit.
  catch (...) 
    {
      std::cerr << std::endl << std::endl
		<< "----------------------------------------------------"
		<< std::endl;
      std::cerr << "Unknown exception!" << std::endl
		<< "Aborting!" << std::endl
		<< "----------------------------------------------------"
		<< std::endl;
      return 1;
    }
  
  return 0;
}
