/* $Id: step-1.cc 27657 2012-11-21 13:19:08Z bangerth $
 *
 * Copyright (C) 1999-2003, 2005-2007, 2009, 2011-2012 by the deal.II authors
 *
 * This file is subject to QPL and may not be  distributed
 * without copyright and license information. Please refer
 * to the file deal.II/doc/license.html for the  text  and
 * further information on this license.
 */

/*
what do I want to talk about:
  
- use GridGenerator (already discussed in step-1)

- construct your own mesh programmatically

- how to use gmsh
  - 2d
  - 3d: mention difficulties

- modify a mesh:
  - merge meshes
  - change boundary indicators
  - move vertices
  - transform via smooth function
  - perturb mesh
  
- how to extrude a mesh  

*/

// @sect3{Include files}

// The most fundamental class in the library is the Triangulation class, which
// is declared here:
#include <deal.II/grid/tria.h>
// We need the following two includes for loops over cells and/or faces:
#include <deal.II/grid/tria_accessor.h>
#include <deal.II/grid/tria_iterator.h>
// Here are some functions to generate standard grids:
#include <deal.II/grid/grid_generator.h>
// We would like to use boundaries which are not straight lines, so we import
// some classes which predefine some boundary descriptions:
#include <deal.II/grid/tria_boundary_lib.h>
// Output of grids in various graphics formats:
#include <deal.II/grid/grid_out.h>
#include <deal.II/grid/grid_in.h>

// This is needed for C++ output:
#include <fstream>
// And this for the declarations of the `sqrt' and `fabs' functions:
#include <cmath>

using namespace dealii;

// @sect3{Creating the first mesh}

// load from a msh generated by gmsh
void grid_1 ()
{
  Triangulation<2> triangulation;

  GridIn<2> gridin;
  gridin.attach_triangulation(triangulation);
  std::ifstream f("untitled.msh");
  gridin.read_msh(f);
  
  // Now we want to write a graphical representation of the mesh to an output
  // file. The GridOut class of deal.II can do that in a number of different
  // output formats; here, we choose encapsulated postscript (eps) format:
  std::ofstream out ("grid-1.eps");
  GridOut grid_out;
  grid_out.write_eps (triangulation, out);
}


// merge triangulations
// note: the vertices have to be exactly on top of each other!
void grid_2 ()
{
  Triangulation<2> triangulation;

  Triangulation<2> tria1, tria2;

  
  GridGenerator::hyper_cube_with_cylindrical_hole (tria1, 0.25, 1.0);
  std::vector< unsigned int > repetitions(2);
  repetitions[0]=3;
  repetitions[1]=2;
  GridGenerator::subdivided_hyper_rectangle (tria2, repetitions,
					     Point<2>(1.0,-1.0), Point<2>(4.0,1.0));

  GridGenerator::merge_triangulations	(tria1, tria2, triangulation);
  
  std::ofstream out ("grid-2.eps");
  GridOut grid_out;
  grid_out.write_eps (triangulation, out);
}





// @sect3{The main function}

// Finally, the main function. There isn't much to do here, only to call the
// two subfunctions, which produce the two grids.
int main ()
{
  grid_1 ();
  grid_2 ();
}
