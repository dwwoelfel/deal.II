<i>This program was made by Timo Heister.</i>

<a name="Intro"></a>
<h1> Introduction </h1>

This tutorial is an extension to step-1 and demonstrates several ways to
obtain more involved meshes.

Generating complex geometries is a challenging task, especially in 3 space
dimensions. We will discuss several ways to do this, but this list is not
exhaustive. Additionally, there is not one approach that fits all problems.

The example program shows some of ways to create and modify meshes for
computations and outputs them as .eps files. No other computations or adaptive
refinements are done. Please note that the example program does not show all
the ways to generate meshes that are discussed in this text.

<h3>General concerns about meshes</h3>

When you use adaptive mesh refinement, you definitely want the initial mesh to
be as coarse as possible. The reason is that you can make it as fine as you
want using adaptive refinement as long as you have memory and CPU time
available. However, this requires that you don't waste mesh cells in parts of
the domain where they don't pay off. As a consequence, you don't want to start
with a mesh that is too fine to start with, because that takes up a good part
of your cell budget already, and because you can't coarsen away cells that are
in the initial mesh.

That said, your mesh needs to capture the given geometry adequately.

<h3>How to create meshes</h3>

There are several ways to create an initial mesh. Meshes can be modified or
combined in many ways as discussed later on.

<h4>GridGenerator</h4>

The easiest way to generate meshes is to use the GridGenerator, which is
already discussed in step-1.  There are many different helper functions
available, including GridGenerator::hyper_cube(),
GridGenerator::hyper_shell(), GridGenerator::hyper_ball(),
GridGenerator::hyper_cube_with_cylindrical_hole(), ...

<h4>Construct your own mesh programmatically</h4>

If the is no good fit in the GridGenerator class, you can always create a
Triangulation in your program "by hand". For that, you need a list of vertices
with their coordinates and a list of cells referencing those vertices. You can
find an example in the function create_coarse_grid in step-14. Additionally,
all the functions in GridGenerator are implemented in this fashion.

 We are happy to accept more functions to be added to GridGenerator. So, if
you end up writing a function that might be useful for a larger audience,
please contribute it.

<h4>Import from external programs</h4>

The class GridIn can read many different mesh formats from a file from
disk. How this is done is explained in step-5 and can be seen in the function
grid_1 in this example.

Meshes can be generated from different tools like <a
href="http://geuz.org/gmsh/" rel="nofollow">gmsh</a>, <a
href="https://lagrit.lanl.gov/" rel="nofollow">lagrit</a> and <a
href="http://cubit.sandia.gov/" rel="nofollow">cubit</a>. See the
documentation of GridIn for more information. The problem is that deal.II
needs meshes that only consist of quads and hexas -- tetrahedral meshes won't
work (this means tools like tetgen can not be used directly).

We will describe a possible workflow using Gmsh. Gmsh is the smallest and
quickest to set up open source tool, that we know of. It can generate
unstructured 2d quad based meshes, but in 3d it can only extrude 2d meshes to
get hexahedral meshes. 3D meshing of unstructured geometry into hexas is not
supported at the time of writing.

A mesh is described in a text based .geo file, that can be edited by hand and
can contain computations, loops, variables, etc.. It is very flexible. The
mesh is generated from a surface representation, which is build from a list of
line loops, which is build from a list of lines, which are in turn build from
points.

It is important that file contains "physical lines" and "physical
surfaces". These give the boundary indicators and material ids for the use
inside deal.II. Without the physical entities, nothing will be imported into
deal.II.  The .geo script can be written by hand or it can be generated
automatically by creating objects graphically. In many cases it is best to
combine both approaches. The file can be easily reloaded by pressing "reload"
under the "Geometry" tab.

This tutorial contains an example .geo file, that describes a box with two
objects cut out in the interior. This is how untitled.geo looks like in gmsh
(displaying the boundary indicators): 
@image html gmsh_picture.png Mesh displayed in Gmsh

You might want to open the .geo file in a text editor to see how it is
structured. Deal.II can read the .msh format written by gmsh. You generate the
.msh from the .geo by running: 

<pre>
gmsh -2 untitled.geo
</pre>

or by clicking "Mesh" and then "2D" inside Gmsh after loading the file.  Now
this is the mesh read from the .msh file and saved again by deal.II as an
image (see the grid_1 function):

@image html step-49.grid-1.png


<h3>Modify a Mesh</h3>

After aquiring one (or several) meshes in the ways described above, there are
many ways to manipulate them before using them in a finite element
computation.


<h4>Transformations</h4>

The GridTools namespace contains a collection of small functions to transform
a given mesh in various ways. The usage of the functions GridTools::shift,
GridTools::rotate, GridTools::scale is fairly obvious, so we won't discuss
those functions here.

The function GridTools::transform allows you to transform the vertices of a
given mesh using a smooth function.

In the function grid_5() we perturb the y coordinate of a mesh with
a sin curve:
<TABLE WIDTH="60%" ALIGN="center">
  <tr>
    <td ALIGN="center">
        @image html step-49.grid-5a.png regular input mesh
    </td>
    <td ALIGN="center">
        @image html step-49.grid-5.png output mesh 
    </td>
  </tr>
</TABLE>

Using the formula
$(x,y) \mapsto (x,tanh(2*y)/tanh(2))$, we transform a regular refined
unit square to a wall-adapted mesh in y direction. This is done in grid_6()
of this tutorial:
<TABLE WIDTH="60%" ALIGN="center">
  <tr>
    <td ALIGN="center">
        @image html step-49.grid-6a.png regular input mesh
    </td>
    <td ALIGN="center">
        @image html step-49.grid-6.png wall-adapted output mesh 
    </td>
  </tr>
</TABLE>

The function Triangulation::distort_random allows you to move vertices in the
mesh (optionally ignoring boundary nodes) by a random amount. This is
demonstrated in grid_7() and the result is as follows:
<TABLE WIDTH="60%" ALIGN="center">
  <tr>
    <td ALIGN="center">
        @image html step-49.grid-7a.png regular input mesh
    </td>
    <td ALIGN="center">
        @image html step-49.grid-7.png perturbed output mesh 
    </td>
  </tr>
</TABLE>

Please note that while this allows you to negate some of the superconvergence
effects one gets when studying convergence on regular meshes, it is better to
work with a sequence of unstructured meshes (see possible extensions).


<h4>Merge Meshes</h4>

The function GridGenerator::merge_triangulations() allows you to merge two
given Triangulations into a single one. This only works, if the vertices of
the to be shared edge or face match exactly. It is useful to use
GridTools::shift and GridTools::scale to align the two meshes.  In the
function grid_2() of this tutorial, we merge a square with a round hole
(generated with hyper_cube_with_cylindrical_hole()) and a rectangle. The
function GridTools::subdivided_hyper_rectangle() allows you to specify the
number of repetitions and the positions of the corners, this way we do not
need to shift it manually. You should inspect the mesh graphically to make
sure, that cells line up correctly and no hanging nodes exist in the merged
Triangulation.

These are the input meshes and the output mesh:
<TABLE WIDTH="80%" ALIGN="center">
  <tr>
    <td ALIGN="center">
        @image html step-49.grid-2a.png input mesh 1
    </td>
    <td ALIGN="center">
        @image html step-49.grid-2b.png input mesh 2
    </td>

    <td ALIGN="center">
        @image html step-49.grid-2.png merged mesh
    </td>
  </tr>
</table>


<h4>Move Vertices</h4>

The function grid_3() demonstrates the ability to pick individual vertices and
move them around in an existing mesh. Please be sure to not produce degenerate
cells. Here, we create a box with a cylindrical hole, that is not exactly
centered by moving the top vertices upwards:

<TABLE WIDTH="60%" ALIGN="center">
  <tr>
    <td ALIGN="center">
        @image html step-49.grid-3a.png input mesh
    </td>

    <td ALIGN="center">
        @image html step-49.grid-3.png top vertices moved upwards
    </td>
  </tr>
</table>


<h4>Extrude Meshes</h4>

If you need a 3d mesh that can be created by extruding a given 2d mesh (that
can be created in any of the ways given above), you can use the function
GridGenerator::extrude_triangulation(). See grid_4() function in this tutorial
for an example. Note that the given result could also be achieved using the 3d
version of hyper_cube_with_cylindrical_hole(). The main usage is a 2d mesh
generated for example with gmsh, that is read in from a .msh file as described
above. This is the output from grid_4():

<TABLE WIDTH="60%" ALIGN="center">
  <tr>
    <td ALIGN="center">
      @image html step-49.grid-4base.png input mesh
    </td>

    <td ALIGN="center">
      @image html step-49.grid-4.png extruded output mesh
    </td>
  </tr>
</table>


<h4>Possible Extensions</h4>

- Modify a mesh:
  - change boundary indicators
  - relax inner vertices
- Database of unstructured meshes for convergence studies
- GridTools::extract_boundary_mesh 
