<a name="Intro"></a>
<h1>Introduction</h1>



<H2><A NAME="SECTION00001000000000000000">
Overview</A>
</H2>
This example is devoted to the <I>discontinuous Galerkin method</I>, or
in short: DG method. It includes the following topics.

<UL>
<LI>Discretization of the linear transport equation with the DG method
</LI>
<LI>Two different assembling routines for the system matrix based on
  face terms given as a sum of integrals that

<OL>
<LI>loops over all cell and all their faces, or that
</LI>
<LI>loops over all faces, whereas each face is treated only once.
</LI>
</OL>
</LI>
<LI>Time comparison of the two assembling routines.
</LI>
</UL>

<P>

<H2><A NAME="SECTION00002000000000000000">
Problem</A>
</H2>
The DG method was first introduced to discretize simple transport
equations. Over the past years DG methods have been applied to a
variety of problems and many different schemes were introduced
employing a big zoo of different convective and diffusive fluxes.  As
this example's purpose is to illustrate some implementational issues
of the DG discretization only, here we simply consider the linear
transport equation
<P></P>
<DIV ALIGN="CENTER"><A NAME="transport-equation"></A><!-- MATH
 \begin{equation}
\nabla\cdot \left\{\boldsymbol\beta u\right\}=f  \qquad\mbox{in }\Omega,
\end{equation}
 -->
<TABLE CELLPADDING="0" WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE">
<TD NOWRAP ALIGN="CENTER"><IMG
 WIDTH="105" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img1.png"
 ALT="$\displaystyle \nabla\cdot \left\{\boldsymbol\beta u\right\}=f$">&nbsp; &nbsp;in <IMG
 WIDTH="22" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img2.png"
 ALT="$\displaystyle \Omega,$"></TD>
<TD NOWRAP WIDTH="10" ALIGN="RIGHT">
(1)</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P>
subject to the boundary conditions
<P><!-- MATH
 \begin{displaymath}
u=g\quad\mbox{on }\Gamma_-,
\end{displaymath}
 -->
</P>
<DIV ALIGN="CENTER">
<IMG
 WIDTH="46" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img3.png"
 ALT="$\displaystyle u=g$">&nbsp; &nbsp;on <IMG
 WIDTH="31" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img4.png"
 ALT="$\displaystyle \Gamma_-,
$">
</DIV><P>
</P>
on the inflow part <IMG
 WIDTH="27" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img5.png"
 ALT="$ \Gamma_-$">
 of the boundary <!-- MATH
 $\Gamma=\partial\Omega$
 -->
<IMG
 WIDTH="61" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="step-12.data/intro/img6.png"
 ALT="$ \Gamma=\partial\Omega$">

of the domain.  Here, <!-- MATH
 $\boldsymbol\beta=\boldsymbol\beta(x)$
 -->
<IMG
 WIDTH="75" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img7.png"
 ALT="$ \boldsymbol\beta=\boldsymbol\beta(x)$">
 denotes a
vector field, <IMG
 WIDTH="15" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img8.png"
 ALT="$ f$">
 a source function, <IMG
 WIDTH="14" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="step-12.data/intro/img9.png"
 ALT="$ u$">
 the (scalar) solution
function, <IMG
 WIDTH="13" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img10.png"
 ALT="$ g$">
 a boundary value function,
<P><!-- MATH
 \begin{displaymath}
\Gamma_-:=\{x\in\Gamma, \boldsymbol\beta(x)\cdot{\bf n}(x)<0\}
\end{displaymath}
 -->
</P>
<DIV ALIGN="CENTER">
<IMG
 WIDTH="237" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img11.png"
 ALT="$\displaystyle \Gamma_-:=\{x\in\Gamma, \boldsymbol\beta(x)\cdot{\bf n}(x)&lt;0\}
$">
</DIV><P>
</P>
the inflow part of the boundary of the domain and <IMG
 WIDTH="15" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="step-12.data/intro/img12.png"
 ALT="$ {\bf n}$">
 denotes
the unit outward normal to the boundary <IMG
 WIDTH="15" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="step-12.data/intro/img13.png"
 ALT="$ \Gamma$">
. Equation
(<A HREF="#transport-equation">1</A>) is the conservative version of the
transport equation already considered in step 9 of this tutorial.

<P>
In particular, we consider problem (<A HREF="#transport-equation">1</A>) on
<!-- MATH
 $\Omega=[0,1]^2$
 -->
<IMG
 WIDTH="83" HEIGHT="38" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img14.png"
 ALT="$ \Omega=[0,1]^2$">
 with <!-- MATH
 $\boldsymbol\beta=\frac{1}{|x|}(-x_2, x_1)$
 -->
<IMG
 WIDTH="129" HEIGHT="39" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img15.png"
 ALT="$ \boldsymbol\beta=\frac{1}{\vert x\vert}(-x_2, x_1)$">

representing a circular counterclockwise flow field, <IMG
 WIDTH="47" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img16.png"
 ALT="$ f=0$">
 and <IMG
 WIDTH="45" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img17.png"
 ALT="$ g=1$">

on <!-- MATH
 $x\in\Gamma_-^1:=[0,0.5]\times\{0\}$
 -->
<IMG
 WIDTH="182" HEIGHT="38" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img18.png"
 ALT="$ x\in\Gamma_-^1:=[0,0.5]\times\{0\}$">
 and <IMG
 WIDTH="45" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img19.png"
 ALT="$ g=0$">
 on <!-- MATH
 $x\in
\Gamma_-\setminus \Gamma_-^1$
 -->
<IMG
 WIDTH="96" HEIGHT="38" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img20.png"
 ALT="$ x\in
\Gamma_-\setminus \Gamma_-^1$">
.

<H2><A NAME="SECTION00003000000000000000">
Discretization</A>
</H2>
Following the general paradigm of deriving DG discretizations for
purely hyperbolic equations, we first consider the general hyperbolic
problem
<P><!-- MATH
 \begin{displaymath}
\nabla\cdot {\mathcal F}(u)=f  \qquad\mbox{in }\Omega,
\end{displaymath}
 -->
</P>
<DIV ALIGN="CENTER">
<IMG
 WIDTH="103" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img21.png"
 ALT="$\displaystyle \nabla\cdot {\mathcal F}(u)=f$">&nbsp; &nbsp;in <IMG
 WIDTH="22" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img2.png"
 ALT="$\displaystyle \Omega,$">
</DIV><P>
</P>
subject to appropriate boundary conditions. Here <!-- MATH
 ${\mathcal F}$
 -->
<IMG
 WIDTH="19" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="step-12.data/intro/img22.png"
 ALT="$ {\mathcal F}$">

denotes the flux function of the equation under consideration that in
our case, see equation (<A HREF="#transport-equation">1</A>), is represented by
<!-- MATH
 ${\mathcal F}(u)=\boldsymbol\beta u$
 -->
<IMG
 WIDTH="87" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img23.png"
 ALT="$ {\mathcal F}(u)=\boldsymbol\beta u$">
.  For deriving the DG
discretization we start with a variational, mesh-dependent
formulation of the problem,
<P><!-- MATH
 \begin{displaymath}
\sum_\kappa\left\{-({\mathcal F}(u),\nabla v)_\kappa+({\mathcal
  F}(u)\cdot{\bf n}, v)_{\partial\kappa}\right\}=(f,v)_\Omega,
\end{displaymath}
 -->
</P>
<DIV ALIGN="CENTER">
<IMG
 WIDTH="363" HEIGHT="52" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img24.png"
 ALT="$\displaystyle \sum_\kappa\left\{-({\mathcal F}(u),\nabla v)_\kappa+({\mathcal
F}(u)\cdot{\bf n}, v)_{\partial\kappa}\right\}=(f,v)_\Omega,
$">
</DIV><P>
</P>
that originates from (<A HREF="#transport-equation">1</A>) by multiplication with
a test function <IMG
 WIDTH="13" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="step-12.data/intro/img25.png"
 ALT="$ v$">
 and integration by parts on each cell <IMG
 WIDTH="14" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="step-12.data/intro/img26.png"
 ALT="$ \kappa$">
 of
the triangulation. Here <!-- MATH
 $(\cdot, \cdot)_\kappa$
 -->
<IMG
 WIDTH="44" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img27.png"
 ALT="$ (\cdot, \cdot)_\kappa$">
 and <!-- MATH
 $(\cdot,
\cdot)_{\partial\kappa}$
 -->
<IMG
 WIDTH="52" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img28.png"
 ALT="$ (\cdot,
\cdot)_{\partial\kappa}$">
 simply denote the integrals over the cell
<IMG
 WIDTH="14" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="step-12.data/intro/img26.png"
 ALT="$ \kappa$">
 and the boundary <!-- MATH
 $\partial\kappa$
 -->
<IMG
 WIDTH="25" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="step-12.data/intro/img29.png"
 ALT="$ \partial\kappa$">
 of the cell,
respectively. To discretize the problem, the functions <IMG
 WIDTH="14" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="step-12.data/intro/img9.png"
 ALT="$ u$">
 and <IMG
 WIDTH="13" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="step-12.data/intro/img25.png"
 ALT="$ v$">
 are
replaced by discrete functions <IMG
 WIDTH="23" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img30.png"
 ALT="$ u_h$">
 and <IMG
 WIDTH="21" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img31.png"
 ALT="$ v_h$">
 that in the case of
discontinuous Galerkin methods belong to the space <IMG
 WIDTH="23" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img32.png"
 ALT="$ V_h$">
 of
discontinuous piecewise polynomial functions of some degree <IMG
 WIDTH="13" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img33.png"
 ALT="$ p$">
. Due
to the discontinuity of the discrete function <IMG
 WIDTH="23" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img30.png"
 ALT="$ u_h$">
 on interelement
faces, the flux <!-- MATH
 ${\mathcal F}(u)\cdot{\bf n}$
 -->
<IMG
 WIDTH="66" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img34.png"
 ALT="$ {\mathcal F}(u)\cdot{\bf n}$">
 must be replaced by a
<I>numerical flux</I> function <!-- MATH
 ${\mathcal H}(u_h^+, u_h^-, {\bf n})$
 -->
<IMG
 WIDTH="102" HEIGHT="39" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img35.png"
 ALT="$ {\mathcal H}(u_h^+, u_h^-, {\bf n})$">
,
where <!-- MATH
 $u_h^+|_{\partial\kappa}$
 -->
<IMG
 WIDTH="47" HEIGHT="39" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img36.png"
 ALT="$ u_h^+\vert _{\partial\kappa}$">
 denotes the inner trace (w.r.t.  the
cell <IMG
 WIDTH="14" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="step-12.data/intro/img26.png"
 ALT="$ \kappa$">
) of <IMG
 WIDTH="23" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img30.png"
 ALT="$ u_h$">
 and <!-- MATH
 $u_h^-|_{\partial\kappa}$
 -->
<IMG
 WIDTH="47" HEIGHT="39" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img37.png"
 ALT="$ u_h^-\vert _{\partial\kappa}$">
 the outer trace,
i.e. the value of <IMG
 WIDTH="23" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img30.png"
 ALT="$ u_h$">
 on the neighboring cell. Furthermore the
numerical flux function <!-- MATH
 ${\mathcal H}$
 -->
<IMG
 WIDTH="19" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="step-12.data/intro/img38.png"
 ALT="$ {\mathcal H}$">
, among other things, must be
consistent, i.e.
<P><!-- MATH
 \begin{displaymath}
{\mathcal H}(u,u,{\bf n})={\mathcal F}(u)\cdot{\bf n},
\end{displaymath}
 -->
</P>
<DIV ALIGN="CENTER">
<IMG
 WIDTH="169" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img39.png"
 ALT="$\displaystyle {\mathcal H}(u,u,{\bf n})={\mathcal F}(u)\cdot{\bf n},
$">
</DIV><P>
</P>
and conservative, i.e.
<P></P>
<DIV ALIGN="CENTER"><A NAME="conservative"></A><!-- MATH
 \begin{equation}
{\mathcal H}(v,w,{\bf n})=-{\mathcal H}(w,v,-{\bf n}).
\end{equation}
 -->
<TABLE CELLPADDING="0" WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE">
<TD NOWRAP ALIGN="CENTER"><IMG
 WIDTH="214" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img40.png"
 ALT="$\displaystyle {\mathcal H}(v,w,{\bf n})=-{\mathcal H}(w,v,-{\bf n}).$"></TD>
<TD NOWRAP WIDTH="10" ALIGN="RIGHT">
(2)</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P>
This yields the following <I>discontinuous Galerkin
  discretization</I>: find <!-- MATH
 $u_h\in V_h$
 -->
<IMG
 WIDTH="63" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img41.png"
 ALT="$ u_h\in V_h$">
 such that
<P></P>
<DIV ALIGN="CENTER"><A NAME="dg-scheme"></A><!-- MATH
 \begin{equation}
\sum_\kappa\left\{-({\mathcal F}(u_h),\nabla v_h)_\kappa+({\mathcal H}(u_h^+,u_h^-,{\bf n}), v_h)_{\partial\kappa}\right\}=(f,v_h)_\Omega, \quad\forall v_h\in V_h.
\end{equation}
 -->
<TABLE CELLPADDING="0" WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE">
<TD NOWRAP ALIGN="CENTER"><IMG
 WIDTH="526" HEIGHT="52" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img42.png"
 ALT="$\displaystyle \sum_\kappa\left\{-({\mathcal F}(u_h),\nabla v_h)_\kappa+({\mathc...
...\bf n}), v_h)_{\partial\kappa}\right\}=(f,v_h)_\Omega, \quad\forall v_h\in V_h.$"></TD>
<TD NOWRAP WIDTH="10" ALIGN="RIGHT">
(3)</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P>
Boundary conditions are realized by replacing <IMG
 WIDTH="26" HEIGHT="39" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img43.png"
 ALT="$ u_h^-$">
 on the inflow boundary <IMG
 WIDTH="27" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img5.png"
 ALT="$ \Gamma_-$">
 by the boundary function <IMG
 WIDTH="13" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img10.png"
 ALT="$ g$">
.
In the special case of the transport equation
(<A HREF="#transport-equation">1</A>) the numerical flux in its simplest form
is given by
<P></P>
<DIV ALIGN="CENTER"><A NAME="flux-transport-equation"></A><!-- MATH
 \begin{equation}
{\mathcal H}(u_h^+,u_h^-,{\bf n})(x)=\left\{\begin{array}{ll}
      (\boldsymbol\beta\cdot{\bf n}\, u_h^-)(x),&\mbox{for } \boldsymbol\beta(x)\cdot{\bf n}(x)<0,\\
      (\boldsymbol\beta\cdot{\bf n}\, u_h^+)(x),&\mbox{for } \boldsymbol\beta(x)\cdot{\bf n}(x)\geq 0,
\end{array}
\right.
\end{equation}
 -->
<TABLE CELLPADDING="0" WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE">
<TD NOWRAP ALIGN="CENTER"><IMG
 WIDTH="444" HEIGHT="61" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img44.png"
 ALT="$\displaystyle {\mathcal H}(u_h^+,u_h^-,{\bf n})(x)=\left\{\begin{array}{ll} (\b...
...)(x),&amp;\mbox{for } \boldsymbol\beta(x)\cdot{\bf n}(x)\geq 0, \end{array} \right.$"></TD>
<TD NOWRAP WIDTH="10" ALIGN="RIGHT">
(4)</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P>
where on the inflow part of the cell the value is taken from the
neighboring cell, <IMG
 WIDTH="26" HEIGHT="39" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img43.png"
 ALT="$ u_h^-$">
, and on the outflow part the value is
taken from the current cell, <IMG
 WIDTH="26" HEIGHT="39" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img45.png"
 ALT="$ u_h^+$">
.  Hence, the discontinuous Galerkin
scheme for the transport equation (<A HREF="#transport-equation">1</A>) is given
by: find <!-- MATH
 $u_h\in V_h$
 -->
<IMG
 WIDTH="63" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img41.png"
 ALT="$ u_h\in V_h$">
 such that for all <!-- MATH
 $v_h\in V_h$
 -->
<IMG
 WIDTH="61" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img46.png"
 ALT="$ v_h\in V_h$">
 following
equation holds:
<P></P>
<DIV ALIGN="CENTER"><A NAME="dg-transport"></A><!-- MATH
 \begin{equation}
\sum_\kappa\left\{-(u_h,\boldsymbol\beta\cdot\nabla v_h)_\kappa+(\boldsymbol\beta\cdot{\bf n}\, u_h, v_h)_{\partial\kappa_+\setminus\Gamma}+(\boldsymbol\beta\cdot{\bf n}\, u_h^-, v_h)_{\partial\kappa_-\setminus\Gamma}\right\}=(f,v_h)_\Omega-(\boldsymbol\beta\cdot{\bf n}\, g, v_h)_{\Gamma_-},
\end{equation}
 -->
<TABLE CELLPADDING="0" WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE">
<TD NOWRAP ALIGN="CENTER"><IMG
 WIDTH="701" HEIGHT="52" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img47.png"
 ALT="$\displaystyle \sum_\kappa\left\{-(u_h,\boldsymbol\beta\cdot\nabla v_h)_\kappa+(...
...mma}\right\}=(f,v_h)_\Omega-(\boldsymbol\beta\cdot{\bf n}\, g, v_h)_{\Gamma_-},$"></TD>
<TD NOWRAP WIDTH="10" ALIGN="RIGHT">
(5)</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P>
where <!-- MATH
 $\partial\kappa_-:=\{x\in\partial\kappa,
\boldsymbol\beta(x)\cdot{\bf n}(x)<0\}$
 -->
<IMG
 WIDTH="255" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img48.png"
 ALT="$ \partial\kappa_-:=\{x\in\partial\kappa,
\boldsymbol\beta(x)\cdot{\bf n}(x)&lt;0\}$">
 denotes the inflow boundary
and <!-- MATH
 $\partial\kappa_+=\partial\kappa\setminus \partial \kappa_-$
 -->
<IMG
 WIDTH="127" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img49.png"
 ALT="$ \partial\kappa_+=\partial\kappa\setminus \partial \kappa_-$">
 the
outflow part of cell <IMG
 WIDTH="14" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="step-12.data/intro/img26.png"
 ALT="$ \kappa$">
. Below, this equation will be referred
to as <I>first version</I> of the DG method. We note that after a
second integration by parts, we obtain: find <!-- MATH
 $u_h\in V_h$
 -->
<IMG
 WIDTH="63" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img41.png"
 ALT="$ u_h\in V_h$">
 such that
<P><!-- MATH
 \begin{displaymath}
\sum_\kappa\left\{(\nabla\cdot\{\boldsymbol\beta u_h\},\nabla v_h)_\kappa-(\boldsymbol\beta\cdot{\bf n} [u_h], v_h)_{\partial\kappa_-}\right\}=(f,v_h)_\Omega, \quad\forall v_h\in V_h,
\end{displaymath}
 -->
</P>
<DIV ALIGN="CENTER">
<IMG
 WIDTH="518" HEIGHT="52" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img50.png"
 ALT="$\displaystyle \sum_\kappa\left\{(\nabla\cdot\{\boldsymbol\beta u_h\},\nabla v_h...
...u_h], v_h)_{\partial\kappa_-}\right\}=(f,v_h)_\Omega, \quad\forall v_h\in V_h,
$">
</DIV><P>
</P>
where <!-- MATH
 $[u_h]=u_h^+-u_h^-$
 -->
<IMG
 WIDTH="120" HEIGHT="39" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img51.png"
 ALT="$ [u_h]=u_h^+-u_h^-$">
 denotes the jump of the discrete function
between two neighboring cells and is defined to be <!-- MATH
 $[u_h]=u_h^+-g$
 -->
<IMG
 WIDTH="107" HEIGHT="39" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img52.png"
 ALT="$ [u_h]=u_h^+-g$">
 on
the boundary of the domain. This is the discontinuous Galerkin scheme
for the transport equation given in its original notation.
Nevertheless, we will base the implementation of the scheme on the
form given by (<A HREF="#dg-scheme">3</A>) and (<A HREF="#flux-transport-equation">4</A>),
or (<A HREF="#dg-transport">5</A>), respectively.

<P>
Finally, we rewrite (<A HREF="#dg-scheme">3</A>) in terms of a summation over all
faces where each face <!-- MATH
 $e=\partial \kappa\cap\partial \kappa'$
 -->
<IMG
 WIDTH="100" HEIGHT="17" ALIGN="BOTTOM" BORDER="0"
 SRC="step-12.data/intro/img53.png"
 ALT="$ e=\partial \kappa\cap\partial \kappa'$">

between two neighboring cells <IMG
 WIDTH="14" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="step-12.data/intro/img26.png"
 ALT="$ \kappa$">
 and <IMG
 WIDTH="19" HEIGHT="17" ALIGN="BOTTOM" BORDER="0"
 SRC="step-12.data/intro/img54.png"
 ALT="$ \kappa'$">
 occurs twice:
Find <!-- MATH
 $u_h\in V_h$
 -->
<IMG
 WIDTH="63" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img41.png"
 ALT="$ u_h\in V_h$">
 such that
<P></P>
<DIV ALIGN="CENTER"><A NAME="dg-scheme-faces-long"></A><!-- MATH
 \begin{equation}
-\sum_\kappa({\mathcal F}(u_h),\nabla v_h)_\kappa+\sum_e\left\{({\mathcal H}(u_h^+,u_h^-,{\bf n}), v_h)_e+({\mathcal H}(u_h^-, u_h^+,-{\bf n}), v_h^-)_{e\setminus\Gamma}\right\}=(f,v_h)_\Omega \quad\forall v_h\in V_h,
\end{equation}
 -->
<TABLE CELLPADDING="0" WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE">
<TD NOWRAP ALIGN="CENTER"><IMG
 WIDTH="731" HEIGHT="52" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img55.png"
 ALT="$\displaystyle -\sum_\kappa({\mathcal F}(u_h),\nabla v_h)_\kappa+\sum_e\left\{({...
... n}), v_h^-)_{e\setminus\Gamma}\right\}=(f,v_h)_\Omega \quad\forall v_h\in V_h,$"></TD>
<TD NOWRAP WIDTH="10" ALIGN="RIGHT">
(6)</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P>
By employing conservativity (<A HREF="#conservative">2</A>) of the numerical flux
this equation simplifies to: find <!-- MATH
 $u_h\in V_h$
 -->
<IMG
 WIDTH="63" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img41.png"
 ALT="$ u_h\in V_h$">
 such that
<P></P>
<DIV ALIGN="CENTER"><A NAME="dg-scheme-faces"></A><!-- MATH
 \begin{equation}
-\sum_\kappa({\mathcal F}(u_h),\nabla v_h)_\kappa+\sum_e({\mathcal H}(u_h^+,u_h^-,{\bf n}), [v_h])_{e\setminus\Gamma}+({\mathcal H}(u_h,g,{\bf n}), v_h)_{\Gamma}=(f,v_h)_\Omega \quad\forall v_h\in V_h.
\end{equation}
 -->
<TABLE CELLPADDING="0" WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE">
<TD NOWRAP ALIGN="CENTER"><IMG
 WIDTH="687" HEIGHT="52" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img56.png"
 ALT="$\displaystyle -\sum_\kappa({\mathcal F}(u_h),\nabla v_h)_\kappa+\sum_e({\mathca...
...athcal H}(u_h,g,{\bf n}), v_h)_{\Gamma}=(f,v_h)_\Omega \quad\forall v_h\in V_h.$"></TD>
<TD NOWRAP WIDTH="10" ALIGN="RIGHT">
(7)</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P>
Whereas the outer unit normal <!-- MATH
 ${\bf n}|_{\partial\kappa}$
 -->
<IMG
 WIDTH="37" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img57.png"
 ALT="$ {\bf n}\vert _{\partial\kappa}$">
 is uniquely
defined this is not so for <IMG
 WIDTH="23" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img58.png"
 ALT="$ {\bf n}_e$">
 as the latter might be the
normal from either side of the face. Hence, we need to fix the normal
<IMG
 WIDTH="15" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="step-12.data/intro/img12.png"
 ALT="$ {\bf n}$">
 on the face to be one of the two normals and denote the
other normal by <IMG
 WIDTH="29" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img59.png"
 ALT="$ -{\bf n}$">
.  This way we get <IMG
 WIDTH="29" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img59.png"
 ALT="$ -{\bf n}$">
 in the second
face term in (<A HREF="#dg-scheme-faces-long">6</A>) that finally produces the
minus sign in the jump <IMG
 WIDTH="31" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img60.png"
 ALT="$ [v_h]$">
 in equation (<A HREF="#dg-scheme-faces">7</A>).

<P>
For the linear transport equation (<A HREF="#transport-equation">1</A>)
equation (<A HREF="#dg-scheme-faces">7</A>) simplifies to
<P></P>
<DIV ALIGN="CENTER"><A NAME="dg-transport-gamma"></A><!-- MATH
 \begin{equation}
-\sum_\kappa(u_h,\boldsymbol\beta\cdot\nabla v_h)_\kappa+\sum_e\left\{(\boldsymbol\beta\cdot{\bf n}\, u_h, [v_h])_{e_+\setminus\Gamma}+(\boldsymbol\beta\cdot{\bf n}\, u_h^-, [v_h])_{e_-\setminus\Gamma}\right\}=(f,v_h)_\Omega-(\boldsymbol\beta\cdot{\bf n}\, g, v_h)_{\Gamma_-},
\end{equation}
 -->
<TABLE CELLPADDING="0" WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE">
<TD NOWRAP ALIGN="CENTER"><IMG
 WIDTH="730" HEIGHT="52" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/intro/img61.png"
 ALT="$\displaystyle -\sum_\kappa(u_h,\boldsymbol\beta\cdot\nabla v_h)_\kappa+\sum_e\l...
...mma}\right\}=(f,v_h)_\Omega-(\boldsymbol\beta\cdot{\bf n}\, g, v_h)_{\Gamma_-},$"></TD>
<TD NOWRAP WIDTH="10" ALIGN="RIGHT">
(8)</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P>
which will be refered to as <I>second version</I> of the DG method.

<H2><A NAME="SECTION00004000000000000000">
Implementation</A>
</H2>
As already mentioned at the beginning of this example we will
implement assembling the system matrix in two different ways.
The first one will be based on the first version (<A HREF="#dg-transport">5</A>)
of the DG method that includes a sum of integrals over all cell
boundaries <!-- MATH
 $\partial\kappa$
 -->
<IMG
 WIDTH="25" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="step-12.data/intro/img29.png"
 ALT="$ \partial\kappa$">
. This is realized by a loop over all cells and
a nested loop over all faces of each cell.  Thereby each inner face
<!-- MATH
 $e=\partial\kappa\cap\partial \kappa'$
 -->
<IMG
 WIDTH="100" HEIGHT="17" ALIGN="BOTTOM" BORDER="0"
 SRC="step-12.data/intro/img53.png"
 ALT="$ e=\partial \kappa\cap\partial \kappa'$">
 is treated twice, the first
time when the outer loop treats cell <IMG
 WIDTH="14" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="step-12.data/intro/img26.png"
 ALT="$ \kappa$">
 and the second time when it
treats cell <IMG
 WIDTH="19" HEIGHT="17" ALIGN="BOTTOM" BORDER="0"
 SRC="step-12.data/intro/img54.png"
 ALT="$ \kappa'$">
. This way some values like the shape function
values at quadrature points on faces need to be computed twice.

<P>
To overcome this overhead and for comparison, we implement
assembling of matrix also in a second and different way. This will
be based on the second version (<A HREF="#dg-transport-gamma">8</A>) that
includes a sum of integrals over all faces <IMG
 WIDTH="12" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="step-12.data/intro/img62.png"
 ALT="$ e$">
. Here, several
difficulties occurs.

<UL>
<LI>As degrees of freedom are associated with cells (and not to faces)
  and as a normal is only defined w.r.t. a cell adjacent to the face we
  cannot simply run over all faces of the triangulation but need to
  perform the nested loop over all cells and all faces of each cell
  like in the first implementation.  This, because in <TT>deal.II</TT>
  faces are accessible from cells but not visa versa.
</LI>
<LI>Due to the nested loop we arrive twice at each face. In order to
  assemble face terms only once we either need to track which
  faces we have treated before, or we introduce a simple rule that decides
  which of the two adjacent cells the face should be accessed and
  treated from.  Here, we employ the second approach and define the
  following rule:
  <DL COMPACT>
<DT>a).</DT>
<DD>If the two cells adjacent to a face are of the same refinement level we access and treat the face from the cell with lower index on this level.
  
</DD>
<DT>b).</DT>
<DD>If the two cells are of different refinement levels we access
    and treat the face from the coarser cell.
  
</DD>
</DL>
</LI>
</UL>
Before we start with the description of the code we first introduce
its main ingredients. The main class is called
<TT>DGMethod</TT>. It comprises all basic objects like the
triangulation, the dofhandler, the system matrix and solution vectors.
Furthermore it has got some member functions, the most prominent of
which are the <TT>assemble_system1</TT> and <TT>assemble_system2</TT>
functions that implement the two different ways mentioned above for
assembling the system matrix. Within these assembling routines several
different cases must be distinguished while performing the nested
loops over all cells and all faces of each cell and assembling the
respective face terms. While sitting on the current cell and looking
at a specific face there are the cases

<OL>
<LI>face is at boundary,
</LI>
<LI>neighboring cell is finer,
</LI>
<LI>neighboring cell is of the same refinement level, and
</LI>
<LI>neighboring cell is coarser
</LI>
</OL>
where the `neighboring cell' and the current cell have the mentioned
faces in common. In last three cases the assembling of the face terms
are almost the same. Hence, we can implement the assembling of the
face terms either by `copy and paste' (the lazy way, whose
disadvantages come up when the scheme or the equation might want to be
changed afterwards) or by calling a separate function that covers all
three cases. To be kind of educational within this tutorial we perform
the latter approach, of course. We go even further and encapsulate
this function and everything that is needed for assembling the
specific equation under consideration within a class called
<TT>DGTransportEquation</TT>. This class includes objects of all
equation-specific functions, the <TT>RHS</TT> and the
<TT>BoundaryValues</TT> class, both derived from the <TT>Function</TT>
class, and the <TT>Beta</TT> class representing the vector field.
Furthermore, the <TT>DGTransportEquation</TT> class comprises member
functions <TT>assemble_face_terms1</TT> and
<TT>assemble_face_terms2</TT> that are invoked by the
<TT>assemble_system1</TT> and <TT>assemble_system2</TT> functions of the
<TT>DGMethod</TT>, respectively, and the functions
<TT>assemble_cell_term</TT> and <TT>assemble_boundary_term</TT> that
are the same for both assembling routines. Due to the encapsulation of
all equation- and scheme-specific functions, the
<TT>DGTransportEquation</TT> class can easily be replaced by a similar
class that implements a different equation and a different DG method.
Indeed, the implementation of the <TT>assemble_system1</TT> and
<TT>assemble_system2</TT> functions of the <TT>DGMethod</TT> class will
be general enough to serve for different DG methods, different
equations, even for systems of equations (!) and, under small
modifications, for nonlinear problems. Finally, we note that the
program is dimension independent, i.e. after replacing
<TT>DGMethod&lt;2&gt;</TT> by <TT>DGMethod&lt;3&gt;</TT> the code runs in 3d.
