<a name="Results"></a>
<h1>Results</h1>

<p>
The output of the program looks as follows:
<pre><code>
Cycle 0:
   Number of active cells:       20
   Number of degrees of freedom: 89
Cycle 1:
   Number of active cells:       44
   Number of degrees of freedom: 209
Cycle 2:
   Number of active cells:       92
   Number of degrees of freedom: 449
Cycle 3:
   Number of active cells:       200
   Number of degrees of freedom: 961
Cycle 4:
   Number of active cells:       440
   Number of degrees of freedom: 2033
Cycle 5:
   Number of active cells:       932
   Number of degrees of freedom: 4465
Cycle 6:
   Number of active cells:       1916
   Number of degrees of freedom: 9113
Cycle 7:
   Number of active cells:       3884
   Number of degrees of freedom: 18401
</code></pre>
</p>

<p>
As intended, the number of cells roughly doubles in each cycle.  The
number of degrees is slightly more than four times the number of
cells; one would expect a factor of exactly four in two spatial
dimensions on an infinite grid (since the spacing between the degrees
of freedom is half the cell width: one additional degree of freedom on
each edge and one in the middle of each cell), but it is larger than
that factor due to the finite size of the mesh and due to additional
degrees of freedom which are introduced by hanging nodes and local
refinement.
</p>

<p>
The final solution, as written by the program at the end of the
<code>run()</code> function, looks as follows:
</p>

<p>
<IMG SRC="step-6.data/final-solution.jpg" ALT="final-solution" WIDTH="300">
</p>

<p>
In each cycle, the program furthermore writes the grid in EPS
format. These are shown in the following:
</p>

<p>
<TABLE WIDTH="100%">
<tr>
<td>
<IMG SRC="step-6.data/grid-0.jpg" ALT="grid-0" WIDTH="300">
</td>
<td>
<IMG SRC="step-6.data/grid-1.jpg" ALT="grid-1" WIDTH="300">
</td>
</tr>

<tr>
<td>
<IMG SRC="step-6.data/grid-2.jpg" ALT="grid-2" WIDTH="300">
</td>
<td>
<IMG SRC="step-6.data/grid-3.jpg" ALT="grid-3" WIDTH="300">
</td>
</tr>

<tr>
<td>
<IMG SRC="step-6.data/grid-4.jpg" ALT="grid-4" WIDTH="300">
</td>
<td>
<IMG SRC="step-6.data/grid-5.jpg" ALT="grid-5" WIDTH="300">
</td>
</tr>

<tr>
<td>
<IMG SRC="step-6.data/grid-6.jpg" ALT="grid-6" WIDTH="300">
</td>
<td>
<IMG SRC="step-6.data/grid-7.jpg" ALT="grid-7" WIDTH="300">
</td>
</tr>
</table>
</p>

<p>
It is clearly visible that the region where the solution has a kink,
i.e. the circle at radial distance 0.5 from the center, is
refined most. Furthermore, the central region where the solution is
very smooth and almost flat, is almost not refined at all, but this
results from the fact that we did not take into account that the
coefficient is large there. The region outside is refined rather
randomly, since the second derivative is constant there and refinement
is therefore mostly based on the size of the cells and their deviation
from the optimal square.
</p>


<p>
For completeness, we show what happens if the code we commented about
in the destructor of the <code>LaplaceProblem</code> class is omitted
from this example.
</p>
<pre><code>
--------------------------------------------------------
An error occurred in line <78> of file <source/subscriptor.cc> in function
    virtual Subscriptor::~Subscriptor()
The violated condition was: 
    counter == 0
The name and call sequence of the exception was:
    ExcInUse(counter, object_info->name(), infostring)
Additional Information: 
Object of class 4FE_QILi2EE is still used by 1 other objects.
  from Subscriber 10DoFHandlerILi2EE

Stacktrace:
-----------
#0  /u/bangerth/p/deal.II/1/deal.II/lib/libbase.g.so(_ZN11SubscriptorD2Ev+0x25b) [0x2aaaabc62087]
#1  /u/bangerth/p/deal.II/1/deal.II/lib/libdeal_II_2d.g.so(_ZN13FiniteElementILi2EED2Ev+0x3f6) [0x2aaaaaf85122]
#2  ./step-6(_ZN7FE_PolyI24TensorProductPolynomialsILi2EELi2EED2Ev+0x58) [0x41ee28]
#3  ./step-6(_ZN4FE_QILi2EED1Ev+0x58) [0x41b9ee]
#4  ./step-6(_ZN14LaplaceProblemILi2EED1Ev+0x10d) [0x4162fb]
#5  ./step-6(main+0x7d) [0x415da5]
#6  /lib64/tls/libc.so.6(__libc_start_main+0xea) [0x2aaaac60254a]
#7  ./step-6(_ZN15DataOut_DoFDataILi2E10DoFHandlerLi2ELi2EE5clearEv+0x52) [0x415c8a]
--------------------------------------------------------
make: *** [run] Aborted
</code></pre>
</p>

<p>
From the above error message, we conclude that an object of type
``10DoFHandlerILi2EE'' is still using the object of type
``4FE_QILi2EE''. These are of course "mangled" names for
<code>DoFHandler</code> and <code>FE_Q</code>. The mangling works as
follows: the first number indicates the number of characters of the
template class, i.e. 10 for <code>DoFHandler</code> and 4
for<code>FE_Q</code>; the rest of the text is then template
arguments. From this we can already glean a little bit who's the
culprit here, and who the victim.:
The one object that still uses the finite element is the
``dof_handler'' object.
</p>

<p>
The stacktrace gives an indication of where the problem happened. For
technical reasons, the present code only shows mangled function names,
but if you run the stacktrace through the <code>c++filt</code>
program, you will get something like this:
<pre><code>
#0  /u/bangerth/p/deal.II/1/deal.II/lib/libbase.g.so(Subscriptor::~Subscriptor()+0x25b) [0x2aaaabc62087]
#1  /u/bangerth/p/deal.II/1/deal.II/lib/libdeal_II_2d.g.so(FiniteElement<2>::~FiniteElement()+0x3f6) [0x2aaaaaf85122]
#2  ./step-6(FE_Poly<TensorProductPolynomials<2>, 2>::~FE_Poly()+0x58) [0x41ee28]
#3  ./step-6(FE_Q<2>::~FE_Q()+0x58) [0x41b9ee]
#4  ./step-6(LaplaceProblem<2>::~LaplaceProblem()+0x10d) [0x4162fb]
#5  ./step-6(main+0x7d) [0x415da5]
#6  /lib64/tls/libc.so.6(__libc_start_main+0xea) [0x2aaaac60254a]
#7  ./step-6(DataOut_DoFData<2, DoFHandler, 2, 2>::clear()+0x52) [0x415c8a]
</code></pre>
</p>

<p>
In other words, we can now see that the exception was triggered in the
destructor of the <code>FiniteElement</code> class that was called
through a few more functions from the destructor of the
<code>LaplaceProblem</code> class, exactly where we have commented out
the call to <code>DoFHandler::clear()</code>.
</p>
