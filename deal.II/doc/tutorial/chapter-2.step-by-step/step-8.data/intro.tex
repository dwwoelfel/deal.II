%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% intro.html was generated from this file 
%% with latex2html and some handwork
%% (copying out the relevant parts from the 
%% generated html file, replacing IMG=
%% by the proper path)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass{article}
\usepackage{amsmath}
\usepackage{amsfonts}

\renewcommand{\vec}[1]{{\mathbf #1}}
\renewcommand{\div}{\nabla \cdot}
\begin{document}

In real life, most partial differential equations are really systems
of equations. Accordingly, the solutions are usually
vector-valued. The deal.II library supports such problems, and we will show
that that is mostly rather simple. The only more complicated problems
are in assembling matrix and right hand side, but these are easily
understood as well. 

In the example, we will want to solve the elastic equations. They are
an extension to Laplace's equation with a vector-valued solution that
describes the displacement in each space direction of a rigid body
which is subject to a force. Of course, the force is also
vector-valued, meaning that in each point it has a direction and an
absolute value. The elastic equations are the following:
$$
  -
  \partial_j (c_{ijkl} \partial_k u_l)
  =
  f_i,
  \qquad
  i=1\ldots d,
$$
where the values $c_{ijkl}$ are the stiffness coefficients and
will usually depend on the space coordinates. In
many cases, one knows that the material under consideration is
isotropic, in which case by introduction of the two coefficients
$\lambda$ and $\mu$ the coefficient tensor reduces to
$$
  c_{ijkl} 
  =
  \lambda \delta_{ij} \delta_{kl} + 
  \mu (\delta_{ik} \delta_{jl} + \delta_{il} \delta_{jk}).
$$

The elastic equations can then be rewritten in much simpler a form:
$$
   -
   \nabla (\lambda+\mu) (\div \vec u)
   -
   (\nabla \cdot \mu \nabla) \vec u
   =
   \vec f,
$$
and the respective bilinear form is then
$$
  a(\vec u, \vec v) =
  \left(
    (\lambda+\mu) \div \vec u, \div \vec v
  \right)_\Omega
  +
  \sum_k
  \left(
    \mu \nabla u_k, \nabla v_k
  \right)_\Omega,
$$
or as a sum over components:
$$
  a(\vec u, \vec v) =
  \sum_{k,l}
  \left(
    (\lambda+\mu) \partial_l u_l, \partial_k v_k
  \right)_\Omega
  +
  \sum_{k,l}
  \left(
    \mu \partial_l u_k, \partial_l v_k
  \right)_\Omega.
$$


How do we now assemble the matrix for such an equation? The first thing we
need is some knowledge about how the shape functions work in the case of
vector-valued finite elements. Basically, this comes down to the following:
let $n$ be the number of shape functions for the scalar finite element of
which we build the vector element (for example, we will use bilinear functions
for each component of the vector-valued finite element, so the scalar finite
element is the \texttt{FEQ1} element which we have used in previous examples
already, and $n=4$ in two space dimensions). Further, let $N$ be the number of
shape functions for the vector element; in two space dimensions, we need $n$
shape functions for each component of the vector, so $N=2n$. Then, the $i$th
shape function of the vector element has the form
$$
  \Phi_i(\vec x) = \varphi_{base(i)}(\vec x)\ \vec e_{comp(i)},
$$
where $e_l$ is the $l$th unit vector, $comp(i)$ is the function that tells
us which component of $\Phi_i$ is the one that is nonzero (for
each vector shape function, only one component is nonzero, and all others are
zero). $\varphi_{base(i)}(x)$ describes the space dependence of the shape
function, which is taken to be the $base(i)$-th shape function of the scalar
element. Of course, while $i$ is in the range $0,\ldots,N-1$, the functions
$comp(i)$ and $base(i)$ have the ranges $0,1$ (in 2D) and $0,\ldots,n-1$,
respectively. 

For example (but this layout is not mandatory, and you should not rely on it),
the following layout could be used by the library:
\begin{center}
\begin{multline*}
  \Phi_0(\vec x) = 
  \begin{pmatrix}
    \varphi_0(\vec x) \\ 0
  \end{pmatrix},
  \qquad
  \Phi_1(\vec x) = 
  \begin{pmatrix}
    0 \\ \varphi_0(\vec x)
  \end{pmatrix},
  \\
  \Phi_2(\vec x) = 
  \begin{pmatrix}
    \varphi_1(\vec x) \\ 0
  \end{pmatrix},
  \qquad
  \Phi_3(\vec x) = 
  \begin{pmatrix}
    0 \\ \varphi_1(\vec x)
  \end{pmatrix},
  \ldots
\end{multline*}
\end{center}
where here
$$
  comp(0)=0, \quad  comp(1)=1, \quad  comp(2)=0, \quad  comp(3)=1, \quad  \ldots
$$
$$
  base(0)=0, \quad  base(1)=0, \quad  base(2)=1, \quad  base(3)=1, \quad  \ldots
$$

In all but very rare cases, you will not need to know which shape function
$\varphi_{base(i)}$ of the scalar element belongs to a shape function $\Phi_i$
of the vector element. Let us therefore define
$$
  \phi_i = \varphi_{base(i)}
$$
by which we can write the vector shape function as
$$
  \Phi_i(\vec x) = \phi_{i}(\vec x)\ \vec e_{comp(i)}.
$$
You can now safely forget about the function $base(i)$, at least for the rest
of this example program.

Now using this vector shape functions, we can write the discrete finite
element solution as
$$
  \vec u_h(\vec x) = 
  \sum_i \Phi_i(\vec x)\ u_i
$$
with scalar coefficients $u_i$. If we define an analog function $\vec v_h$ as
test function, we can write the discrete problem as follows: Find coefficients
$u_i$ such that
$$
  a(\vec u_h, \vec v_h) = (\vec f, \vec v_h)
  \qquad
  \forall \vec v_h.
$$

If we insert the definition of the bilinear form and the representation of
$\vec u_h$ and $\vec v_h$ into this formula:
\begin{center}
\begin{multline*}
  \sum_{i,j}
    u_i v_j
  \sum_{k,l}
  \left\{
  \left(
    (\lambda+\mu) \partial_l (\Phi_i)_l, \partial_k (\Phi_j)_k
  \right)_\Omega
  +
  \left(
    \mu \partial_l (\Phi_i)_k, \partial_l (\Phi_j)_k
  \right)_\Omega  
  \right\}
\\
=
  \sum_j v_j
  \sum_l
  \left(
    f_l,
    (\Phi_j)_l
  \right)_\Omega.
\end{multline*}
\end{center}
We note that here and in the following, the indices $k,l$ run over spatial
directions, i.e. $0\le k,l \le d-1$, and that indices $i,j$ run over degrees
of freedoms.

The local stiffness matrix on cell $K$ therefore has the following entries:
$$
  A^K_{ij}
  =
  \sum_{k,l}
  \left\{
  \left(
    (\lambda+\mu) \partial_l (\Phi_i)_l, \partial_k (\Phi_j)_k
  \right)_K
  +
  \left(
    \mu \partial_l (\Phi_i)_k, \partial_l (\Phi_j)_k
  \right)_K
  \right\},
$$
where $i,j$ now are local degrees of freedom and therefore $0\le i,j \le N-1$. 
In these formulas, we always take some component of the vector shape functions
$\Phi_i$, which are of course given as follows (see their definition):
$$
  (\Phi_i)_l = \phi_i \delta_{l,comp(i)},
$$
with the Kronecker symbol $\delta_{nm}$. Due to this, we can delete some of
the sums over $k$ and $l$:
\begin{center}
\begin{align*}
  A^K_{ij}
  &=
  \sum_{k,l}
  \Bigl\{
  \left(
    (\lambda+\mu) \partial_l \phi_i\ \delta_{l,comp(i)}, 
                  \partial_k \phi_j\ \delta_{k,comp(j)}
  \right)_K
\\
  &\qquad\qquad +
  \left(
    \mu \partial_l \phi_i\ \delta_{k,comp(i)},
        \partial_l \phi_j\ \delta_{k,comp(j)}
  \right)_K
  \Bigr\}
\\
  &=
  \left(
    (\lambda+\mu) \partial_{comp(i)} \phi_i,
                  \partial_{comp(j)} \phi_j
  \right)_K
  +
  \sum_l
  \left(
    \mu \partial_l \phi_i,
        \partial_l \phi_j
  \right)_K
  \ \delta_{comp(i),comp(j)}
\\
  &=
  \left(
    (\lambda+\mu) \partial_{comp(i)} \phi_i,
                  \partial_{comp(j)} \phi_j
  \right)_K
  +
  \left(
    \mu \nabla \phi_i,
        \nabla \phi_j
  \right)_K
  \ \delta_{comp(i),comp(j)}.
\end{align*}
\end{center}

Likewise, the contribution of cell $K$ to the right hand side vector is
\begin{center}
\begin{align*}
  f^K_j
  &=
  \sum_l
  \left(
    f_l,
    (\Phi_j)_l
  \right)_K
\\
  &=
  \sum_l
  \left(
    f_l,
    \phi_j \delta_{l,comp(j)}
  \right)_K
\\
  &=
  \left(
    f_{comp(j)},
    \phi_j
  \right)_K.
\end{align*}  
\end{center}

This is the form in which we will implement the local stiffness matrix and
right hand side vectors.



\end{document}
