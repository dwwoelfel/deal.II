<a name="Results"></a>
<h1>Results</h1>


<p>
The results of this program are not that interesting - after all
its purpose was not to demonstrate some new mathematical idea, and
also not how to program with deal.II, but rather to use the material
which we have developed in the previous examples to form something
which demonstrates a way to build modern finite element software in a
modular and extensible way.
</p>

<p>
Nevertheless, we of course show the results of the program. Of
foremost interest is the point value computation, for which we had
implemented the corresponding evaluation class. The results (i.e. the
output) of the program looks as follows:
<code>
<pre>
    Running tests with "global" refinement criterion:
    -------------------------------------------------
    Refinement cycle: 0 1 2 3 4 5 6
    DoFs  u(x_0)
       25 1.2868
       81 1.6945
      289 1.4658
     1089 1.5679
     4225 1.5882
    16641 1.5932
    66049 1.5945

    Running tests with "kelly" refinement criterion:
    ------------------------------------------------
    Refinement cycle: 0 1 2 3 4 5 6 7 8 9 10 11
    DoFs  u(x_0)
       25 1.2868
       47 0.8775
       89 1.5365
      165 1.2974
      316 1.6442
      589 1.5221
     1090 1.5724
     2035 1.5622
     3754 1.5916
     7100 1.5876
    13059 1.5942
    24749 1.5933
</pre>
</code>
</p>

<p>
What surprises here is that the the exact value is 1.59491554..., and that
it is obviously suprisingly complicated to compute the solution even to
only one per cent accuracy, although the solution is smooth (in fact
infinite often differentiable). This smoothness is shown in the
graphical output generated by the program, here coarse grid and the
first 9 refinement steps of the Kelly refinement indicator:
</p>

<table width="80%" align="center">
  <tr>
    <td>
      <img src="step-13.data/pix-kelly/solution-kelly-0.jpg" 
       alt="Solution Kelly, coarse grid">
    </td>
    <td>
      <img src="step-13.data/pix-kelly/solution-kelly-1.jpg" 
       alt="Solution Kelly, 1 refinement steps">
    </td>
  </tr>

  <tr>
    <td>
      <img src="step-13.data/pix-kelly/solution-kelly-2.jpg" 
       alt="Solution Kelly, 2 refinement steps">
    </td>
    <td>
      <img src="step-13.data/pix-kelly/solution-kelly-3.jpg" 
       alt="Solution Kelly, 3 refinement steps">
    </td>
  </tr>

  <tr>
    <td>
      <img src="step-13.data/pix-kelly/solution-kelly-4.jpg" 
       alt="Solution Kelly, 4 refinement steps">
    </td>
    <td>
      <img src="step-13.data/pix-kelly/solution-kelly-5.jpg" 
       alt="Solution Kelly, 5 refinement steps">
    </td>
  </tr>

  <tr>
    <td>
      <img src="step-13.data/pix-kelly/solution-kelly-6.jpg" 
       alt="Solution Kelly, 6 refinement steps">
    </td>
    <td>
      <img src="step-13.data/pix-kelly/solution-kelly-7.jpg" 
       alt="Solution Kelly, 7 refinement steps">
    </td>
  </tr>

  <tr>
    <td>
      <img src="step-13.data/pix-kelly/solution-kelly-8.jpg" 
       alt="Solution Kelly, 8 refinement steps">
    </td>
    <td>
      <img src="step-13.data/pix-kelly/solution-kelly-9.jpg" 
       alt="Solution Kelly, 9 refinement steps">
    </td>
  </tr>
</table>

<p>
While we're already at watching pictures, this is the eighth grid, as
viewed from top:
</p>

<p align="center">
  <img src="step-13.data/pix-kelly/grid-kelly-8.gif" alt="Kelly, grid 8">
</p>



<p>
However, we are not yet finished with evaluation the point value
computation. In fact, plotting the error
<em>e=|u(x<sub>h</sub>)-u<sub>h</sub>(x<sub>0</sub>)|</em> for the two
refinement criteria yields the following picture:
</p>

<p align="center">
  <img src="step-13.data/error.gif" alt="error" width="80%">
</p>


<p>
What <em>is</em> disturbing about this picture is that not only is the
adaptive mesh refinement not better than global refinement as one
would usually expect, it is even significantly worse since its
convergence is irregular, preventing all extrapolation techniques when
using the values of subsequent meshes! On the other hand, global
refinement provides a perfect <em>1/N</em> or <em>h<sup>-2</sup></em>
convergence history and provides every opportunity to even improve on
the point values by extrapolation. Global mesh refinement must
therefore be considered superior in this example! This is even more
surprising as the evaluation point is not somewhere in the left part
where the mesh is coarse, but rather to the right and the adaptive
refinement should refine the mesh around the evaluation point as well.
</p>

<p>
We thus close the discussion of this example program with a question:
</p>
<p align="center">
  <strong><em>What is wrong with adaptivity if it is not better than
  global refinement?</em></strong>
</p>


<p>
<em>Exercise at the end of this example:</em> There is a simple reason
for the bad and irregular behavior of the adapted mesh solutions. It
is simple to find out by looking at the mesh around the evaluation
point in each of the steps - the data for this is in the output files
of the program. An exercise would therefore be to modify the mesh
refinement routine such that the problem (once you remark it) is
avoided. The second exercise is to check whether the results are then
better than global refinement, and if so if even a better order of
convergence (in terms of the number of degrees of freedom) is
achieved, or only by a better constant.
</p>

<p>
(<em>Very brief answers for the impatient:</em> at steps with larger
errors, the mesh is not regular at the point of evaluation, i.e. some
of the adjacent cells have hanging nodes; this destroys some
superapproximation effects of which the globally refined mesh can
profit. Answer 2: this quick hack
<code><pre>
    bool refinement_indicated = false;
    typename Triangulation<dim>::active_cell_iterator cell;
    for (cell=triangulation->begin_active();
	 cell!=triangulation->end(); ++cell)
      for (unsigned int v=0; v<GeometryInfo<dim>::vertices_per_cell; ++v)
	if (cell->vertex(v) == Point<dim>(.5,.5))
	  {
	    cell->clear_coarsen_flag();
	    refinement_indicated |= cell->refine_flag_set();
	  };
    if (refinement_indicated)
      for (cell=triangulation->begin_active();
	   cell!=triangulation->end(); ++cell)
	for (unsigned int v=0; v<GeometryInfo<dim>::vertices_per_cell; ++v)
	  if (cell->vertex(v) == Point<dim>(.5,.5))
	    cell->set_refine_flag ();
</pre></code>
in the refinement function of the Kelly refinement class right before
executing refinement would improve the results (exercise: what does
the code do?), making them consistently better than global
refinement. Behavior is still irregular, though, so no results about
an order of convergence are possible.)
</p>
