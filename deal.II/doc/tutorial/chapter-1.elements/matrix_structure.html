<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"
   "http://www.w3.org/TR/REC-html40/strict.dtd">
<html>
<head>
<!-- deal.II tutorial template
     Jan Schrage and others <deal@iwr.uni-heidelberg.de> 1999 
-->

<title>deal.II tutorial: Matrix Structure</title>
    <link href="../screen.css" rel="StyleSheet" title="deal.II Tutorial" media="screen">
    <link href="../print.css" rel="StyleSheet" title="deal.II Tutorial" media="print">
    <link href="../audio.css" rel="StyleSheet" title="deal.II Tutorial" media="aural">
    <meta name="author" content="Jan Schrage and others <deal@iwr.uni-heidelberg.de>">
    <meta name="keywords" content="deal.II,deal.II tutorial,deal II">
</head>

<!-- Page Body -->
<body lang="en">

<h1>Matrix Structure</h1>

<h2>Why thinking about matrix structures is important</h2>
<p>
Many of the matrices encountered when trying to solve systems of differential
equations consist mostly of zero entries. At the same time those matrices are 
very large, and therefore storage is expensive in terms of memory. 
<acronym>deal.II</acronym> attempts to resolve this problem by 
providing means of generating memory efficient structures for sparse
matrices where only non-zero elements are stored.
</p>
<p>
To show only two example of matrices which are quite typical of finite
element discretizations of partial differential equations, we present
the following two graphics, in which each dot represents a non-zero
entry of the matrix:
</p>
<p>
 <img src="../images/sparsity_1.jpg" alt="Sparsity 1" width="45%">
 <img src="../images/sparsity_2.jpg" alt="Sparsity 2" width="45%">
</p>
<p>
The first is a 300x300 matrix, the second has approximately 4000 rows
and columns. As can be seen, the vast majority of entries is zero, and
we can also guess that the proportion of zeroes is even growing as the
matrix size is increased (this is in fact so, but can not so clearly
be seen from the pictures, admittedly). The equation discretized to
yield these matrices is rather complex, so the number of non-zero
entries per row is quite large for finite element matrices.
Both matrices were derived after renumbering of the degrees of freedom
using the algorithm of Cuthill-McKee, which concentrates the entries
around the diagonal of the matrix.


<h2>Ways of dealing with matrix structures provided by <acronym>deal.II</acronym></h2>
<p>
Before you can build the appropriate matrices for your problem you
need to ascertain where the components of your matrix are non-zero 
and generate a structure for storing the matrix accordingly. 
This structure
is then used to actually initialize the matrix, i.e.
tell the matrix for which elements to allocate memory.
</p>

<h3>The Standard Sparse Matrix</h3>
<p>
The <acronym>deal.II</acronym> function initializing a standard sparse matrix
structure is <code>void SparseMatrixStruct::reinit(const unsigned int m, const unsigned int n, const unsigned int max_per_row)</code>. It takes as its arguments
the size of the matrix in question and the maximum number of non-zero elements
in one row. This first sets up a blank sparsity pattern which,
however, has as yet no information which entries are non-zero.
</p>
<p>
Before going on with showing how to find out which elements are
non-zero, we have to talk about how to find out about the maximum
number of non-zero entries per row which we will need for our matrix.
Since this number depends of the actual finite element used (higher
order elements need more non-zero entries than linear elements, for
example), of the equation under consideration, and of some properties
of the triangulation on which we want to do our computations. Since
all these factors can't be considered by the user all the time, there
is a library function which does the necessary computations for you:
<code>unsigned int DoFHandler::max_couplings_between_dofs()</code>.
We note that this function was written to cope with refined grids, and
if you only have structured grids without local refinement and hanging
nodes, the result of this function will overestimate the maximal
number of non-zero entries per row.
</p>
<p>
After having fixed the basic properties of the sparsity structure, we
can tell it which entries actually are non-zero. This is again done
using a library function,
<code>DoFTools::make_sparsity_pattern</code>. Then we have to take
into account that constraints due to hanging nodes (see the previous
chapter) add some more non-zero entries, which is again done using 
some library functions (see the example below). After this, we can
instruct the sparsity pattern to throw out all unused elements
(in those rows where the actual number of non-zero elements is less
than the maximal number given to <code>reinit</code>, we can discard
the unused one to save some more memory). This is discussed in the
next subsection.
</p>
<p>
This matrix structure can then be used to serve as sparsity pattern to
one or several matrices using 
<code>void SparseMatrix::reinit(const SparseMatrixStruct&sparsity)</code>.
We note the distinction that the <code>SparseMatrixStruct</code> only
stores the places of the non-zero elements, while the
<code>SparseMatrix</code> actually stores the values of these
elements. The separation was made since often several matrices are
needed with the same sparsity pattern, but different entry values;
this way, we can save some memory space.
</p>

<p class="Example">
<a name="sparsity_pattern"><span class="example">Example:</span></a> We show the include files you need, 
the definitions and the function calls. Make sure to use them in their
appropriate places. This example initializes a sparse square matrix structure.
</p>
<pre class="example">
<code>
#include &lt;grid/dof.h&gt;
#include &lt;lac/sparsematrix.h&gt;
#include &lt;basic/dof_tools.h&gt;


const unsigned int dim=2; // For example
SparseMatrixStruct sparsity_pattern;
DoFHandler&lt;dim&gt; dof_handler;

// set up a triangulation, refine it, associate the DoFHandler object
// shown above to it, and distribute the degrees of freedom
...

// now fix the size of the matrix and the maximal number
// of non-zero entries:
sparsity_pattern.reinit (dof_handler.n_dofs(),
                         dof_handler.n_dofs(),
                         dof_handler.max_couplings_between_dofs());

// tell the sparsity pattern which entries are non-zero:
make_sparsity_pattern (dof_handler, sparsity_pattern); 

// Condense the <a href="hanging_nodes.html">hanging nodes</a> into
// the matrix structure, taking into account the constraints due to
// the hanging nodes. 
// You can skip this part if your grid is not locally refined.
ConstraintMatrix hanging_nodes; 
dof_handler.make_constraint_matrix(hanging_nodes);
hanging_nodes.condense (sparsity_pattern);
</code>
</pre>

<h3>Compression of Matrix Structures</h3>

<p>
Sparse matrix structures can (and indeed must) be compressed before they are used 
in objects of the class <code>SparseMatrix&lt;&gt;</code> that actually hold the matrix
data. The reason for this is the way matrix structures and matrices are generated:
<ul>
      <li>Initially a fixed number of non-zero entries is allocated for each matrix row.
	Usually, though, rows will have much less entries than this maximum number. Rows
	rows corresponding to degrees of freedom
	on cells with hanging nodes have more entries than rows corresponding to degrees of freedom
	in regular regions of the grid.
      </li>
      <li> When you compress the matrix structure
	you stop adding new non-zero entries and all unused entries in each row
	are deleted. Thus memory is saved.
      </li>
      <li> Only now are you allowed to associate this matrix structure
	to a matrix object which then allocates memory for each non-zero entry,
	rather than for the maximum number of non-zero entries of each row.
      </li>
</ul>

The appropriate function is <code>void SparseMatrixStruct::compress()</code>.
</p>

<p class="Example">
<span class="example">Example:</span> Starting from <a href="#sparsity_pattern">the example above</a>, we
compress our matrix structure <code>sparsity_pattern</code>.
</p>
<pre class="example">
<code>
sparsity_pattern.compress();
</code>
</pre>


<h3>More complex matrices</h3>

Finally, we note that in some cases not all variables in a system of
partial differential equations couple to each other, or that the
operators have a special structure. For this reason, there are more
specialized version of the
<code>DoFTools::make_sparsity_pattern</code> and 
<code>SparseMatrixStruct::reinit</code> functions, which allow you to
more flexibly determine the actual number of non-zero elements of all
or individual rows. See the documentation of the respective classes
for more information.


<!-- Page Foot -->
<hr>
<table class="navbar">      
<tr>
  <td>
    <a href="matrix_generation.html">Next Chapter: Matrix and Vector Generation</a>
  </td>
  <td>
    <a href="toc.html">Back to this chapter's index</a>
  </td>
  <td>
    <a href="../index.html" target="_top">Back to the tutorial index</a>
  </td>
</tr>
</table>
<hr>
<address>
<a href="mailto:deal@iwr.uni-heidelberg.de">The deal.II group</a></address>
<p>
Last modified: $Date$ 
</p>
</body>
</html>

