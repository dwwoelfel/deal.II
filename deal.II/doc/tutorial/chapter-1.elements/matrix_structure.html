<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"
   "http://www.w3.org/TR/REC-html40/strict.dtd">
<html>
<head>
<!-- deal.II tutorial template
     Jan Schrage <schrage@gaia.iwr.uni-heidelberg.de> 1999 
-->

<title>Matrix Structure</title>
    <link href="../dealtut.css" rel="StyleSheet" title="deal.II Tutorial">
    <meta name="author" content="Jan Schrage <schrage@gaia.iwr.uni-heidelberg.de>">
    <meta name="keywords" content="deal.II,deal.II tutorial,deal II">
</head>

<!-- Page Body -->
<body lang="en">

<h1>Matrix Structure</h1>

<h2>Why thinking about matrix structures is important</h2>
<p>
Many of the matrices encountered when trying to solve systems of differential
equations consist mostly of zero entries. At the same time those matrices are 
very large, and therefore storage is expensive in terms of memory. 
<acronym>deal.II</acronym> attempts to resolve this problem by 
providing means of generating memory efficient structures for sparse
matrices where only non-zero elements are stored.
</p>

<h2>Ways of dealing with matrix structures provided by <acronym>deal.II</acronym></h2>
<p>
Before you can build the appropriate matrices for your problem you
need to ascertain where the components of your matrix are non-zero 
and generate a structure for storing the matrix accordingly. 
This structure
is then used to actually initialize the matrix, i.e.
tell the matrix for which elements to allocate memory.
</p>

<h3>The Standard Sparse Matrix</h3>
<p>
The <acronym>deal.II</acronym> function initializing a standard sparse matrix
structure is <code>void SparseMatrixStruct::reinit(const unsigned int m, const unsigned int n, const unsigned int max_per_row)</code>. It takes as its arguments
the size of the matrix in question and the maximum number of non-zero elements
in one row.
This number can be calculated with 
<code>int DoFHandler::max_couplings_between_dofs()</code>.
This matrix structure can then be used to generate a matrix using 
<code>void SparseMatrix::reinit(const SparseMatrixStruct &sparsity)</code>.
In cases of locally refined grids you will also need to take care of the constraints to your
matrix given by the <a href="hanging_nodes.html">hanging nodes</a>.
</p>

<p class="Example">
<a name="sparsity_pattern"><span class="example">Example:</span></a> We show the include files you need, 
the definitions and the function calls. Make sure to use them in their
appropriate places. This example initializes a sparse square matrix structure.
</p>
<pre class="example">
<code>
#include &lt;grid/dof.h&gt;
#include &lt;lac/sparsematrix.h&gt;


int dim=2; // For example
SparseMatrixStruct&lt;double&gt; sparsity_pattern;
DoFHandler&lt;dim&gt; dof;
ConstraintMatrix hanging_nodes;  // Only necessary for locally refined grids

// Your degrees of freedom must already be distributed

sparsity_pattern.reinit(dof.n_dofs(),dof.n_dofs(),dof.max_couplings_between_dofs());

// Condense the <a href="hanging_nodes.html">hanging nodes</a> into
// the matrix, taking into account the constraints to the hanging nodes.
// This must be done before the matrix structure is compressed, but only
// on locally refined grids.
// You can skip this part if your grid is not locally refined.

dof.make_sparsity_pattern(sparsity_pattern); 
hanging_nodes.clear();
dof.make_constraint_matrix(hanging_nodes);
hanging_nodes.condense(sparsity_pattern);

</code>
</pre>

<h3>Compression of Matrix Structures</h3>

<p>
Sparse matrix structures can (and indeed must) be compressed before they are used 
in objects of the class <code>SparseMatrix&lt;&gt;</code> that actually hold the matrix
data. The reason for this is the way matrix structures and matrices are generated:
<ul>
      <li>Initially a fixed number of non-zero entries is allocated for each matrix row.
	Usually, though, rows will have much less entries than this maximum number. Rows
	rows corresponding to degrees of freedom
	on cells with hanging nodes have more entries than rows corresponding to degrees of freedom
	in regular regions of the grid.
      </li>
      <li> When you compress the matrix structure
	you stop adding new non-zero entries and all unused entries in each row
	are deleted. Thus memory is saved.
      </li>
      <li> Only now are you allowed to associate this matrix structure
	to a matrix object which then allocates memory for each non-zero entry,
	rather than for the maximum number of non-zero entries of each row.
      </li>
</ul>

The appropriate function is <code>void SparseMatrixStruct::compress()</code>.
</p>

<p class="Example">
<span class="example">Example:</span> Starting from <a href="#sparsity_pattern">the example above</a>, we
compress our matrix structure <code>sparsity_pattern</code>.
</p>
<pre class="example">
<code>
sparsity_pattern.compress();
</code>
</pre>


<!-- Page Foot -->
<hr>
<table class="navbar">      
<tr>
  <td>
    <a href="matrix_generation.html">Next Chapter: Matrix and Vector Generation</a>
  </td>
  <td>
    <a href="toc.html">Back to this chapter's index</a>
  </td>
  <td>
    <a href="../index.html" target="_top">Back to the tutorial index</a>
  </td>
</tr>
</table>
<hr>
<address>
<a href="mailto:schrage@gaia.iwr.uni-heidelberg.de">Jan Schrage</a></address>
<p>
Last modified: $Date$ 
</p>
</body>
</html>

