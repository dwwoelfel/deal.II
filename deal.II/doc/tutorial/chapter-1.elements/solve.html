<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"
   "http://www.w3.org/TR/REC-html40/strict.dtd">
<html>
<head>
<!-- deal.II tutorial template
     Jan Schrage and others <deal@iwr.uni-heidelberg.de> 1999 
-->

<title>deal.II tutorial: Solving the Problem</title>
    <link href="../screen.css" rel="StyleSheet" title="deal.II Tutorial" media="screen">
    <link href="../print.css" rel="StyleSheet" title="deal.II Tutorial" media="print">
    <link href="../audio.css" rel="StyleSheet" title="deal.II Tutorial" media="aural">
    <meta name="author" content="Jan Schrage and others <deal@iwr.uni-heidelberg.de>">
    <meta name="keywords" content="deal.II,deal.II tutorial,deal II">
</head>

<!-- Page Body -->
<body lang="en">

<h1>Solving the Problem</h1>

<p>
<acronym>deal.II</acronym> offers several solver classes:
</p>

<ul>
<li>
  <code><a href="#bicgstab">SolverBicgstab</a></code>, the Bicgstab algorithm 
	by van der Worst
</li>
<li>
  <code><a href="#cg">SolverCG</a></code>, the preconditioned cg-algorithm
</li>
<li>
  <code><a href="#gmres">SolverGMRES</a></code>, an implementation of the 
	Restarted 
	Preconditioned Direct Generalized Minimal Residual Method
</li>
<li>
  <code><a href="#richardson">SolverRichardson</a></code>, the Richardson 
	iteration method
</li>
</ul>
Some more specialized solvers may be implemented in the meantime. In
case you need some such solver, you should take a look at the
up-to-date online documentation.

<p>
Besides the solver classes, there are several utility classes:
<ul>
<li> 
<code><a href="#control">SolverControl</a></code> to 
control the iterative solvers, i.e. to determine whether the iteration 
should be continued
</li>
<li>
<code><a href="#solvselect">SolverSelector</a></code>, the use of which
offers several advantages over solver selection by hand
</li>
<li>
<code><a href="#precondition">PreconditionSelector</a></code> that allows
you to select a preconditioner
</li>
</ul>
</p>

<h3>A note on <acronym>deal.II</acronym> solvers</h3>

<p>
All of the <acronym>deal.II</acronym> solvers have a structure
<code>AdditionalData</code> that is used to pass additional 
arguments to the solver. We discuss this structure only for those 
solvers that need it.
</p>

<p>
Information on common solution methods can be found in any modern
textbook on finite elements, for example in <cite>Braess, Dietrich, Finite
Elements</cite>. The GMRES solver discussed below is rather
special, and if you are going to use it you probably know what
you are doing anyway.

<p>
We will now begin with the discussion of the <code>SolverControl</code>, the
<code>SolverSelector</code>
and the <code>PreconditionSelector</code> classes, then discuss the solvers 
in more detail.
</p>

<h2><a name="control">Solver Control</a></h2>

<p>
The class <code>SolverControl</code> is used by iterative solvers
to determine whether to continue with the iteration. It takes two
to three parameters: the maximum number of iterations and the criterium for
abortion, usually the residual and a flag controlling whether to log the 
history (the value to be checked and the number of the iteration step).  
<code>SolverControl</code> is initialized using<br>
<code>SolverControl (const unsigned int n, const double tol, const bool log_history = false)</code>

<p class="Example">
<span class="example">Example:</span>We initialize a solver control with
a maximum of 1000 iterations and a maximum residual of 1e-6.
</p>

<pre class="example">
<code>
#include &lt;lac/solver_control.h&gt;

SolverControl control(1000,1e-6);
</code>
</pre>

Thus, the iterative solver which with it shall be used will stop after
either 1000 iterations are performed or the norm of the residual is
below the given threshold.


<h2><a name="solvselect">SolverSelector</a></h2>

<p>
The <code>SolverSelector</code> class is a wrapper for all the 
<acronym>deal.II</acronym> solver classes. By calling it with the
right constructor you select your solver, and by calling its <code>solve</code>
method you call the <code>solve</code> method of the solver you selected.
The advantage of this approach is that your solver is an argument
to this class and - more important - an argument you can set in a 
parameter file. That means that if you want to change your solver, e.g.
because a new one has been added you do not have to rewrite your program.
</p>
<p>
The <code>SolverSelector</code> is initialized using<br>
<code>
SolverSelector(const string solvername, SolverControl &amp;control,
VectorMemory&lt;Vector&gt; &amp;mem)
</code>
</p>

<p class="Example">
<span class="example">Example:</span>We initialize a solver selector
that will call the cg-solver. The problem matrix is a sparse matrix of
doubles and the right hand side a vector of doubles. 
</p>

<pre class="example">
<code>
#include &lt;lac/solver_control.h&gt;
#include &lt;lac/solver_selector.h&gt;
#include &lt;lac/sparse_matrix.h&gt;
#include &lt;lac/vector.h&gt;

SolverControl control;
VectorMemory&lt;Vector&lt;double&gt; &gt; mem;

SolverSelector&lt;SparseMatrix&lt;double&gt;, Vector&lt;double&gt; &gt;
  solver_selector("cg", control, mem);
</code>
</pre>


<h2><a name="precondition">Preconditioning</a></h2>

<p>
Before firing up the solver of your choice you will need some kind of 
preconditioning. This is easiest selected by creating an instance of
the <code>PreconditionSelect</code> class with an appropriate choice of 
parameters. This can be done using <code>PreconditionSelector(const string
preconditioning, const typename Vector::value_type &amp;omega=1.)</code>
where <code>preconditioning</code> denotes the preconditioning method used 
and <code>omega</code> is the damping parameter if the preconditioner
you selected uses it.
</p>
<p>
The preconditioning methods currently available using this class are
</p>
<ul>
<li>none</li>
<li>jacobi</li>
<li>sor</li>
<li>ssor</li>
</ul>
<p>
You can obtain a list of available methods by calling
<code>string PreconditionSelector::get_precondition_names()</code>.
</p>

<p>
After having selected a preconditioner you will need to select a 
matrix used for preconditioning. Usually this will be the problem matrix 
<code>A</code> of the problem <code>Au=f</code>.
The method to be called is <code>void PreconditionSelector::use_matrix(const
Matrix &amp;M)</code>.
</p>

<p class="Example">
<span class="example">Example:</span>We initialize a Jacobi preconditioner
with a damping parameter of 1. The matrix used for preconditioning 
is the matrix <code>A</code>
of the problem <code>Au=f</code>.
</p>

<pre class="example">
<code>
#include &lt;lac/precondition_selector.h&gt;
#include &lt;dofs/dof_handler.h&gt;
#include &lt;lac/full_matrix.h&gt;

FullMatrix&lt;double&gt; A(100,50);

PreconditionSelector preconditioning("jacobi",1.);
preconditioning.use_matrix(A);
</code>
</pre>



<h2><a name="bicgstab">SolverBicgstab</a></h2>

<p>
This class implements the Bicgstab algorithm by van der Worst.
It is initialized by<br>
<code>SolverBicgstab (SolverControl &cn, VectorMemory<Vector> &mem)</code>.
</p>
<p class="Example">
<span class="example">Example:</span>We initialize a Bicgstab-solver for
the problem <code>Au=f</code>, using the <a href="#control">solver control</a>
explained above. <code>A</code> shall be a sparse matrix and the vectors
<code>u</code> and <code>f</code> shall be vectors of doubles. Next,
we solve the problem. 
</p>

<pre class="example">
<code>
// Include files for solver control, solver and preconditioner
#include &lt;lac/solver_control.h&gt;
#include &lt;lac/solver_bicgstab.h&gt;
#include &lt;lac/precondition_selector.h&gt;

// Include files for matrices and vectors
#include &lt;lac/sparse_matrix.h&gt;
#include &lt;lac/vector.h&gt;

// Initialize the solver control and the solver

SolverControl control(1000,1e-6);
VectorMemory&lt;Vector&lt;double&gt; &gt; vectormem;
SolverBicgstab&lt;SparseMatrix&lt;double&gt;,Vector&lt;double&gt; &gt; solver(control,vectormem);

// Initialize the problem matrices. Well...they shouldn't only be
// initialized but also contain the problem, so this is just an example
// to get the definitions and types and everything right. 

SparseMatrix&lt;double&gt; A;
Vector&lt;double&gt; u,f;

// Generate a Jacobi preconditioner with the damping parameter 1
PreconditionSelector&lt;SparseMatrix&lt;double&gt;, Vector&lt;double&gt; &gt; preconditioning("jacobi",1.);

// Use the matrix of the linear equation system for preconditioning
// (this is the usual case).
preconditioning.use_matrix(A);

solver.solve(A,u,f,preconditioning);
</code>
</pre>

<h2><a name="cg">SolverCG</a></h2>

<p>
This class implements the preconditioned cg-method.
It is initialized by<br>
<code>SolverCG (SolverControl &cn, VectorMemory<Vector> &mem)</code>.
</p>
<p class="Example">
<span class="example">Example:</span>We initialize a CG-solver for
the problem <code>Au=f</code>, using the <a href="#control">solver control</a>
explained above. <code>A</code> shall be a sparse matrix and the vectors
<code>u</code> and <code>f</code> shall be vectors of doubles. Next,
we solve the problem. 
</p>

<pre class="example">
<code>
// Include files for solver control, solver and preconditioner
#include &lt;lac/solver_control.h&gt;
#include &lt;lac/solver_bicgstab.h&gt;
#include &lt;lac/precondition_selector.h&gt;

// Include files for matrices and vectors
#include &lt;lac/sparse_matrix.h&gt;
#include &lt;lac/vector.h&gt;

// Initialize the solver control and the solver

SolverControl control(1000,1e-6);
VectorMemory&lt;Vector&lt;double&gt; &gt; vectormem;
SolverCG&lt;SparseMatrix&lt;double&gt;,Vector&lt;double&gt; &gt; solver(control,vectormem);

// Initialize the problem matrices. Well...they shouldn't only be
// initialized but also contain the problem, so this is just an example
// to get the definitions and types and everything right. 

SparseMatrix&lt;double&gt; A;
Vector&lt;double&gt; u,f;

// Generate a Jacobi preconditioner with the damping parameter 1
PreconditionSelector&lt;SparseMatrix&lt;double&gt;, Vector&lt;double&gt; &gt; preconditioning("jacobi",1.);

// Use the matrix of the linear equation system for preconditioning
// (this is the usual case).
preconditioning.use_matrix(A);

solver.solve(A,u,f,preconditioning);
</code>
</pre>

<h2><a name="gmres">SolverGMRES</a></h2>

<p>This class implements the Restarted Preconditioned Direct Generalized
Minimal Residual Method. The stopping criterion is the norm of the residual.
It is initialized using <br>
<code>SolverGMRES(SolverControl &amp;cn, VectorMemory&lt;Vector&gt; &amp;mem,
const AdditionalData &amp;data=Additionaldata())
</code>
This constructor needs the maximum number of temporary vectors to be used. 
A number too small can seriously affect its performance, but a number
too large will also increase the required computing time. This number is
contained in the <code>AdditionalData</code> structure with a default of 30. 
This solver is rather special, and for a detailed explanation you should
<a href="http://gaia.iwr.uni-heidelberg.de/~deal/doc/auto/kdoc/lac/SolverGMRES.html">take a look at the detailed description of the <code>SolverGMRES</code>
class</a>.
</p>

<p class="Example">
<span class="example">Example:</span>We initialize a GMRES-solver for
the problem <code>Au=f</code>, using the <a href="#control">solver control</a>
explained above. <code>A</code> shall be a sparse matrix and the vectors
<code>u</code> and <code>f</code> shall be vectors of doubles. 
Next, we solve the problem. We use the default number of thirty temporary
vectors.
</p>

<pre class="example">
<code>
// Include files for solver control, solver and preconditioner
#include &lt;lac/solver_control.h&gt;
#include &lt;lac/solver_gmres.h&gt;
#include &lt;lac/precondition_selector.h&gt;

// Include files for matrices and vectors
#include &lt;lac/sparse_matrix.h&gt;
#include &lt;lac/vector.h&gt;

// Initialize the solver control and the solver

SolverControl control(1000,1e-6);
VectorMemory&lt;Vector&lt;double&gt; &gt; vectormem;
SolverGMRES&lt;SparseMatrix&lt;double&gt;,Vector&lt;double&gt; &gt; solver(control,vectormem);

// Initialize the problem matrices. Well...they shouldn't only be
// initialized but also contain the problem, so this is just an example
// to get the definitions and types and everything right. 

SparseMatrix&lt;double&gt; A;
Vector&lt;double&gt; u,f;

// Generate a Jacobi preconditioner with the damping parameter 1
PreconditionSelector&lt;SparseMatrix&lt;double&gt;, Vector&lt;double&gt; &gt; preconditioning("jacobi",1.);

// Use the matrix of the linear equation system for preconditioning
// (this is the usual case).
preconditioning.use_matrix(A);

solver.solve(A,u,f,preconditioning);
</code>
</pre>


<h2><a name="richardson">SolverRichardson</a></h2>

<p>
This class implements the Richardson iteration method. The stopping criterion
is the norm of the residual. It is initialized using<br>
<code>SolverRichardson(SolverControl &amp;cn, VectorMemory&lt;Vector&gt; 
&amp;mem, const AdditionalData &amp;data=Additionaldata())
</code>
The additional data for this solver is the damping, with a default of 1.
</p>

<p class="Example">
<span class="example">Example:</span>We initialize a Richardson-solver for
the problem <code>Au=f</code>, using the <a href="#control">solver control</a>
explained above. <code>A</code> shall be a sparse matrix and the vectors
<code>u</code> and <code>f</code> shall be vectors of doubles. Next,
we solve the problem. We use the default damping parameter of 1.
</p>

<pre class="example">
<code>
// Include files for solver control, solver and preconditioner
#include &lt;lac/solver_control.h&gt;
#include &lt;lac/solver_richardson.h&gt;
#include &lt;lac/precondition_selector.h&gt;

// Include files for matrices and vectors
#include &lt;lac/sparse_matrix.h&gt;
#include &lt;lac/vector.h&gt;

// Initialize the solver control and the solver

SolverControl control(1000,1e-6);
VectorMemory&lt;Vector&lt;double&gt; &gt; vectormem;
SolverRichardson&lt;SparseMatrix&lt;double&gt;,Vector&lt;double&gt; &gt; solver(control,vectormem);

// Initialize the problem matrices. Well...they shouldn't only be
// initialized but also contain the problem, so this is just an example
// to get the definitions and types and everything right. 

SparseMatrix&lt;double&gt; A;
Vector&lt;double&gt; u,f;

// Generate a Jacobi preconditioner with the damping parameter 1
PreconditionSelector&lt;SparseMatrix&lt;double&gt;, Vector&lt;double&gt; &gt; preconditioning("jacobi",1.);

// Use the matrix of the linear equation system for preconditioning
// (this is the usual case).
preconditioning.use_matrix(A);

solver.solve(A,u,f,preconditioning);
</code>
</pre>

<!-- Page Foot -->
<hr>
<table class="navbar">      
<tr>
  <td>
    <a href="postprocess.html">Next Chapter: Postprocessing</a>
  </td>
  <td>
    <a href="toc.html">Back to this chapter's index</a>
  </td>
  <td>
    <a href="../index.html" target="_top">Back to the tutorial index</a>
  </td>
</tr>
</table>
<hr>
<address>
<a href="mailto:deal@iwr.uni-heidelberg.de">The deal.II group</a></address>
<p>
Last modified: $Date$ 
</p>
</body>
</html>
