<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"
   "http://www.w3.org/TR/REC-html40/strict.dtd">
<html>
<head>
<!-- deal.II tutorial template
     Jan Schrage <schrage@gaia.iwr.uni-heidelberg.de> 1999 
-->

<title>Solving the Problem</title>
    <link href="../dealtut.css" rel="StyleSheet" title="deal.II Tutorial">
    <meta name="author" content="Jan Schrage <schrage@gaia.iwr.uni-heidelberg.de>">
    <meta name="keywords" content="deal.II,deal.II tutorial,deal II">
</head>

<!-- Page Body -->
<body lang="en">

<h1>Solving the Problem</h1>

<p>
<acronym>deal.II</acronym> offers several solver classes:
</p>

<ul>
<li>
  <code><a href="#bicgstab">SolverBicgstab</a></code>, the Bicgstab algorithm 
	by van der Worst
</li>
<li>
  <code><a href="#cg">SolverCG</a></code>, the preconditioned cg-algorithm
</li>
<li>
  <code><a href="#gmres">SolverGMRES</a></code>, an implementation of the 
	Restarted 
	Preconditioned Direct Generalized Minimal Residual Method
</li>
<li>
  <code><a href="#richardson">SolverRichardson</a></code>, the Richardson 
	iteration method
</li>
</ul>

<p>
Besides, there is a class named 
<code><a href="#control">SolverControl</a></code> in order to 
control the iterative solvers, i.e. to determine whether the iteration 
should be continued and a class named 
<code><a href="#precondition">PreconditionSelector</a></code> that allows
you to select a preconditioner.
</p>

<p>
We will begin with the discussion of the <code>SolverControl</code>
and the <code>PreconditionSelector</code> classes, then discuss the solvers 
in more detail.
</p>

<h2><a name="control">Solver Control</a></h2>

<p>
The class <code>SolverControl</code> is used by iterative solvers
to determine whether to continue with the iteration. It takes two
to three parameters: the maximum number of iterations and the criterium for
abortion, usually the residual and a flag controlling whether to log the 
history (the value to be checked and the number of the iteration step).  
<code>SolverControl</code> is initialized using<br>
<code>SolverControl (const unsigned int n, const double tol, const bool log_history = false)</code>

<p class="Example">
<span class="example">Example:</span>We initialize a solver control with
a maximum of 1000 iterations and a maximum residual of 1e-6.
</p>

<pre class="example">
<code>
#include &lt;lac/solver_control.h&gt;

SolverControl control(1000,1e-6);
</code>
</pre>

<h2><a name="precondition">Preconditioning</a></h2>

<p>
Before firing up the solver of your choice you will need some kind of 
preconditioning. This is easiest selected by creating an instance of
the <code>PreconditionSelect</code> class with an appropriate choice of 
parameters. This can be done using <code>PreconditionSelector(const string
preconditioning, const typename Vector::value_type &amp;omega=1.)</code>
where <code>preconditioning</code> denotes the preconditioning method used 
and <code>omega</code> is the damping parameter.
</p>
<p>
The preconditioning methods currently available using this class are
</p>
<ul>
<li>none</li>
<li>jacobi</li>
<li>sor</li>
<li>ssor</li>
</ul>
<p>
You can obtain a list of available methods by calling
<code>string PreconditionSelector::get_precondition_names()</code>.
</p>

<p>
After having selected a preconditioner you will need to select a 
matrix used for preconditioning. Usually this will be the problem matrix 
<code>A</code> of the problem <code>Au=f</code>.
The method to be called is <code>void PreconditionSelector::use_matrix(const
Matrix &amp;M)</code>.
</p>

<p class="Example">
<span class="example">Example:</span>We initialize a Jacobi preconditioner
with a damping parameter of 1. The matrix used for preconditioning 
is the matrix <code>A</code>
of the problem <code>Au=f</code>.
</p>

<pre class="example">
<code>
#include &lt;lac/precondition_selector.h&gt;
#include &lt;grid/dof.h&gt;
#include &lt;lac/fullmatrix.h&gt;

FullMatrix&lt;double&gt; A(100,50);

PreconditionSelector preconditioning("jacobi",1.);
preconditioning.use_matrix(A);
</code>
</pre>



<h2><a name="bicgstab">SolverBicgstab</a></h2>

<p>
This class implements the Bicgstab algorithm by van der Worst.
It is initialized by<br>
<code>SolverBicgstab (SolverControl &cn, VectorMemory<Vector> &mem)</code>.
</p>
<p class="Example">
<span class="example">Example:</span>We initialize a Bicgstab-solver for
the problem <code>Au=f</code>, using the <a href="#control">solver control</a>
explained above. <code>A</code> shall be a sparse matrix and the vectors
<code>u</code> and <code>f</code> shall be vectors of doubles. Next,
we solve the problem. 
</p>

<pre class="example">
<code>
// Include files for solver control, solver and preconditioner
#include &lt;lac/solver_control.h&gt;
#include &lt;lac/solver_bicgstab.h&gt;
#include &lt;lac/precondition_selector.h&gt;

// Include files for matrices and vectors
#include &lt;lac/sparsematrix.h&gt;
#include &lt;lac/vector.h&gt;

// Initialize the solver control and the solver

SolverControl control(1000,1e-6);
VectorMemory&lt;Vector&lt;double&gt; &gt; vectormem;
SolverBicgstab&lt;SparseMatrix,Vector&lt;double&gt; &gt; solver(control,vectormem);

// Initialize the problem matrices. Well...they shouldn't only be
// initialized but also contain the problem, so this is just an example
// to get the definitions and types and everything right. 
// <em>To make it clear: This code as it is will not do anything because</em>
// <em>it does not contain any mathematical problem !</em> 

SparseMatrix&lt;double&gt; A;
Vector&lt;double&gt; u,f;

// Generate a Jacobi preconditioner with the damping parameter 1
PreconditionSelector&lt;SparseMatrix&lt;double&gt;, Vector&lt;double&gt; &gt; preconditioning("jacobi",1.);

// Use the matrix of the linear equation system for preconditioning
// (this is the usual case).
preconditioning.use_matrix(A);

solver.solve(A,u,f,preconditioning);
</code>
</pre>

<h2><a name="cg">SolverCG</a></h2>

<p>
This class implements the preconditioned cg-method.
It is initialized by<br>
<code>SolverCG (SolverControl &cn, VectorMemory<Vector> &mem)</code>.
</p>
<p class="Example">
<span class="example">Example:</span>We initialize a CG-solver for
the problem <code>Au=f</code>, using the <a href="#control">solver control</a>
explained above. <code>A</code> shall be a sparse matrix and the vectors
<code>u</code> and <code>f</code> shall be vectors of doubles. Next,
we solve the problem. 
</p>

<pre class="example">
<code>
// Include files for solver control, solver and preconditioner
#include &lt;lac/solver_control.h&gt;
#include &lt;lac/solver_bicgstab.h&gt;
#include &lt;lac/precondition_selector.h&gt;

// Include files for matrices and vectors
#include &lt;lac/sparsematrix.h&gt;
#include &lt;lac/vector.h&gt;

// Initialize the solver control and the solver

SolverControl control(1000,1e-6);
VectorMemory&lt;Vector&lt;double&gt; &gt; vectormem;
SolverCG&lt;SparseMatrix,Vector&lt;double&gt; &gt; solver(control,vectormem);

// Initialize the problem matrices. Well...they shouldn't only be
// initialized but also contain the problem, so this is just an example
// to get the definitions and types and everything right. 
// <em>To make it clear: This code as it is will not do anything because</em>
// <em>it does not contain any mathematical problem !</em> 

SparseMatrix&lt;double&gt; A;
Vector&lt;double&gt; u,f;

// Generate a Jacobi preconditioner with the damping parameter 1
PreconditionSelector&lt;SparseMatrix&lt;double&gt;, Vector&lt;double&gt; &gt; preconditioning("jacobi",1.);

// Use the matrix of the linear equation system for preconditioning
// (this is the usual case).
preconditioning.use_matrix(A);

solver.solve(A,u,f,preconditioning);
</code>
</pre>


<!-- Page Foot -->
<hr>
<table class="navbar">      
<tr>
  <td>
    <a href="postprocess.html">Next Chapter: Postprocessing</a>
  </td>
  <td>
    <a href="toc.html">Back to this chapter's index</a>
  </td>
  <td>
    <a href="../index.html" target="_top">Back to the tutorial index</a>
  </td>
</tr>
</table>
<hr>
<address>
<a href="mailto:schrage@gaia.iwr.uni-heidelberg.de">Jan Schrage</a></address>
<p>
Last modified: $Date$ 
</p>
</body>
</html>
