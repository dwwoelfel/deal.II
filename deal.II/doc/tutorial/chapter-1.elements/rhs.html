<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"
   "http://www.w3.org/TR/REC-html40/strict.dtd">
<html>
<head>
<!-- deal.II tutorial template
     Jan Schrage and others <deal@iwr.uni-heidelberg.de> 1999 
-->

<title>deal.II tutorial: The Problem Matrix and the Right Hand Side</title>
    <link href="../../screen.css" rel="StyleSheet" title="deal.II Tutorial" media="screen">
    <link href="../../print.css" rel="StyleSheet" title="deal.II Tutorial" media="print">
    <meta name="author" content="Jan Schrage and others <deal@iwr.uni-heidelberg.de>">
    <meta name="keywords" content="deal.II,deal.II tutorial,deal II">
</head>

<!-- Page Body -->
<body lang="en">

<h1>The Problem Matrix and the Right Hand Side</h1>

<p>
Having talked a lot about the initialization of matrices and vectors
we shall now discuss how to fill them. You have to:
</p>
<ol>
  <li>Define a quadrature rule which will be used for integration of
  the local cell matrices and vectors. </li>
  <li><a href="#calcfe">Calculate the trial functions</a> for the
	finite elements and their faces. 
  </li>
  <li><a href="#integrate">Integrate the problem locally.</a></li>
  <li>Insert your local matrix into the global one.</li>
</ol>

<h2><a name="calcfe">Calculating finite element trial functions</a></h3>

<p>
</p>

<p class="Example">
<span class="example">Example:</span> The two lines below calculate
trial functions for the two-dimensional finite element <code>fe</code>
and for its faces using Gaussian quadrature. The first line
initializes an object for the trial and test functions of the
finite element associated with the degree of freedom handler
<code>dof_handler</code>, telling it to update the values of the gradients and
of the Jacobi determinant multiplied by a weight function given by the
quadrature <code>quadrature</code> whenever <code>fe_values.reinit(fe)</code>
is called on a cell. The second line does the same for the faces of the finite
element, telling it to update the <code>JxW</code> values and the
quadrature points.
</p>
<pre class="example">
<code>
// Initialize the trial functions on the cell faces.
FEValues&lt;2&gt; fe_values(fe, quadrature,
                   UpdateFlags(update_values    | 
                               update_gradients |
                               update_JxW_values));
FEFaceValues&lt;2&gt; fe_face_values (fe, face_quadrature,
                              UpdateFlags(update_values     | 
                                          update_JxW_values |
                                          update_q_points));
</code>
</pre>

<h2><a name="integrate">Integrating the problem</a></h2>

<p>
Integration of a problem is performed locally, i.e. you have to traverse all
the cells and integrate the problem on the cell. This implies that you need a local
matrix to store your results. This local matrix must then be inserted 
into the global problem matrix. 
</p>

<p class="example">
<span class="example">Example: Integration of the two-dimensional Laplace-problem:</span>
Integration is done locally. Therefore we need appropriate definitions for
</p>
<ul>
<li>
an index vector that will allow us to reassemble the global matrix later on
</li>
<li>a vector of doubles with the dimension of the number of degrees of freedom per cell
</li>
<li>and a square matrix of doubles with the same dimension</li>
</ul>

<pre class="example">
<code>
  vector&lt;int&gt; dof_indices (fe.dofs_per_cell);
  Vector&lt;double&gt; element_vector (fe.dofs_per_cell);
  
  FullMatrix&lt;double&gt; element_matrix (fe.dofs_per_cell, fe.dofs_per_cell);
</code>
</pre>

<p class="example">
Next we traverse all the cells and integrate the Laplace problem using the
discretized Laplace operator. <tt>quadrature</tt> is some quadrature
rule, for example a Gaussian rule.
</p>

<p class="example">
Within the loop over all cells, the outer loop traverses all the
points of the quadrature <code>quadrature</code>.  The inner two loops
traverse the degrees of freedom of the finite element <code>fe</code>
where <code>du</code> and <code>dv</code> are the gradients of the
trial and test functions at the present quadrature points. 
<code>fe_values.JxW(k)</code> gives
the Jacobi determinant multiplied by the weight of the quadrature
point <code>k</code>. Taken together the line <br>
<code>
element_matrix(i,j) += fevalues.JxW(k) * du * dv;
</code>
<br>
gives the discretized Laplace operator.
</p>

<pre class="example">
<code>
// Integrate the problem locally...
vector&lt;int&gt;        local_dof_indices (fe.dofs_per_cell);
Vector&lt;double&gt;     element_vector    (fe.dofs_per_cell);
FullMatrix&lt;double&gt; element_matrix    (fe.dofs_per_cell);

                        // traverse all cells  
for (DoFHandler&lt;2&gt;::active_cell_iterator cell = dof_handler.begin_active();
     cell != dof_handler.end(); ++cell)
{
                        // compute gradients and some other values
                        // of the shape functions on this cell
  fe_values.reinit (cell);
                        // set entries of local matrix and vector
                        // to zero
  element_matrix.clear();
  element_vector.clear();

                        // The loop over the quadrature points
                        // starts here. In effect, the  integration
                        // is performed in this loop.
  for (unsigned q_point=0; q_point&lt;quadrature.n_quadrature_points; ++q_point)
    for (unsigned i=0; i&lt;fe.dofs_per_cell; ++i)
      {
        const Point&lt;dim&gt; dv = fe_values.shape_grad (i, q_point);
	
        for (unsigned j=0; j&lt;fe.dofs_per_cell; ++j)
          {
	    const Point&lt;2&gt; du = fe_values.shape_grad(j,q_point);
	
	                // Perform the integration using
                        // the weak form of the Laplace operator
	    element_matrix(i,j) += fevalues.JxW(k) * du * dv;
          }
      }

                        // get the global indices of the degrees
                        // of freedom on the present cell
  cell-&gt;get_dof_indices (local_dof_indices);
                        // and insert the local matrix
                        // into the global one.
  for (unsigned i=0; i&lt;fe.dofs_per_cell; ++i)
    for (unsigned j=0; j&lt;fe.dofs_per_cell; ++j)
      A.add (local_indices[i], local_indices[j],
             element_matrix (i,j));
}    
</code>
</pre>

The right hand side vector is set up analogously, but obviously you
only need one loop over the shape functions, since the right hand side
is a linear form instead of a bilinear one.


<!-- Page Foot -->
<hr>
<table class="navbar">      
<tr>
  <td>
    <a href="boundary.html">Next Chapter: Boundary Conditions</a>
  </td>
  <td>
    <a href="toc.html">Back to this chapter's index</a>
  </td>
  <td>
    <a href="../index.html" target="_top">Back to the tutorial index</a>
  </td>
</tr>
</table>
<hr>
<address>
<a href="../../mail.html">The deal.II group</a></address>
<p>

</p>
</body>
</html>


