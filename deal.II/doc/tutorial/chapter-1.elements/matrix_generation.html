<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"
   "http://www.w3.org/TR/REC-html40/strict.dtd">
<html>
<head>
<!-- deal.II tutorial template
     Jan Schrage and others <deal@iwr.uni-heidelberg.de> 1999 
-->

<title>deal.II tutorial: Matrix and Vector Generation</title>
    <link href="../screen.css" rel="StyleSheet" title="deal.II Tutorial" media="screen">
    <link href="../print.css" rel="StyleSheet" title="deal.II Tutorial" media="print">
    <link href="../audio.css" rel="StyleSheet" title="deal.II Tutorial" media="aural">
    <meta name="author" content="Jan Schrage and others <deal@iwr.uni-heidelberg.de>">
    <meta name="keywords" content="deal.II,deal.II tutorial,deal II">
</head>

<!-- Page Body -->
<body lang="en">

<h1>Matrix and Vector Generation</h1>

<h2>Different kinds of matrices</h2>
<p>
There are several kinds of matrices which we will deal with: 
</p>
<ul>
<li>
<a href="#full">Full matrices</a>, i.e. matrices where we store all
entries, which is useful if the majority of entries is non-zero.
</li>
<li>
<a href="#sparse">Sparse matrices</a>, i.e. matrices where the majority of 
cells has zero value; these zeroes are not stored in order to save memory.
</li>
</ul>

<h3><a name="full">The full matrix</a></h3>

<p>
The full matrix is useful is we can assume that the we have mostly
entries of non-zero value.  Since we then store all entries, it
consumes a lot of memory, much more than the other matrix types.  It
is initialized using <code>FullMatrix::reinit(const unsigned int rows,
const unsigned int cols)</code>.
</p>

<p class="Example">
<span class="example">Example:</span> We show the include files you need, 
the definitions and the function calls. Make sure to use them in their
appropriate places. This example initializes two full matrices of doubles
with 100 rows and 50 columns in two different ways.
</p>
<pre class="example">
<code>
#include &lt;dofs/dof_handler.h&gt;
#include &lt;lac/full_matrix.h&gt;

FullMatrix&lt;double&gt; A;

A.reinit(100,50);

// or, alternatively (important for const objects):

FullMatrix&lt;double&gt; B(100,50);

</code>
</pre>


<h3><a name="sparse">The sparse matrix</a></h3>

<p>
A sparse matrix is a matrix with mostly zero elements. In other words,
it is possible to store this matrix efficiently, which can be important
for large systems of equations. Before generating a sparse matrix you 
will have to generate a 
<a href="matrix_structure.html">sparse matrix structure</a> 
to initialize the sparse matrix with. This is simply due to the fact that
before you can generate a memory-efficient matrix for your special
problem you need information about the matrix structure, i.e. where
the matrix has non-zero entries.
</p>


<p class="Example">
<span class="example">Example:</span> We show the include files you need, 
the definitions and the function calls. Make sure to use them in their
appropriate places. This example initializes a sparse square matrix structure.
</p>
<pre class="example">
<code>
#include &lt;dofs/dof_handler.h&gt;
#include &lt;lac/sparse_matrix.h&gt;


const unsigned int dim=2; // For example
SparseMatrixStruct sparsity_pattern;
SparseMatrix&lt;double&gt; sparse_matrix;
DoFHandler&lt;dim&gt; dof_handler;

// Your degrees of freedom must already be distributed

sparsity_pattern.reinit (dof_handler.n_dofs(),
                         dof_handler.n_dofs(),
                         dof_handler.max_couplings_between_dofs());

// If your grid is locally refined, <a href="matrix_structure.html#sparsity_pattern">condense the hanging nodes</a> into the
// structure.

sparsity_pattern.compress();

// initialize the actual matrix with the sparsity pattern
sparse_matrix.reinit (sparsity_pattern);
</code>
</pre>


<h2>Vector Generation</h2>

<p>
Vector operations are supplied by the class <code><a
href="http://gaia.iwr.uni-heidelberg.de/~deal/doc/auto/kdoc/lac/Vector.html">Vector</a></code>.
The first and most important operation on a vector is its
initialization using <code>void Vector::reinit(const usigned int N,
const bool fast=false)</code>, which resets the vector's size to
<code>N</code> and sets all elements to zero.  If the second parameter
<code>fast</code> is set true, this means that the entries will not be
cleared; this is useful if the vector is being assigned to immediately
after, in which case an initialization with zeroes would be
redundant. Note that this mode of use is rather uncommon and mostly
only useful inside linear solvers where it is important to save as
much computing time as possible.
</p>

<p>
In addition to standard vector operations such as addition, multiplication with
a vector etc. <acronym>deal.II</acronym> provides several vector norms, too:
</p>

<ul>
  <li>the l1-norm: <code>Number Vector::l1_norm() const</code></li>
  <li>the l2-norm: <code>Number Vector::l2_norm() const</code></li>
  <li>the infinity-norm: <code>Number Vector::infty_norm() const</code></li>
</ul>

<p class="Example">
<span class="example">Example:</span>Continuing the above example, 
we initialize the vector for the right hand side. Recall that the problem 
matrix is a sparse square matrix of size 
<code>dof.n_dofs()<sup>2</sup></code>. 
</p>
<pre class="example">
<code>
#include &lt;lac/vector.h&gt;

Vector&lt;double&gt; f;

f.reinit(dof.n_dofs());
</code>
</pre>


<h2>A word on memory allocation</h2>

Since vectors and matrices are used <i>very</i> often, it is necessary
to be rather conservative with operations that may use significant
computing time. One of such operations is memory allocation and
de-allocation. For this reason, the <code>reinit</code> functions of
all vector and matrix classes are implemented in a way to only allow
the allocated memory to grow, since this reduces the number of times
allocation and de-allocation has to happen, and in addition reduces
memory fragmentation.
</p>
<p>
One immediate consequence is that if you write
<pre class="example">
<code>
Vector&lt;double&gt; f;
f.reinit(100);
f.reinit(50);
</code>
</pre>
then the second <code>reinit</code> will only have the effect of
reducing the internal size of the vector, but the memory that is no
more needed will not be released. Likewise, if you later write
<pre class="example">
<code>
f.reinit(100);
</code>
</pre>
this will again only set the size of the vector to a different value,
but since enough memory is still allocated, no re-allocation has to
happen. Only if the required number of entries exceeds the memory
already allocated, will there be a re-allocation.
</p>
<p>
All matrix and vector classes in <acronym>deal.II</acronym> work this
way, and in fact this is also the way the standard C++ container
classes like <code>vector</code> or <code>map</code> work.
However, this is not very useful if you use vectors or matrices
as member variables, since at times they may not be used at all if
your program works on other objects or you are in other parts of the
object. You would then like to let the vectors and matrices sleep with
no memory presently lying around unused. For this purpose, all
matrices and vectors support a mode of their <code>reinit</code>
function which frees all memory that is presently allocated: just call
it with parameters such that the new size is zero. For example, the
following lines will release all memory from their objects:
<pre class="example">
<code>
f.reinit(0);
full_matrix.reinit(0,0);
sparse_matrix_struct.reinit (0,0);
sparse_matrix.reinit (sparse_matrix_struct);
</code>
</pre>
Note that in the last line, you have to pass an empty sparsity pattern
to the sparse matrix to tell it to release all of its memory.


<h4>A word of caution</h4>

It is noted that several vector and matrix classes have a
<code>clear</code> function. These, however, work differently than
might be expected from the analogous functions in the C++ standard
library. There, <code>clear</code> removes all data from the objects
and resets it into a virgin state. In <acronym>deal.II</acronym>,
<code>clear</code> only resets the values of a metrix or vector to
zero, but does not change the size and does no re-allocation
either. This unfortunate name clash is due to historical reasons.

<!-- Page Foot -->
<hr>
<table class="navbar">      
<tr>
  <td>
    <a href="rhs.html">Next Chapter: Problem Matrix and RHS</a>
  </td>
  <td>
    <a href="toc.html">Back to this chapter's index</a>
  </td>
  <td>
    <a href="../index.html" target="_top">Back to the tutorial index</a>
  </td>
</tr>
</table>
<hr>
<address>
<a href="mailto:deal@iwr.uni-heidelberg.de">The deal.II group</a></address>
<p>
Last modified: $Date$ 
</p>
</body>
</html>
