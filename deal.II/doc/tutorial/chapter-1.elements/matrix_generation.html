<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"
   "http://www.w3.org/TR/REC-html40/strict.dtd">
<html>
<head>
<!-- deal.II tutorial template
     Jan Schrage <schrage@gaia.iwr.uni-heidelberg.de> 1999 
-->

<title>Matrix and Vector Generation</title>
    <link href="../dealtut.css" rel="StyleSheet" title="deal.II Tutorial">
    <meta name="author" content="Jan Schrage <schrage@gaia.iwr.uni-heidelberg.de>">
    <meta name="keywords" content="deal.II,deal.II tutorial,deal II">
</head>

<!-- Page Body -->
<body lang="en">

<h1>Matrix and Vector Generation</h1>

<h2>Different kinds of matrices</h2>
<p>
There are several kinds of matrices we will deal with: 
</p>
<ul>
<li>
<a href="#full">Full matrices</a>, i.e. matrices where the majority of 
cells have non-zero values.
</li>
<li>
<a href="#block">Block sparse matrices</a> where the matrix is assumed to 
consist of blocks on the diagonal.
</li>
<li>
<a href="#sparse">Sparse matrices</a>, i.e. matrices where the majority of 
cells has zero value.
</li>
</ul>

<h3><a name="full">The full matrix</a></h3>

<p>
The full matrix is assumed to have mostly cells of non-zero value. 
Therefore it consumes a lot of memory, much more than the other matrix types.
It is initialized using <code>FullMatrix::reinit(const unsigned
int rows, const unsigned int cols)</code>.
</p>

<p class="Example">
<span class="example">Example:</span> We show the include files you need, 
the definitions and the function calls. Make sure to use them in their
appropriate places. This example initializes a full matrix of doubles
with 100 rows and 50 columns.
</p>
<pre class="example">
<code>
#include &lt;grid/dof.h&gt;
#include &lt;lac/fullmatrix.h&gt;

FullMatrix&lt;double&gt; A;

A.reinit(100,50);
</code>
</pre>


<h3><a name="sparse">The sparse matrix</a></h3>

<p>
A sparse matrix is a matrix with mostly zero elements. In other words,
it is possible to store this matrix efficiently, which can be important
for large systems of equations. Before generating a sparse matrix you 
will have to generate a 
<a href="matrix_structure.html">sparse matrix structure</a> 
to initialize the sparse matrix with. This is simply due to the fact that
before you can generate a memory-efficient matrix for your special
problem you need information about the matrix structure, i.e. where
the matrix has non-zero entries.
</p>


<p class="Example">
<span class="example">Example:</span> We show the include files you need, 
the definitions and the function calls. Make sure to use them in their
appropriate places. This example initializes a sparse square matrix structure.
</p>
<pre class="example">
<code>
#include &lt;grid/dof.h&gt;
#include &lt;lac/sparsematrix.h&gt;


int dim=2; // For example
SparseMatrixStruct&lt;double&gt; smstruct;
SparseMatrix&lt;double&gt; sm;
DoFHandler&lt;dim&gt; dof;

// Your degrees of freedom must already be distributed

smstruct.reinit(dof.n_dofs(),dof.n_dofs(),dof.max_couplings_between_dofs());

// If your grid is locally refined, <a href="matrix_structure.html#smstruct">condense the hanging nodes</a> into the
// structure.

smstruct.compress();

sm.reinit(smstruct);
</code>
</pre>

<h3><a name="block">The block sparse matrix</a></h3>

<p>
A block matrix is assumed to consist of blocks on the diagonal with all
the blocks having the same size.
It is initialized using 
<code>BlockSparseMatrix::reinit(const SparseMatrixStruct &amp;sparsity)</code>
Since this is a sparse matrix, i.e. a matrix that can be
stored efficiently, we need to generate a matrix structure first, like for the 
sparse matrix. In fact, the block sparse matrix is just a specialization of
the sparse matrix.
</p>

<p class="Example">
<span class="example">Example:</span> We show the include files you need, 
the definitions and the function calls. Make sure to use them in their
appropriate places. 
</p>
<pre class="example">
<code>
#include &lt;grid/dof.h&gt;
#include &lt;lac/blocksparsematrix.h&gt;

int dim=2; // 2 Dimensions, could also be three
SparseMatrixStruct&lt;double&gt; smstruct;
DoFHandler&lt;dim&gt; dof;
BlockSparseMatrix&lt;double&gt; A;


// Your degrees of freedom must already be distributed

smstruct.reinit(dof.n_dofs(),dof.n_dofs(),dof.max_couplings_between_dofs());

// If your grid is locally refined, <a href="matrix_structure.html#smstruct">condense the hanging nodes</a> into the
// structure.

smstruct.compress();

A.reinit(smstruct);
</code>
</pre>


<!-- Page Foot -->
<hr>
<table class="navbar">      
<tr>
  <td>
    <a href="rhs.html">Next Chapter: Problem Matrix and RHS</a>
  </td>
  <td>
    <a href="toc.html">Back to this chapter's index</a>
  </td>
  <td>
    <a href="../index.html" target="_top">Back to the tutorial index</a>
  </td>
</tr>
</table>
<hr>
<address>
<a href="mailto:schrage@gaia.iwr.uni-heidelberg.de">Jan Schrage</a></address>
<p>
Last modified: $Date$ 
</p>
</body>
</html>
