<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"
   "http://www.w3.org/TR/REC-html40/strict.dtd">
<html>
<head>
<!-- deal.II tutorial template
     Jan Schrage <schrage@hermes.iwr.uni-heidelberg.de> 1999 
-->

<title>deal.II tutorial: Grid and Data Output</title>
    <link href="../screen.css" rel="StyleSheet" title="deal.II Tutorial" media="screen">
    <link href="../print.css" rel="StyleSheet" title="deal.II Tutorial" media="print">
    <link href="../audio.css" rel="StyleSheet" title="deal.II Tutorial" media="aural">
    <meta name="author" content="Jan Schrage <schrage@hermes.iwr.uni-heidelberg.de>">
    <meta name="keywords" content="deal.II,deal.II tutorial,deal II">
</head>

<!-- Page Body -->
<body lang="en">

<h1>Grid and Data Output</h1>

<p>
Grid and data output becomes a difficult thing as soon as flexibility
in terms of different output formats and which parts of the data 
are actually written is required.
Consequently, there is a bunch of classes in <acronym>deal.II</acronym>, 
every one dealing with a different aspect of the problem. You, the 
user, however, need to concern yourself only with two ouput classes:
<code>GridOut</code> and <code>DataOut</code> handling the output of
grid and data, respectively.  In addition there is one class for
each kind of output storing the parameters for this particular 
format. These parameters are common to both grid and data ouput 
and are used by both <code>GridOut</code> and <code>DataOut</code>.
</p>

<p>
Since <acronym>deal.II</acronym> is fairly versatile when it comes
to graphics output we shall have to talk about the following topics
in depth:
</p>

<ul class="pagetoc">
  <li><a href="#formats">Graphics formats</a> for 
	<code>GridOut</code> and <code>DataOut</code>
  </li>
  
  <li><a href="#parameters">Parameters</a> for the different formats
	common to both <code>GridOut</code> and <code>DataOut</code>
  </li>

  <li><a href="#usage">Usage of <code>DataOut</code></a>
  </li>

  <li><a href="#usage">Usage of <code>GridOut</code></a>
  </li>
</ul>

<hr>
<hr>

<h2><a name="formats">Graphics Formats</a></h2>
<p>
<acronym>deal.II</acronym> provides a class called <code>DataOut</code>
dealing with the output of simulation data and a class called
<code>GridOut</code> handling the output of grid (triangulation) data. 
Both are fairly versatile and can handle a 
number of different data formats.
</p>

<h3><code>DataOut</code> graphics formats</h3>
<p>
The graphics formats available in <code>DataOut</code> are:
</p>
<ul>
  <li><a href="#ucd">Unstructured Cell Data (ucd)</a>
  </li>

  <li><a href="#gnuplot">Gnuplot</a>, in two different qualities.
  </li>

  <li><a href="#eps">Encapsulated Postscript (eps)</a>
  </li>

  <li><a href="#pov">PoVRay mesh data</a>, for use with the PoVRay raytracer.
  </li>

  <li><a href="#gmv">General Mesh Viewer</a>
  </li>
</ul>


<h3><code>GridOut</code> graphics formats</h3>
<p>
The graphics formats available in <code>GridOut</code> are:
</p>
<ul>
  <li><a href="#grid_ucd">Unstructured Cell Data (ucd)</a>
  </li>

  <li><a href="#grid_gnuplot">Gnuplot</a>
  </li>

  <li><a href="#grid_eps">Encapsulated Postscript (eps)</a>
  </li>
</ul>

<hr>
<hr>

<h2><a name="parameters">Parameters for grid and data output</a></h2>

<p>For each output format there is a class containing the
parameters that determine how the output will look. All these classes
have a sensible set of default parameters; you will only have
to bother about setting parameters yourself if your desires are
rather special. We shall commence with a brief description of 
these classes and the most important parameters you can set. It is
also worthwhile to look at the online documentation to see whether
additional flags have been introduced in the meantime.
</p>


<h3>UcdFlags</h3>

<p>
This class provides the settings for ucd output. The values in brackets
denote the default values.
</p>
<ul>
      <li><code>bool write_preamble</code> (true): 
	  Determines whether to write a preamble containing creation
	  date etc.
      </li>
</ul>

<h3>GnuplotFlags</h3>

<p>
This class provides the settings for gnuplot output. At present it
is empty.
</p>

<h3>EpsFlags</h3>

<p>
This class provides the settings for EPS output. The values in brackets
denote the default values.
</p>

<ul>
      <li><code>unsigned int height_vector</code> (0):
	Number of the data vector to be used for generation of the height 
	information. The number is determined by the order in which 
	<code>DataOut&lt;dim&gt;::add_data_vector</code> was called
	for the different vectors.
      </li>
      <li><code>unsigned int color_vector</code> (0):
	Number of the data vector to be used for colorizing cells.
	The number is determined by the order in which 
	<code>DataOut&lt;dim&gt;::add_data_vector</code> was called
	for the different vectors.
      </li>
      <li><code>SizeType sizetype</code> (width):
	Determines whether the width or the height is used to scale
	the output. Can be set to width or height.
      </li>
      <li><code>unsigned int size</code> (300): 
	Size of the output in points. One point is 1/72 inch.
      </li>
      <li><code>double line_width</code> (0.5):
	Width of a line in points. One point is 1/72 inch.
      </li>
      <li><code>double azimut_angle</code> (60):
	Viewing angle with respect to the positive z-axis.
      </li>
      <li><code>double turn_angle</code> (30):
	We quote the class documentation:
	<cite>Angle by which the viewers position projected onto the 
	  x-y-plane is rotated around the z-axis, in positive sense when 
	  viewed from above. The unit are degrees, and zero
	  equals a position above or below the negative y-axis.
	</cite>
      </li>
      <li><code>double z_scaling</code> (1):
	Factor by which the z-axis is stretched compared to the
	x- and y-axis.
      </li>
      <li><code>bool draw_mesh</code> (true): 
	Determines whether the cell boundaries are drawn.
      </li>
      <li><code>bool draw_cells</code> (true): Determines whether the
	cells are drawn. If this flag is true and 
	<code>shade_cells</code> is false the cells are filled with white.
      </li>
      <li><code>bool shade_cells</code> (true):
	Determines whether to colour cells. 
      </li>
      <li><code>ColorFunction color_function</code> (&amp;default_color_function):
	Determines the function to use for colouring the cells. The default
	shifts the colours from black for the lowest values through the
	spectrum towards white.
      </li>
 </ul>

<h3>PovrayFlags</h3>
<p>
This class provides the settings for PoVRay output. There are several
flags implemented presently, but we advise you to consult the online
documentation since they are rather special and you will probably have
to set them anyway, if you want high-quality output.
</p>

<h3>GmvFlags</h3>
<p>
This class provides the settings for General Mesh Viewer output. At present it 
is empty.
</p>


<hr>
<hr>

<h2><a name="usage">General description of the usage of 
<code>DataOut</code></a></h2>

<p>
What exactly it is you need to do in order to make use of the 
<code>DataOut</code> 
class is described in the table below. Note that data is written to an 
<code>ostream</code>. That means you have to attach your <code>ostream</code>
to a file if you want to use the data later on.
</p>

<table>
<caption><b>Usage of the <code>DataOut</code> class</b></caption>
<tr>
  <td><b>Step</b>
  </td>
  <td><b>What to do</b>
  </td>
  <td><b>Function call</b>
  </td>
</tr>
<tr>
  <td>1.</td>
  <td>Use the correct include-file.
  </td>
  <td><code>#include &lt;basic/data_out.h&gt;</code>
  </td>
</tr>
<tr>
  <td>2.</td>
  <td>Create an object of this class with the right dimension. 
      It takes no initialization parameters.
  </td>
  <td><code>DataOut&lt;dim&gt; my_data_out;</code>
  </td>
</tr>
<tr>
  <td>3.
  </td>
  <td>Attach a <a href="dofs.html"><code>DoFHandler</code></a> 
      object to your <code>DataOut</code>
      object. This <code>DoFHandler</code> 
      is used to extract geometry
      data and the mapping between nodes and node values.
  </td>
  <td><code>
        void DataOut&lt;dim&gt;::attach_dof_handler(const DoFHandler&lt;dim&gt; &amp;)
      </code>
  </td>
</tr>
<tr>
  <td>4.
  </td>
  <td>Add data vectors to be written to a file. The second and third argument
      are the name of the vector and its physical units.
  </td>
  <td><code>
        void DataOut&lt;dim&gt;::add_data_vector(const Vector&lt;double&gt; &amp;data,
        const string &amp;name, const string &amp;
	units=&quot;&lt;dimensionless&gt;&quot;)
      </code>
  </td>
</tr>
<tr>
  <td>5.
  </td>
  <td>Generate an <code>ostream</code> (and, normally, attach it to a file).
  </td>
  <td><code>
      ofstream out("filename");
      </code>
  </td>
</tr>
<tr>
  <td>6.
  </td>
  <td>Write your data to this ofstream. The second parameter denotes the 
      output format to be used. It must be one of <code>{ ucd, gnuplot, 
      gnuplot_draft,
      povray_mesh, eps, gmv }</code>.
  </td>
  <td><code>void DataOut&lt;dim&gt;::write(ostream &amp;out, const OutputFormat output_format)</code>
  </td>
</tr>
</table>


<hr>

<h2><a name="dataout_formats"><code>DataOut</code> data formats</a></h2>

<h3><a name="ucd">Unstructured Cell Data (ucd)</a></h3>

<p>
The ucd data format is described in the AVS developer's guide. There
are a binary and a ASCII version of this format. <acronym>deal.II</acronym>
uses the ASCII ucd format.
</p>

<h4>Limitations of the ucd format</h4>
<p>
Only node based data can be written, higher order elements are written
with their node values, not with interior or line values. This is
due to limitations in the present format. In this implementation
it is not possible to give model data since this is not widely supported.
It is possible to give cell data.
</p>

<h4>Usage of the ucd format</h4>

<p>
In order to write your data in ucd format you need to follow the
steps described in the section on the <a href="#usage">usage of 
<code>DataOut</code></a>. 
The data is written using <code>void write(ostream &amp;out,"ucd")</code>.
</p>


<h3><a name="gnuplot">Gnuplot data format</a></h3>

<h4>Understanding gnuplot data</h4>

<p>
The gnuplot data format is a pure ASCII format where each line is 
of the form<br>
<code>x v1 v2 ...</code><br>
for one-dimensional data and<br>
<code>x y v1 v2 ...</code><br>
for two-dimensional data.<br>
<code>x</code> and <code>y</code> denote the grid coordinates,
<code>v<sub>i</sub></code> denote the vertex values.
</p>

<p>
A somewhat more elaborate description can be found in the 
<a href="http://www.cs.dartmouth.edu/gnuplot/gptug.ps">Gnuplot User's Guide (Postscript)</a>
</p>

<h4>Viewing gnuplot data</h4>

<p>
In order to view a one-dimensional plot you use<br>
<code>
plot &quot;filename&quot; using 1:x</code><br>
where <code>x</code> denotes the number of the vertex you wish to plot.
</p>

<p>
In order to view your grid in two dimensions you should use<br>
<code>
set data style lines<br>
plot &quot;filename&quot;<br>
</code>
and to finally see your results<br>
<code>
set data style lines<br>
plot &quot;filename&quot; using 1:2:x
</code><br>
where again <code>x</code> denotes the number of the vertex 
to be plotted.
</p>


<h4>Limitations of the gnuplot data format</h4>

<p>The limitations of the gnuplot data format have been well described
in the 
<a href="http://hermes.iwr.uni-heidelberg.de/~deal/doc/auto/kdoc/basic/DataOut.html">
<code>DataOut</code> class description</a>:
</p>
<blockquote>
<p>
This format is somewhat restricted to coninuous data and to finite elements of first order only. The reason for the first restriction is that it takes nodal values and can
therefore only work if a finite element has degrees of freedom in the vertices of each cell. This is not the case for discontinuous elements. The second restriction is only a
problem of quality of output: you actually can print quadratic or higher order elements using this style, but you will only see the contour of each cell with the bounding lines of
each cell being straight lines. You won't see the structure of the solution in the interior of a cell nor on the lines bounding it. 
</p>
</blockquote>

<h4>The two different qualities of gnuplot output</h4>

<p>The limitations mentioned above can to some extent be remedied,
and that is why there is also an option for high quality output.
For how this is done, we quote (again) the 
<a href="http://hermes.iwr.uni-heidelberg.de/~deal/doc/auto/kdoc/basic/DataOut.html">
<code>DataOut</code> class description</a>:
</p>

<blockquote>
<p>
To remedy the abovementioned problems, the gnuplot &quot;quality&quot; format 
was introduced. [...] gnuplot can handle tensor grids and 
displays them quite nicely,
including hidden line removal. It can also handle more than one tensor grid, 
then called a patch. The idea now is to describe each cell as a patch of 
<code>N x N</code> points (in 2D).
For linear elements, <code>2 x 2</code> is sufficient, but for elements
of higher order you will want to use a higher number. The 
<code>write_gnuplot</code> 
function writes the data in this format and
the argument it takes is the number of subintervals it divides each cell into,
 i.e. <code>N-1</code>. 
</p>
<p>
This output routine also addresses the problem introduced with discontinuous 
elements, since it takes its data locally from each cell and displays it as a 
patch separately; it
therefore does not use continuity and gnuplot will also plot discontinuities 
if there are any. 
</p>
</blockquote>


<h4>Usage of the gnuplot data format</h4>

<p>
In order to write your data in gnuplot format you need to follow the
steps described in the section on the <a href="#usage">usage of 
<code>DataOut</code></a>. 
The data is written using 
</p>
<ul>
<li>
  <code>void write(ostream &amp;out,"gnuplot_draft")</code> for the lower 
  (draft) quality output.
</li>
<li>
  <code>void write(ostream &amp;out,"gnuplot")</code> for the high quality
  output. 
</li>
</ul>

<h3><a name="eps">Encapsulated Postscript (EPS)</a></h3>

<p>EPS output of <acronym>deal.II</acronym> data consists of the grid
and the cells. The cells can be left empty, printed white (which leads
to hidden-line removal) or colorized using a data vector. This format
does not support gradient shading, i.e. each cell has one color which 
is taken from the value of the data in its centre. Coordinates 
have at most five digits, and the EPS files do not have an explicit 
bounding box, i.e. the bonding box is close to the graphics on  
all four sides. <em>EPS output can only be used for two-dimensional
data.</em>
</p>

<p>EPS otput is performed by calling <br>
<code>void DataOut&lt;dim&gt;::write_eps(ostream &amp;out)</code>
</p>


<h3><a name="pov">PoVRay output</a></h3>

<p>
PoVRay is a most comprehensive raytracer freely available at 
<a href="http://www.povray.org">http://www.povray.org</a>. 
This is also the place to start looking for more information
on its features.
</p>

<p>PoVRay output is accomplished by calling<br>
<code>DataOut&lt;dim&gt;::write_povray(ostream &amp;out)</code><br>
At present there is no more information available on PoVRay output
in <acronym>deal.II</acronym>.
</p>


<h3><a name="gmv">General Mesh Viewer (gmv) output</a></h3>

<p>
The General Mesh Viewer can display data in both 2D, 3D and cuts through
data sets. More information on the gmv is available at
<a href="http://www-xdiv.lanl.gov/XCM/gmv/GMVHome.html">
http://www-xdiv.lanl.gov/XCM/gmv/GMVHome.html</a>
At present the gmv cannot output postscript or EPS data.
</p>

<p>
gmv output is accomplished by calling<br>
<code>void DataOut&lt;dim&gt;::write_gmv(ostream &amp;out)</code><br>
There is no more information available on the output format.
</p>

<hr>
<hr>

<h2><a name="grid_usage">General description of the usage of 
<code>GridOut</code></a></h2>

<p>
What exactly it is you need to do in order to make use of the 
<code>GridOut</code> 
class is described in the table below. Note that data is written to an 
<code>ostream</code>. That means you have to attach your <code>ostream</code>
to a file if you want to use the data later on.
</p>

<p>
There are essentially two ways to use <code>GridOut</code>: If you don't need
to change any of the default parameters (which will be explained along with 
the graphics formats) you can use the class almost as if its methods
were static. There is no need to create a <code>GridOut</code> object
in advance.
</p>

<p>
The second method requires the creation of a <code>GridOut</code> object
to which parameters can be passed. 
</p>

<table>
<caption><b>Usage of the <code>GridOut</code> class with the default parameters</b></caption>
<tr>
  <td><b>Step</b>
  </td>
  <td><b>What to do</b>
  </td>
  <td><b>Function call</b>
  </td>
</tr>
<tr>
  <td>1.</td>
  <td>Use the correct include-file.
  </td>
  <td><code>#include &lt;basic/grid_out.h&gt;</code>
  </td>
</tr>
<tr>
  <td>2.
  </td>
  <td>Generate an <code>ostream</code> (and, normally, attach it to a file).
  </td>
  <td><code>
      ofstream out("filename");
      </code>
  </td>
</tr>
<tr>
  <td>3.
  </td>
  <td>Write your data to the ofstream by calling the appropriate 
      <code>write</code> method giving your triangulation object and
      the output file type as parameters. <code>output_format</code>
      is one of {ucd,gnuplot, eps}.
  </td>
  <td><code>void GridOut().write(const Triangulation&lt;dim&gt; &amp; tria,ostream &amp;out, const OutputFormat output_format)</code><br>	  
  </td>
</tr>
</table>

<table>
<caption><b>Usage of the <code>GridOut</code> class with new parameters</b></caption>
<tr>
  <td><b>Step</b>
  </td>
  <td><b>What to do</b>
  </td>
  <td><b>Function call</b>
  </td>
</tr>
<tr>
  <td>1.</td>
  <td>Use the correct include-files.
  </td>
  <td><code>#include &lt;basic/grid_out.h&gt;</code><br>
      <code>#include &lt;basic/data_out_base.h&gt;</code>
  </td>
</tr>
<tr>
  <td>2.
  </td>
  <td>Generate an <code>ostream</code> (and, normally, attach it to a file).
  </td>
  <td><code>
      ofstream out("filename");
      </code>
  </td>
</tr>
<tr>
  <td>3.
  </td>
  <td>Generate a <code>GridOut&lt;dim&gt;</code> object.
  </td>
  <td><code>GridOut&lt;dim&gt; my_grid_out;</code><br>	  
  </td>
</tr>
<tr>
  <td>4.
  </td>
  <td>Set your parameters (in this example for ucd).
  </td>
  <td><code>UcdFlags ucd_flags;<br> 
      ucd_flags.write_preamble = 1;<br>
      my_grid_out.set_flags(ucd_flags);
      </code>
  </td>
</tr>
<tr>
  <td>5.
  </td>
  <td>Write your data to the ostream by calling the appropriate 
      <code>write</code> method giving your triangulation object and
      the output file type as parameters. <code>output_format</code>
      is one of {ucd,gnuplot, eps}.
  </td>
  <td><code>void my_grid_out.write(const Triangulation&lt;dim&gt; &amp; tria,ostream &amp;out, const OutputFormat output_format)</code><br>	  
  </td>
</tr>
</table>

<hr>

<h2><a name="gridout_formats"><code>GridOut</code> data formats</a></h2>


<h3><a name="grid_ucd">Unstructured Cell Data (ucd)</a></h3>

<p>
The ucd data format is described in the AVS developer's guide. There
are a binary and a ASCII version of this format. <acronym>deal.II</acronym>
uses the ASCII ucd format.
</p>

<p>
The ucd data format is special because it can not only be written but
also read by <acronym>deal.II</acronym>. I.e. you can use a triangulation
written to a ucd-file as a starting triangulation for 
<acronym>deal.II</acronym>. In order to be able to reuse your triangulation
you will need to explicitly write all of your boundary indicators that
are not zero to the output file. Otherwise, upon reloading the triangulation,
all your boundaries will be labelled with the default value, zero.
There is a flag in the class <code>UcdFlags</code>
controlling <code>GridOut</code> with respect to whether
boundary indicators are explicitly written: 
<code>bool UcdFlags::write_preamble</code>. It defaults to true, i.e.
boundary indicators are written by default and you can use the first,
simpler method for writing ucd-files.
</p>

<h3><a name="grid_gnuplot">Gnuplot data format</a></h3>

<p>
Gnuplot output is performed by calling<br>
<code>void write_gnuplot (const Triangulation&lt;dim&gt; &amp;tria, 
ostream &amp;out)  </code><br>
It is controlled by the class <code>GnuplotFlags</code>.
</p>

<p>
In Gnuplot format the boundaries of each cell 
are written as a sequence of lines to your output stream. 
Output can be modified by the following flags:
</p>
<ul>
  <li><code>GnuplotFlags::write_cell_numbers</code>:
	If this is set the (internal) number of each cell is written to the
	output file before the cell data.
  </li>
  <li><code>GnuplotFlags::write_level</code>: If this flag
	is set the refinement level of each cell is written as an
	additional column. This can be used to raise the cells according
	to their refinement level if a 2D-grid is plotted as 3D, or, 
	alternatively, to plot only the cells within a given range of 
	levels of refinement using<br>
	<code>splot [:][:][level1:level2] &quot;filename&quot;</code> 
  </li>
</ul>
<p>
Contrary to, e.g., EPS, you do not need to set a viewpoint. 
</p>

<h3><a name="grid_eps">Encapsulated Postscript</a></h3>

<p>
EPS output is performed using the parameters set forth in the class
<code>EpsFlags</code>. Grid output in the EPS format is always 
two-dimensional; 3D-grids are viewed from a given viewpoint
without hidden-line removal.
EPS output is performed by calling<br>
<code>GridOut::write_eps (Triangulation&amp; tria, ostream&amp; output)</code>
<br>
Alternatively, you can use the general <code>GridOut::write</code> method
as explained in the part on the <a href="#grid_usage">usage of the 
<code>GridOut</code> class</a>.
</p>





<!-- Page Foot -->
<hr>
<table class="navbar">      
<tr>
  <td>
    <a href="toc.html">Back to this chapter's index</a>
  </td>
  <td>
    <a href="../index.html" target="_top">Back to the tutorial index</a>
  </td>
</tr>
</table>
<hr>
<address>
<a href="mailto:schrage@hermes.iwr.uni-heidelberg.de">Jan Schrage</a></address>
<p>
Last modified: $Date$ 
</p>
</body>
</html>
