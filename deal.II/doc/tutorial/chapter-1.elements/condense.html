<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"
   "http://www.w3.org/TR/REC-html40/strict.dtd">
<html>
<head>
<!-- deal.II tutorial template
     Jan Schrage and others <deal@iwr.uni-heidelberg.de> 1999 
-->

<title>deal.II tutorial: Condensing the Hanging Nodes</title>
    <link href="../../screen.css" rel="StyleSheet" title="deal.II Tutorial" media="screen">
    <link href="../../print.css" rel="StyleSheet" title="deal.II Tutorial" media="print">
    <meta name="author" content="Jan Schrage and others <deal@iwr.uni-heidelberg.de>">
    <meta name="keywords" content="deal.II,deal.II tutorial,deal II">
</head>

<!-- Page Body -->
<body lang="en">

<h1>Condensing the Hanging Nodes</h1>

<p>
On locally refined grids you get <a href="hanging_nodes.html">hanging nodes</a>
that need to be integrated into your problem matrix, and before that, into
the <a href="matrix_structure.html">matrix structure</a>. Hanging nodes are
constrained degrees of freedom; these constraints need to be taken into
account when dealing with them. 
</p>
<p>
The <acronym>deal.II</acronym> class 
that has the ability to handle constraint matrices is called 
<a href="../../auto/kdoc/dof/ConstraintMatrix.html"><code>ConstraintMatrix</code></a>. It provides all functions
necessary to condense hanging nodes into a matrix structure. 
You will have to:
<ol>
<li>Clear the hanging nodes so there is no mess left from previous use.
    Clearing them if they are already cleared doesn't hurt. This is
    accomplished with the function <code>void ConstraintMatrix::clear()</code>.
</li>
<li>
Create a global sparsity pattern (as described in the chapter on
<a href="matrix_structure.html">matrix structure</a>) using 
<code>void DoFTools::make_sparsity_pattern(const DoFHandler&lt;dim&gt; &amp;,
                                           SparsityPattern &amp;)</code></a>.
</li>
<li>
Create the constraints on the hanging nodes using 
<code>void DoFHandler::make_constraint_matrix(ConstraintMatrix &amp;)</code>. 
</li>   
<li>Close the constraints matrix using <code>void
ConstraintMatrix::close()</code>. Closing the object performs some
sorting and reshuffling of data (but you need not care about what
actually happens).
This method is needed because you might wish to implement additional constraints
(apart from those for the hanging nodes). This would have to be done before
closing the object; therefore you can't have it closed automatically somewhere.
</li>
<li>Finally, condense the hanging nodes into the matrix structure
using <code>ConstraintMatrix::condense(SparsityPattern &amp;)</code>.
</li>
</ol>

<p class="Example">
<span class="example">Example:</span> We will create a
constraint matrix for hanging nodes and condense the hanging nodes into our matrix structure. Below we show the includes,
definitions and
function calls needed. Be sure to use them in their appropriate places.
</p>
<pre class="example">
<code>
#include &lt;dofs/dof_handler.h&gt;
#include &lt;lac/sparse_matrix.h&gt;
#include &lt;dofs/dof_constraints.h&gt;
#include &lt;dofs/dof_tools.h&gt;

const unsigned int dim=2; // Work in two dimensions, could also be three
SparsityPattern sparsity_pattern;
DoFHandler&lt;dim&gt; dof_handler;
ConstraintMatrix hanging_nodes; 

hanging_nodes.clear();
DoFTools::make_sparsity_pattern(dof_handler, sparsity_pattern);
DoFTools::make_hanging_nodes_constraints(dof_handler, hanging_nodes);
hanging_nodes.close();
hanging_nodes.condense(matrix_structure);
</code>
</pre>

You will later need to condense the matrix itself, and the right hand
side vector, which is done by the following calls:
<pre class="example">
<code>

SparseMatrix<double> system_matrix;
Vector<double>       right_hand_side;

// set up matrix and rhs, possibly apply boundary values, etc
...

// now condense the hanging nodes into the matrix:
hanging_nodes.condense (system_matrix);
hanging_nodes.condense (right_hand_side);
</code>
</pre>


<h3>Generalizations</h3>

The <code>ConstraintMatrix</code> is more general than only for use
with hanging nodes. In fact, it is able to represent general
constraints of the form
<pre class="example">
  Cx = 0
</pre>
where <code>C</code> is a matrix and is represented by an object of
type <code>ConstraintMatrix</code>. Constraints due to hanging nodes
are of this form, since for example using bilinear elements, the
hanging node on the middle of a line equals the mean value of the two
neighboring points, i.e. the entries of the respective row in the
matrix are <code>1, -0.5, -0.5</code>. Since <code>C</code> can be
scaled arbitrarily, we can chose its diagonal elements to be one, and
then only need to store the nondiagonal elements. The
<code>ConstraintMatrix</code> is specialized in storing these
nondiagonal elements if there are only relatively few such elements
per row (as is commonly the case for hanging nodes) and if the number
of constraints itself is relatively low, i.e. much smaller than the
total size of the matrix. In the latter case, most rows of the matrix
contain only zeroes, and we only store those lines that constitute
constraints, which are exactly the lines corresponding to hanging
nodes.

</p>
<p>

Some other constraints can be written in the same form as above, with
a sparse matrix <code>C</code>. In these cases, the
<code>ConstraintMatrix</code> can be used as well. For example, it has
been used to perform computations on two grids at the same time, where
the interpolation between the grids can be represented by some such
matrix. 




<!-- Page Foot -->
<hr>
<table class="navbar">      
<tr>
  <td>
    <a href="solve.html">Next Chapter: Solving the Problem</a>
  </td>
  <td>
    <a href="toc.html">Back to this chapter's index</a>
  </td>
  <td>
    <a href="../index.html" target="_top">Back to the tutorial index</a>
  </td>
</tr>
</table>
<hr>
<address>
<a href="../../mail.html">The deal.II group</a></address>
<p>

</p>
</body>
</html>
