<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"
   "http://www.w3.org/TR/REC-html40/strict.dtd">
<html>
<head>
<title>deal.II tutorial: Creation of a Grid</title>
    <link href="../screen.css" rel="StyleSheet" title="deal.II Tutorial" media="screen">
    <link href="../print.css" rel="StyleSheet" title="deal.II Tutorial" media="print">
    <link href="../audio.css" rel="StyleSheet" title="deal.II Tutorial" media="aural">
    <meta name="author" content="Jan Schrage <schrage@hermes.iwr.uni-heidelberg.de>">
    <meta name="keywords" content="deal.II,deal.II tutorial,deal II">
</head>

<body lang="en">

<h1>Creation of a Grid</h1>

<h2>Different kinds of grids</h2>

<p>
The numerics for which this library was written is always done on a grid. 
Choosing the right kind of grid can be essential for solving your problem.
A grid should be chosen to fit your problem space in the best way possible.
This chapter describes coarse grids for the triangulation of your domain.
</p>
<p>
<acronym>deal.II</acronym> offers various ways to produce grids for
standard domains, such as 
a <a href="#cube">hypercube</a>, a <a href="#ball">hyperball</a> 
and a <a href="#L">hyper_L</a>. There may be more in the meantime (for
example I can now see a ring domain), and you may want to check out
the documentation of the <tt>GridGenerator</tt> class for this.
<p>
Furthermore it is possible to 
<a href="#file">read a triangulation from a <tt>ucd</tt>-file</a> or 
<a href="#program">generate a custom grid from within a program</a>.
</p>
<p>We note before actually going to some code snippets that
a triangulation object must be empty before it is initialized with a
grid. However, you need not fear now, since the library will tell you
if you try to initialize a triangulation which is already initialized;
in general, the library will warn you about almost all errors you do,
since in the debug version there are very many checks.
</p>

<h3><a name="cube">Hypercube</a></h3>

<p>
A hypercube can be created using the function<br>
<code>void GridGenerator::hyper_cube(Triangulation&lt;dim&gt; &amp;tria,const double left=0.,const double right=1.)</code><br>
The cube created is the tensor product of the left and right edges which
default to 0 and 1, creating the unit hypercube. The hypercube will consist of
exactly one cell. In two dimensions, this amounts to a unit square, in
three, to a unit cube. In one dimension, you simply get a line.
</p>

<table class="figure">
<caption class="figure" align="bottom">Hypercubes in two and three dimensions</caption>
<td>
  <img src="../images/Hypercube.gif" alt="Hypercubes" width=536 height=257>
</td>
</table>
	  
<p class="Example">
<span class="example">Example - create the square [-1,-1]x[-1,1]:</span> Below we show the includes,
definitions and
function calls needed. Be sure to use them in their appropriate places.
</p>
<pre class="example">
<code>
#include &lt;grid/tria.h&gt;
#include &lt;grid/grid_generator.h&gt;

const unsigned int dim=2;  // Two dimensions; to create a cube set to dim=3
Triangulation&lt;dim&gt; triangulation;

GridGenerator::hyper_cube (triangulation, -1, 1);
</code>
</pre>


<h3><a name="ball">Hyperball</a></h3>
<p>
A hyperball can be created using the function<br>
<code>void GridGenerator::hyper_ball(Triangulation&lt;dim&gt; &amp;tria,const Point&lt;dim&gt; center=0.,const double radius=1.)</code><br>
This will create a hyperball of given centre and radius where the location of the centre defaults to the origin and the radius to unity.
</p>

<table class="figure">
<caption class="figure" align="bottom">Different levels of refinement for a  2D-Hyperball</caption>
<td>
  <img src="../images/hyperballs.gif" alt="Hyperballs" width=399 height=219>
</td>
</table>

<p class="Example">
<span class="example">Example:</span> Below we show the includes,
definitions and
function calls needed. Be sure to use them in their appropriate places.
This example will create a hyperball with unit radius centred on (1,0).
</p>
<pre class="example">
<code>
#include &lt;grid/tria.h&gt;
#include &lt;grid/grid_generator.h&gt;
#include &lt;base/point.h&gt;

const unsigned int dim=2;  // For example
Triangulation&lt;dim&gt; triangulation;
Point&lt;dim&gt; centre(1,0); // Taking (1,0) as the centre of the ball

GridGenerator::hyper_ball (triangulation, centre, 1);

</code>
</pre>

As can be seen above, the unrefined ball (or circle) does not look
very much like a ball (or circle). After several refinement
steps, it looks much better, though. However, along the rays pointing
outward in the initial grid, the cells ar distorted even in the fine
grid and if you want to do high-accuracy computations on circles, you
may want to use a better coarse grid than the one on the left.


<h3><a name="L">Hyper-L</a></h3>
<p>
A hyper-L can be created using the function<br>
<code>void GridGenerator::hyper_L(Triangulation&lt;dim&gt; &amp;tria,const double left=-1.,const double right=1.)</code><br>
This will create a hyper-L consisting of 2<sup>dimension</sup>-1 cells. 
The hyper-L is created from the hypercube [left,right]<sup>dimension</sup> by taking 
away the hypercube [left+right/2,right]<sup>dimension</sup>. 
</p>
<p>
<span class="parhead">Use of the hyper-L:</span> 
The hyper-L is mainly of use in testing grid refinement, error estimates etc.
Boundary conditions of the form <code>u=g</code> on the faces of the original
hypercube and <code>&part;<sub>n</sub>u=0</code> on the "inner" faces resulting
from the smaller hypercube taken away  are chosen, this will usually lead to
a singular solution because of the reentrant corner; these singularities 
can be used to test the efficiency of error estimators.
</p>

<table class="figure">
<caption class="figure" align="bottom">
Hyper-L in three dimensions (not a good picture, since the proportions
of short and long lines is not exactly one half, but you might get a
clue about it)
</caption>
<td>
  <img src="../images/Hyper-L.gif" alt="Hyper-L" width=348 height=321>
</td>
</table>

<p class="example">
<span class="example">Example:</span> Below we show the includes,
definitions and
function calls needed. Be sure to use them in their appropriate places.
This example will create the default hyper-L.
</p>
<pre class="example">
<code>
#include &lt;grid/tria.h&gt;
#include &lt;grid/grid_generator.h&gt;

const unsigned int dim=2;  // For example
Triangulation&lt;dim&gt; triangulation;

GridGenerator::hyper_L (triangulation, -1, 1);
</code>
</pre>


<h3><a name="file">Reading a grid from a file</a></h3>

<p>In many problems taken from real life you will find those grid types
insufficient and you will need to create your own grid. 
This is possible: <acronym>deal.II</acronym> offers the possibility of
reading a complete triangulation from a file in the <tt>ucd</tt>-format 
used by avs. A <tt>ucd</tt>-file can be read with the function<br> 
<code>void DataIn::read_ucd(istream&)</code><br>
</p>

<p><span class="parhead">
Since the creation of input grids is probably not something you need to do on a
daily basis, we will only very briefly describe the format of the
input file. More information can be found in the documentation of the
<code>GridIn</code> class.
</p>
<p>
Vertex numbering in input files:</span>
The vertex numbering must start at the vertex with the lowest number for lines
and be counterclockwise for quads. Also, faces between adjacent cells
must face in the same direction. This must be ensured by you, or by the
grid construction algorithm. Otherwise some of your matrix elements
may have the wrong sign (plus instead of minus or vice versa).
A more detailed description of the problems
encountered in two dimensions can be found in the
<a href="http://hermes.iwr.uni-heidelberg.de/~deal/doc/auto/kdoc/basic/DataIn.html" target="_top"> <code>DataIn</code> class description</a>.
</p>


<h3><a name="program">Custom grid creation from within a program</a></h3>

<p>
Another way to build cutom grids is to use <acronym>deal.II</acronym> methods
for creating grid cells and their properties. This is done in the order
<ol>
<li>vertices</li>
<li>cells</li>
<li>boundaries</li>
<li>create a triangulation from this information</li>
</ol>
In fact, this is the way the functions in the
<code>GridGenerator</code> class use to produce the grids we have
shown above.
</p>
<p class="example">
<span class="example">Example:</span> Below we show the includes,
definitions and
function calls needed. Be sure to use them in their appropriate places.
This example will create a triangulation as shown in this figure. It will
work only in two dimensions. It creates three rectangular cells, the leftmost 
boundary is a Neumann-boundary.
</p>
<pre class="example">
<code>
// First, create an array holding the (2-dimensional) vertices
const Point&lt;2&gt; vertices[8] = { Point&lt;2&gt; (0,0),               
                                 Point&lt;2&gt; (1,0),               
                                 Point&lt;2&gt; (1,1),
                                 Point&lt;2&gt; (0,1),            
                                 Point&lt;2&gt; (2,0),        
                                 Point&lt;2&gt; (2,1),         
                                 Point&lt;2&gt; (3,0),      
                                 Point&lt;2&gt; (3,1)  };

// Next, create a two-dimensional array holding the information
// on what cell consists of which vertices
const int cell_vertices[3][4] = {{0, 1, 2, 3},      
                                 {1, 4, 5, 2},
                                 {4, 6, 7, 5}};

// Next, create a vector of type CellData&lt;2&gt; that holds the
// cells
vector&lt;CellData&lt;2&gt; &gt; cells (3, CellData&lt;2&gt;());             

// The information on the cells is copied into this vector and the 
// material is set to 0. This index can be used to distinguish cells
// of different types. 
for (unsigned int i=0; i&lt;3; ++i)                                        
  {                                                         
    for (unsigned int j=0; j&lt;4; ++j)        
      cells[i].vertices[j] = cell_vertices[i][j];
    cells[i].material_id = 0;
  };

// The Neumann boundary is set below:
// Boundaries are parts of cells, therefore the class is called SubCellData
// to distinguish them from cell data like vertices and material.
SubCellData boundary_info;                                       

// We want to describe a line in 2d, which would be a cell in 1d,
// which is why we can use the object for a 1d cell
// (CellData&lt;1&gt;) for its description:
boundary_info.boundary_lines.push_back (CellData&lt;1&gt;());

// The boundary gets a material id of 1. The boundary id of lines in 2d
// will be interpreted as the boundary id
boundary_info.boundary_lines[0].material_id = 1;

// The boundary is between vertices number 0 and 3
boundary_info.boundary_lines[0].vertices[0] = 0; 
boundary_info.boundary_lines[0].vertices[1] = 3;

// From this information the triangulation is created 
coarse_grid-&gt;create_triangulation (vector&lt;Point&lt;2&gt; &gt;(&vertices[0],
                                                       &vertices[8]),
                                      cells, boundary_info);
</code>
</pre>


<hr>

<table class="navbar" >      
<tr>
  <td>
    <a href="dofs.html">Next chapter: Degrees of Freedom</a>
  </td>
  <td>
    <a href="toc.html">Back to this chapter's index</a>
  </td>
  <td>
    <a href="../index.html" target="_top">Back to the tutorial index</a>
  </td>
</tr>
</table>
<hr>
<address>
<a href="mailto:schrage@hermes.iwr.uni-heidelberg.de">Jan Schrage</a></address>
<p>
Last modified: $Date$
</p>
</body>
</html>

