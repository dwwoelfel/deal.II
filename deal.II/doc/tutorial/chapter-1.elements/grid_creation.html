<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"
   "http://www.w3.org/TR/REC-html40/strict.dtd">
<html>
<head>
<title>Creation of a Grid</title>
    <link href="../dealtut.css" rel="StyleSheet" title="deal.II Tutorial">
    <meta name="author" content="Jan Schrage <schrage@gaia.iwr.uni-heidelberg.de>">
    <meta name="keywords" content="deal.II,deal.II tutorial,deal II">
</head>

<body lang="en">

<h1>Creation of a Grid</h1>

<h2>Different kinds of grids</h2>

<p>
All numerics are done on a grid. 
Choosing the right kind of grid can be essential for solving your problem.
A grid should be chosen to fit your problem space in the best way possible.
This chapter describes coarse grids for the triangulation of your domain.
</p>

<p>
<acronym>deal.II</acronym> offers three fundamental grid types: 
a <a href="#cube">hypercube</a>, a <a href="#ball">hyperball</a> 
and a <a href="#L">hyper_L</a>. Furthermore it is possible to 
<a href="#file">read a triangulation from a <tt>ucd</tt>-file</a>. 
</p>

<h3><a name="cube">Hypercube</a></h3>

<p>
A hypercube can be created using the function<br>
<code>void Triangulation::create_hypercube(const double left=0.,const double right=1.)</code><br>
The cube created is the tensor product of the left and right edges which
default to 0 and 1, creating the unit hypercube. The hypercube will consist of
exactly one cell. In two dimensions, this amounts to a unit square, in three, to a unit cube.  
</p>

<table class="figure">
<caption class="figure" align="bottom">Hypercubes in two and three dimensions</caption>
<td>
  <img src="../images/Hypercube.gif" alt="Hypercubes" width=536 height=257>
</td>
</table>
	  
<p class="Example">
<span class="example">Example - create the square [-1,-1]x[-1,1]:</span> Below we show the includes,
definitions and
function calls needed. Be sure to use them in their appropriate places.
</p>
<pre class="example">
<code>
#include &lt;grid/tria.h&gt;

const unsigned int dim=2;  // Two dimensions; to create a cube set to three
Triangulation&lt;dim&gt; tr;

tr.create_hypercube(-1,1);
</code>
</pre>


<h3><a name="ball">Hyperball</a></h3>
<p>
A hyperball can be created using the function<br>
<code>void Triangulation::create_hyper_ball(const Point&lt;dim&gt; center=0.,const double radius=1.)</code><br>
This will create a hyperball of given centre and radius where the location of the centre defaults to the origin and the radius to unity.
</p>

<table class="figure">
<caption class="figure" align="bottom">Different levels of refinement for a  2D-Hyperball</caption>
<td>
  <img src="../images/hyperballs.gif" alt="Hyperballs" width=399 height=219>
</td>
</table>

<p class="Example">
<span class="example">Example:</span> Below we show the includes,
definitions and
function calls needed. Be sure to use them in their appropriate places.
This example will create a hyperball with unit radius centred on (1,0).
</p>
<pre class="example">
<code>
#include &lt;grid/tria.h&gt;
#include &lt;base/point.h&gt;

const unsigned int dim=2;  // For example
Triangulation&lt;dim&gt; tr;
Point&lt;dim&gt; centre(1,0); // Taking (1,0) as the centre of the ball

tr.create_hyperball(centre,1);

</code>
</pre>


<h3><a name="L">Hyper-L</a></h3>
<p>
A hyper-L can be created using the function<br>
<code>void Triangulation::create_hyper_L(const double left=-1.,const double right=1.)</code><br>
This will create a hyper-L consisting of 2<sup>dimension</sup>-1 cells. 
The hyper-L is created from the hypercube [left,right]<sup>dimension</sup> by taking 
away the hypercube [left+right/2,right]<sup>dimension</sup>. 
</p>
<p>
<span class="parhead">Use of the hyper-L:</span> 
The hyper-L is mainly of use in testing grid refinement, error estimates etc.
Boundary conditions of the form <code>u=g</code> on the faces of the original
hypercube and <code>&part;<sub>n</sub>u=0</code> on the "inner" faces resulting
from the smaller hypercube taken away  are chosen, this will usually lead to
a singular solution because of the reentrant corner; these singularities 
can be used to test the efficiency of error estimators.
</p>

<table class="figure">
<caption class="figure" align="bottom">Hyper-L in three dimensions</caption>
<td>
  <img src="../images/Hyper-L.gif" alt="Hyper-L" width=348 height=321>
</td>
</table>

<p class="example">
<span class="example">Example:</span> Below we show the includes,
definitions and
function calls needed. Be sure to use them in their appropriate places.
This example will create the default hyper-L.
</p>
<pre class="example">
<code>
#include &lt;grid/tria.h&gt;

const unsigned int dim=2;  // For example
Triangulation&lt;dim&gt; tr;

tr.create_hyper_L(-1,1);
</code>
</pre>


<h3><a name="file">Reading a grid from a file</a></h3>

<p>In many problems taken from real life you will find those grid types
insufficient and you will need to create your own grid. Fortunately,
this is possible. <acronym>deal.II</acronym> offers the possibility of
reading a complete triangulation from a file in the <tt>ucd</tt>-format 
used by avs. A <tt>ucd</tt>-file can be read with the function<br> 
<code>void DataIn::read_ucd(istream&)</code><br>
</p>

<p><span class="parhead">Vertex numbering in input files:</span>
The vertex numbering must start at the vertex with the lowest number for lines
and be counterclockwise for quads. Also, faces between adjacent cells
must face in the same direction. This must be ensured by you, or by the
grid construction algorithm. Otherwise some of your matrix elements
may have the wrong sign (plus instead of minus or vice versa).
A more detailed description of the problems
encountered in two dimensions can be found in the
<a href="http://gaia.iwr.uni-heidelberg.de/~deal/doc/auto/kdoc/basic/DataIn.html" target="_top"> <code>DataIn</code> class description</a>.
</p>


<h3><a name="program">Custom grid creation from within a program</a></h3>

<p>
Another way to build cutom grids is to use <acronym>deal.II</acronym> methods
for creating grid cells and their properties. This is done in the order
<ol>
<li>vertices</li>
<li>cells</li>
<li>boundaries</li>
<li>create a triangulation from this information</li>
</ol>
You first create the vertices, then create cells by assigning vertices
to them, then you set the boundary conditions. Last you use this information
to create a triangulation. This is probably best illustrated by an example.
<p class="example">
<span class="example">Example:</span> Below we show the includes,
definitions and
function calls needed. Be sure to use them in their appropriate places.
This example will create a triangulation as shown in this figure. It will
work only in two dimensions. It creates three rectangular cells, the leftmost 
boundary is a Neumann-boundary.
</p>
<pre class="example">
<code>
// First, create an array holding the (2-dimensional) vertices
const Point&lt;2&gt; vertices[8] = { Point&lt;2&gt; (0,0),               
                                 Point&lt;2&gt; (1,0),               
                                 Point&lt;2&gt; (1,1),
                                 Point&lt;2&gt; (0,1),            
                                 Point&lt;2&gt; (2,0),        
                                 Point&lt;2&gt; (2,1),         
                                 Point&lt;2&gt; (3,0),      
                                 Point&lt;2&gt; (3,1)  };

// Next, create a two-dimensional array holding the information
// on what cell consists of which vertices
const int cell_vertices[3][4] = {{0, 1, 2, 3},      
                                 {1, 4, 5, 2},
                                 {4, 6, 7, 5}};

// Next, create a vector of type CellData&lt;2&gt; that holds the
// cells
vector&lt;CellData&lt;2&gt; &gt; cells (3, CellData&lt;2&gt;());             

// The information on the cells is copied into this vector and the 
// material is set to 0. This index can be used to distinguish cells
// of different types. 
for (unsigned int i=0; i&lt;3; ++i)                                        
  {                                                         
    for (unsigned int j=0; j&lt;4; ++j)        
      cells[i].vertices[j] = cell_vertices[i][j];
    cells[i].material_id = 0;
  };

// The Neumann boundary is set below:
// Boundaries are parts of cells, therefore the class is called SubCellData
// to distinguish them from cell data like vertices and material.
SubCellData boundary_info;                                       

// We are using a boundary of cell number 1
boundary_info.boundary_lines.push_back (CellData&lt;1&gt;());

// The boundary gets a material id of 
boundary_info.boundary_lines.back().material_id = 1;

// The boundary is between vertices number 1 and 3
boundary_info.boundary_lines[0].vertices[0] = 0; 
boundary_info.boundary_lines[0].vertices[1] = 3;

// From this information the triangulation is created 
coarse_grid-&gt;create_triangulation (vector&lt;Point&lt;2&gt; &gt;(&vertices[0],
                                                       &vertices[8]),
                                                       cells, boundary_info);
</code>
</pre>


<hr>

<table class="navbar" >      
<tr>
  <td>
    <a href="dofs.html">Next chapter: Degrees of Freedom</a>
  </td>
  <td>
    <a href="toc.html">Back to this chapter's index</a>
  </td>
  <td>
    <a href="../index.html" target="_top">Back to the tutorial index</a>
  </td>
</tr>
</table>
<hr>
<address>
<a href="mailto:schrage@gaia.iwr.uni-heidelberg.de">Jan Schrage</a></address>
<p>
Last modified: $Date$
</p>
</body>
</html>

