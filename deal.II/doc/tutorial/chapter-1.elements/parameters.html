<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"
   "http://www.w3.org/TR/REC-html40/strict.dtd">
<html>
<head>
<!-- deal.II tutorial template
     Jan Schrage and others <deal@iwr.uni-heidelberg.de> 1999 
-->

<title>deal.II tutorial: Parameter Input</title>
    <link href="../../screen.css" rel="StyleSheet" title="deal.II Tutorial" media="screen">
    <link href="../../print.css" rel="StyleSheet" title="deal.II Tutorial" media="print">
    <meta name="author" content="Jan Schrage and others <deal@iwr.uni-heidelberg.de>">
    <meta name="keywords" content="deal.II,deal.II tutorial,deal II">
</head>

<!-- Page Body -->
<body lang="en">

<h1>Parameter Input</h1>

<p>
When writing a numerical program you will usually wish to keep it flexible
with regard to parameter settings and the like. Rewriting a program 
every time a parameter changes is ever so annoying.
For this reason <acronym>deal.II</acronym> provides a class 
called <code>ParameterHandler</code>. This class enables you to easily
parse a parameter file and extract the values of the parameters.
The names and allowed values of the parameters can be defined by you.
</p>

<h2>Introducing parameters into your code</h2>

<h3>Introduction - the most simple case</h3>
<p>
The most simple way to using runtime parameters in your program is the following:
</p>

<table>
<caption><b>Using runtime parameters</b></caption>
<tr>
  <td><b>Step</b>
  </td>
  <td><b>What to do</b>
  </td>
  <td><b>Function call</b>
  </td>
</tr>
<tr>
  <td>1.</td>
  <td>Use the correct include-file.
  </td>
  <td><code>#include &lt;base/parameter_handler.h&gt;</code>
  </td>
</tr>
<tr>
  <td>2.</td>
  <td>Declare a parameter handler object.
  </td>
  <td><code>ParameterHandler prm;</code>
  </td>
</tr>
<tr>
  <td>3.</td>
  <td>Tell the parameter handler about the parameters, their types and their 
	  default values. Here we get one parameter called 
	  &quot;My favourite booze&quot;, its default value is 
	  &quot;Stout&quot; and we allow anything as its value. Note that
	  the parameter name may contain whitespace.
  </td>
  <td><code>prm.declare_entry(&quot;My favourite booze&quot;,
	  &quot;Stout&quot;,Patterns::Anything());
      </code>
  </td>
</tr>
<tr>
  <td>4.</td>
  <td>Generate a parameter file. Following the example above, we
	  set &quot;My favourite booze&quot; to &quot;Ale&quot;. This
	  file will be called &quot;parameters.in&quot;.
  </td>
  <td><code>set My favourite booze = Ale</code>
  </td>
</tr>
<tr>
  <td>5.</td>
  <td>Read the parameters from the file.
  </td>
  <td><code>prm.read_input(&quot;parameters.in&quot;);</code>
  </td>
</tr>
<tr>
  <td>6.</td>
  <td>Find the values of your parameters.
  </td>
  <td><code>string booze = prm.get(&quot;My favourite booze&quot;);</code>
  </td>
</tr>
</table>

<p>
The few steps outlined above are indeed the most simple case. What, now, if 
you have a more complex set of parameters, grouped by purpose ? You could,
for example, wish to solve different equations and set parameters for each
of them. For this purpose you can introduce <em>subsections</em> into
your parameter set.
</p>

<h3>Subsections</h3>

<p>
Parameters declared in different subsections are distinct, although they
may share the same name. Let us stay with the example of two equations
for which you wish to set parameters: <code>Zeldovich-equation</code> and 
<code>Sunyaev-equation</code>. You want to be able to use different solvers,
and thus both take a parameter called <code>Solver</code>.
The way to go is to declare two subsections called (preferably)
<code>Zeldovich-equation</code> and <code>Sunyaev-equation</code>. Each of the two
subsections contains a parameter called <code>Solver</code>.
</p>

<p class=example>
<span class=example>Example:</span>
We declare subsections for two equations called 
Zeldovich-equation and Sunyaev-equation
within a parameter handler.
The allowed values for the parameter <code>Solver</code> are 
<code>CG</code> (default) and <code>GMRES</code>. Afterwards
we read the settings from a file called &quot;parameters.in&quot;
and retrieve their values. The values are stored in the strings
<code>zeldovich_solver</code> and <code>sunyaev_solver</code>.
Please note that in order to stick to the essentials this example 
violates the 
<a href="http://gaia.iwr.uni-heidelberg.de/~deal/doc/auto/kdoc/base/ParameterHandler.html">
recommended style for parameter declaration</a>.
</p>

<pre class="example"> 
<code>
// We declare a parameter handler

ParameterHandler prm;

// We declare the first subsection and its entry

prm.enter_subsection(&quot;Zeldovich-equation&quot;)
prm.declare_entry(&quot;Solver&quot;,&quot;CG&quot;,Patterns::Sequence(&quot;CG|GMRES&quot;));
prm.leave_subsection();

// We declare the second subsection and its entry

prm.enter_subsection(&quot;Sunyaev-equation&quot;)
prm.declare_entry(&quot;Solver&quot;,&quot;CG&quot;,Patterns::Sequence(&quot;CG|GMRES&quot;));
prm.leave_subsection();

// The input file is read

prm.read_input(&quot;parameters.in&quot;

// We retrieve the parameters from the first subsection

prm.enter_subsection(&quot;Zeldovich-equation&quot;)
string zeldovich_solver = prm.get(&quot;Solver&quot;);
prm.leave_subsection();

// We retrieve the parameters from the second subsection

prm.enter_subsection(&quot;Sunyaev-equation&quot;)
string sunyaev_solver = prm.get(&quot;Solver&quot;);
prm.leave_subsection();
</code>
</pre>

<p class="example">We continue this example with a sample parameter
file that tells the code to solve the Zeldovich equation using GMRES
and the Sunyaev equation using CG.
</p>

<pre class="example">
<code>
subsection Zeldovich-equation
  set Solver = GMRES
end

subsection Sunyaev-equation
  set Solver = CG
end
</code>
</pre>

<p>
There are, as we have seen, two methods within the 
<code>ParameterHandler</code> class handling subsections:<br>
<code>
void ParameterHandler::enter_subsection(const string &amp;subsection)
</code><br>
and<br>
<code>
bool ParameterHandler::leave_subsection()
</code><br>
Their names are telling. First you enter a subsection, then you declare
(or retrieve)
all the parameters for this subsection and finally you leave it.
Subsections may be nested, i.e. you are at liberty to declare
subsections within subsections within subsections... 
</p>

<h3>Parameter types</h3>

<p>
The parameter handler allows you to specify that any parameter
be of a distinct type. 
Upon reading a file the value of this
parameter is checked against the type and an exception is thrown
if they do not match. An exception is also thrown if the default
parameter does not match the specified type.
Below we show a list of the types available. The first column
gives an explanation, the second lists the corresponding C++ type
and the third column shows how to use this type in <acronym>deal.II</acronym>.
<em>Parameter values may not contain linebreaks.</em>
<acronym>deal.II</acronym> always gets passed a pointer to a class
handling that type. Those classes are defined in a structure
called <code>Patterns</code>. The include file to be used is the 
same as for the <code>ParameterHandler</code> class. 
</p>

<table>
<caption><b>Parameter types</b></caption>
<tr>
  <td><b>Type</b>
  </td>
  <td><b>Correspondig C++ type</b>
  </td>
  <td><b>deal.II type</b>
  </td>
</tr>
<tr>
  <td>Integer number.</td>
  <td><code>int</code>
  </td>
  <td><code>Patterns::Integer()</code>
  </td>
</tr>
<tr>
  <td>Floating point number of double length.</td>
  <td><code>double</code>
  </td>
  <td><code>Patterns::Double()</code>
  </td>
</tr>
<tr>
  <td>One member of a set.</td>
  <td><code>enum</code>
  </td>
  <td><code>Patterns::Sequence("element 1|element 2|...")</code>
  </td>
</tr>
<tr>
  <td>An arbitrary string.</td>
  <td><code>string</code>
  </td>
  <td><code>Patterns::Anything()</code>
  </td>
</tr>
</table>


<h3>Allowed characters</h3>

<p>
Neither the names nor the values of entries may contain the
following characters:<br>
<tt>\ { } | </tt><br>
</p>

<p>
Besides, entries may not contain linebreaks, i.e. entries may not span
multiple lines.
</p>

<p>
Leading and trailing whitespace is ignored and multiple whitespace is
condensed into one. Entry or subsection
declarations within your code should therefore 
not contain multiple whitespace, which will not be recognized.
</p>

<h3>Different input sources</h3>

<p>
You can obtain data from three different kinds of source:
</p>
<ul>
  <li>an <code>istream</code></li>
  <li>a file</li>
  <li>a string</li>
</ul>

<p>
It is possible to use different sources successively. Parameters
that are entered more than once will be overwritten, i.e. the
value encountered last of the parameter in question is used. 
</p>

<p class="Example">
<span class="example">Example:</span>
We read parameters successively
from three different sources. This example was taken from
the <a href="http://gaia.iwr.uni-heidelberg.de/~deal/doc/auto/kdoc/base/ParameterHandler.html"><code>ParameterHandler</code> class documentation</a>.
</p>

<pre class="example">
<code>
ParameterHandler prm;
...
// declaration of entries
...
prm.read_input (cin);         // read input from standard in,
// or
prm.read_input (&quot;simulation.in&quot;);
// or
char *in = &quot;set Time step size = 0.3 \n ...&quot;;
prm.read_input (in);
...
</code>
</pre>

<h3>Parameter output</h3>

<p>
You can, for example for logging purposes, write all the parameters
your code knows about to an <code>ostream</code> in a given format.
The formats supported at present are text and LaTeX.
The method handling this is called: <br>
<code>
ostream &amp; ParameterHandler::print_parameters(ostream &amp;out, const OutputStyle style) 
</code><br>
</p>

<p>
You can also write the parameters of a single subsection to an
<code>ostream</code> using<br>
<code>
void ParameterHandler::print_parameters_section (ostream &amp;out,
                                   const OutputStyle style,
                                   const unsigned int indent_level);
</code>
</p>

<p>
In both cases <code>out</code> is the <code>ostream</code> 
the parameters are written to, <code>style</code> is 
the output format, either 
<tt>text</tt> or <tt>LaTeX</tt>. In the case of subsections 
the <code>indent_level</code> is the level of indentation.
</p>

<!-- Page Foot -->
<hr>
<table class="navbar">      
<tr>
<!-- This is the last chapter.
  <td>
    <a href="output.html">Next Chapter: Grid and Data Output</a>
  </td>
-->
  <td>
    <a href="toc.html">Back to this chapter's index</a>
  </td>
  <td>
    <a href="../index.html" target="_top">Back to the tutorial index</a>
  </td>
</tr>
</table>
<hr>
<address>
<a href="mailto:deal@iwr.uni-heidelberg.de">The deal.II group</a></address>
<p>
Last modified: $Date$ 
</p>
</body>
</html>
