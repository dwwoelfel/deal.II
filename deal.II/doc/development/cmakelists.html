<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	  "http://www.w3.org/TR/html4/loose.dtd">
<html>
  <head>
    <title>How to use CMake to configure your projects with deal.II</title>
    <link href="../screen.css" rel="StyleSheet">
    <meta name="author" content="the deal.II authors <authors @ dealii.org>">
    <meta name="copyright" content="Copyright (C) 2012, 2013 by the deal.II authors">
    <meta name="date" content="$Date$">
    <meta name="svn_id" content="$Id$">
    <meta name="keywords" content="deal.II">
  </head>

<body>
<h1>How to use CMake to configure your projects with <acronym>deal.II</acronym></h1>

<div class="toc">
  <ol>
    <li><a href="#cmakesimple">Simple <code>CMakeLists.txt</code></a>
      <ol>
	<li><a href="#cmakesimple.multiple">Adding multiple executable targets</a></li>
	<li><a href="#cmakesimple.libs">Adding libraries and common source files</a></li>
	<li><a href="#cmakesimple.build_type">Switching build types</a></li>
	<li><a href="#cmakesimple.run">Adding a "run" target</a></li>
      </ol>
    </li>
    <li><a href="#cmakeadvanced">Advanced <code>CMakeLists.txt</code></a>
      <ol>
	<li> TODO, see list</li>
      </ol>
    </li>
    <li><a href="#cmakeauto">Autopilot style <code>CMakeLists.txt</code></li>
    <li><a href="#dealiiconfig"><code>deal.IIConfig.cmake</code></a></li>
    <li><a href="#legacy">Legacy <code>Make.global_options</code></a></li>
  </ol>
</div>

<p>
  <code>cmake</code> is the configuration and build tool we use
  in <acronym>deal.II</acronym>. Its advantage is not only that it makes
  configuration of <acronym>deal.II</acronym> itself simpler across
  platforms (compared to the older <code>autoconf/make</code> combination)
  but also that it <i>exports</i> information about the deal.II
  configuration that makes it particularly simple for projects
  using <acronym>deal.II</acronym> to configure and link against it.
</p>

<p>
  <code>cmake</code> is controlled by input files that by convention are
  called <code>CMakeLists.txt</code>, listing both configuration commands
  as well as dependencies between source files and targets.
  This page presents some <code>CMakeLists.txt</code> examples for
  potential use in your projects. (A detailed description of the
  <acronym>deal.II</acronym> project configuration is given in the
  <a href="cmake.html" target="body">deal.II CMake ReadMe</a>.)
</p>

<a name="cmakesimple"></a>
<h2>Simple CMakeLists.txt</h2>

<p>
  In this section, we start out with a minimal <code>CMakeLists.txt</code>
  based on the <code>DEAL_II_SETUP_TARGET</code> macro. This method gives
  full control of what's happening and is easily extensible to more complex
  projects, as exemplified in the subsections here and later in the section
  on <a href="cmakeadvanced">advanced topics</a>. Here is a full example
  (<a href="CMakeLists.txt.sample3" target="_top">plain text</a>
  version):

<p class="todo"> Fix plain text after finalizing!</p>

<pre class="cmake">
CMAKE_MINIMUM_REQUIRED(VERSION 2.8.8)

FIND_PACKAGE(deal.II 8.0 REQUIRED
  HINTS ${DEAL_II_DIR} ../ ../../ $ENV{DEAL_II_DIR}
  )
DEAL_II_INITIALIZE_CACHED_VARIABLES()

PROJECT(myproject)

ADD_EXECUTABLE(mycode mycode.cc)
DEAL_II_SETUP_TARGET(mycode)
</pre>

<p>
  The first line of this code makes sure that a sufficiently high
  version of CMake is installed. 2.8.8 is the minimal version required
  to set up <acronym>deal.II</acronym>, therefore it is safe to use this
  number here.
</p>

<p>
  Next, we find our deal.II installation with the help of the
  <code>FIND_PACKAGE</code> command. In this case requiring at least
  version 8.0, which is the first version using CMake. The
  <code>HINTS</code> are a list of directories where the install directory
  of deal.II is likely to be found. First, the location possibly defined in
  the CMake variable <code>DEAL_II_DIR</code> is considered. After that, we
  check whether we are in a subdirectory (first and second level) of the
  deal.II installation and otherwise use the environment variable
  <code>DEAL_II_DIR</code>. If all of these hints fail the default system
  locations <code>/usr/</code> and <code>/usr/local/</code> are considered.
  The list after <code>HINTS</code> can be changed according to your
  preferences.
</p>

<p>
  After finding the deal.II project, we fetch a set of cached variables
  with the <code>DEAL_II_INITIALIZE_CACHED_VARIABLES()</code> macro. You
  can inspect these for instance with <code>ccmake</code>.
</p>

<p class="todo"> link to detailed explanation of the macro below</p>

<p>
  Every <code>CMakeLists.txt</code> must contain a project definition,
  which we do next.
</p>

<p>
  Finally, the last two lines define the executable that is to be
  produced and its source code. The <code>DEAL_II_SETUP_TARGET</code> macro
  will set up necessary incllude directories, compile defintions and the
  link interface.
</p>


<p class="todo"> link to detailed explanation of the macro below</p>

<a name="cmakesimple.multiple"></a>
<h3>Adding multiple executable targets</h3>

<p>
  In order to specify multiple executable targets, simply repeat
  the last two lines of the simple <code>CMakeLists.txt</code>:
</p>

<pre class="cmake">
ADD_EXECUTABLE(mycode2 mycode2.cc)
DEAL_II_SETUP_TARGET(mycode2)

ADD_EXECUTABLE(mycode3 mycode3.cc)
DEAL_II_SETUP_TARGET(mycode3)
</pre>

If the list gets longer, consider using
a <a href="#cmakeadvanced.foreach">loop</a>, possibly
with <a href="#cmakeadvanced.glob">GLOB</a>.

    <a name="cmakesimple.libs"></a>
    <h3>Adding libraries and common source files</h3>

    <p>
      Adding a library is as simple as adding an executable target. We
      specify the library name and then have to tell cmake that the
      executables depend on it. The code in the simple file below the
      project definition accordingly changes for instance to:
    </p>

<pre class="cmake">
ADD_LIBRARY(mylib libsrc1.cc libsrc2.cc libsrc3.cc)
DEAL_II_SETUP_TARGET(mylib)

ADD_EXECUTABLE(mycode mycode.cc)
DEAL_II_SETUP_TARGET(mycode)
TARGET_LINK_LIBRARIES(mycode mylib)
</pre>

<p>When you have <a href="#cmakesimple.multiple">multiple targets</a>,
repeat the last line of code for each of them. Accordingly,
a <a href="#cmakeadvanced.foreach">loop</a> becomes even more
attractive.</p>

<p>If you only have a single file or few files with common source
code, an alternative to creating a library might be the option:</p>

<pre class="cmake">
ADD_EXECUTABLE(mycode mycode.cc common.cc)
DEAL_II_SETUP_TARGET(mycode)

ADD_EXECUTABLE(mycode2 mycode2.cc common.cc)
DEAL_II_SETUP_TARGET(mycode2)
</pre>

<p>You should be aware though that in this case <code>common.cc</code> will
be compiled for each target, not only once. If you want to avoid this and
still don't want to use a shared library or static archive, another option
is to create an <code>OBJECT</code> "library":</p>

<pre class="cmake">
ADD_LIBRARY(common OBJECT common.cc)
DEAL_II_SETUP_TARGET(common)

ADD_EXECUTABLE(mycode mycode.cc $&lt;TARGET_OBJECTS:common&gt;)
DEAL_II_SETUP_TARGET(mycode)

ADD_EXECUTABLE(mycode2 mycode2.cc $&lt;TARGET_OBJECTS:common&gt;)
DEAL_II_SETUP_TARGET(mycode2)
</pre>
This will compile <code>common.cc</code> once for the object target
<code>common</code> and link the resulting object file into the two
executables.

<a name="cmakesimple.build_type"></a>
<h3>Switching build types</h3>

<p> The build type is controlled via the variable
<code>CMAKE_BUILD_TYPE</code>. If it is set to <code>Debug</code>
executables and libraries specified in your <code>CMakeLists.txt</code>
file will be compiled in debug mode and linked against the debug version of
the deal.II library. Contrary <code>Release</code> will build in optimized
mode and link against the optimized release version of deal.II. You can set
<code>CMAKE_BUILD_TYPE</code> with the help of <code>ccmake</code> or via
<code>cmake</code> on the command line: </p>

<pre class="cmake">
$ cmake -DCMAKE_BUILD_TYPE="Debug" .

$ cmake -DCMAKE_BUILD_TYPE="Release" .
</pre>

Alternatively, you can specify custom targets to switch the build type and
compile automatically:

<pre class="cmake">
ADD_CUSTOM_TARGET(debug
  COMMAND ${CMAKE_COMMAND} -DCMAKE_BUILD_TYPE=Debug ${CMAKE_SOURCE_DIR}
  COMMAND ${CMAKE_COMMAND} --build ${CMAKE_BINARY_DIR} --target all
  COMMENT "Switch CMAKE_BUILD_TYPE to Debug"
  )

ADD_CUSTOM_TARGET(release
  COMMAND ${CMAKE_COMMAND} -DCMAKE_BUILD_TYPE=Release ${CMAKE_SOURCE_DIR}
  COMMAND ${CMAKE_COMMAND} --build ${CMAKE_BINARY_DIR} --target all
  COMMENT "Switch CMAKE_BUILD_TYPE to Release"
  )
</pre>
With that, switching the build type and compiling the project can be done
very conveniently via:
<pre class="cmake">
$ make debug

$ make release
</pre>

<a name="cmakesimple.run"></a>
<h3>Adding a "run" target</h3>

<p> If you wish to have a "run" target for make, like in the deal.II
tutorial, specify one this way (obviously, a single "run" target can only
run a single executable): </p>

<pre class="cmake">
ADD_CUSTOM_TARGET(run COMMAND mycode
  COMMENT "Run with ${CMAKE_BUILD_TYPE} configuration"
  )
</pre>


<a name="cmakeadvanced"></a>
<h2> Advanced <code>CMakeLists.txt</code></h2>

<p class="todo">This section covers some advanced topics for a user
<code>CMakeLIists.txt</code> file.</p>

<a name="cmakeadvanced.control"></a>
<h3>Control statements</h3>

<p>Control statements in CMake take the following form:
<pre class="cmake">
IF(&lt;expression&gt;)
  ...
ENDIF()
</pre>
or in long form:
<pre class="cmake">
IF(&lt;expression1&gt;)
  ...
ELSEIF(&lt;expression2&gt;)
  ...
ELSE()
  ...
ENDIF()
</pre>
Please note the (somehow uncommon) empty, opening and closing brackets
behind <code>ELSE()</code> and <code>ENDIF()</code>.
<code>&lt;expression&gt;</code> can take a multitude of different forms,
have a look at the
<a href="http://cmake.org/cmake/help/v2.8.8/cmake.html">CMake
documentation</a> for a complete list. Important examples are:
<p class="todo">Link!</p>
<pre class="cmake">
IF(${variable})
  - the body will be evaluated if the variable "variable" is defined and
    synonymous to true, e.g. 1, TRUE, ON, YES (modulo case insensitivity)

IF(variable MATCHES &lt;regular expression&gt;)
  - the body will be evaluated if the variable "variable" is defined and
    matches the specified regular expression

IF("${variable}" STREQUAL "foobar")
  - the body will be evaluated if both strings are equal. Note that
    "${variable}" will be replaced by the content of the (string)
    variable "variable"
</pre>
<p>An expression can be negated by prefixing <code>NOT</code>:</p>
<pre class="cmake">
IF(NOT &lt;expression&gt;)
  ...
ENDIF()
</pre>

<p>Loops are implemented with the help of <code>WHILE</code> and
<code>FOR</code> statements. The former takes the same
<code>&lt;expression&gt;</code> as the <code>IF</code> statement:</p>
<pre class="cmake">
WHILE(&lt;expression&gt;)
  ...
ENDWHILE()
</pre>
Given a variable <code>list</code> containing a list, the individual
elements <code>element</code> can be accessed with a <code>FOREACH</code>
statement:
<pre class="cmake">
FOREACH(element ${list})
  ...
ENDFOREACH
</pre>
Note: It is also possible to specify the list directly:
<pre class="cmake">
FOREACH(element foo bar baz)
  # The variable element will iterate through foo, bar and baz.
ENDFOREACH
</pre>


<a name="cmakeadvanced.globs"></a>
<h3>File globs</h3>

<p>A very common task is to pick up a list of source files from a
directory. You can either manage a list of source files in
<code>CMakeLists.txt</code> by hand, e.g. by manually updating all source
files for a given target, or you can use a glob to automate this process.
The following example will pick up every source file under
<code>SOURCE_DIR/sources/</code> and add it to an executable:</p>

<pre class="cmake">
FILE(GLOB sources ${CMAKE_SOURCE_DIR}/source/*.cc)
ADD_EXECUTABLE(mycode ${sources})
</pre>

<p>Please be aware of one caveat of this approach: Due to the fact that
CMake is a <i>build system generator</i> the resulting build configuration
(for make) has no way to detect whether a new source file was added (or
removed) and that it has to call back to cmake. So, after adding a new
source file you have to touch a <code>CMakeLists.txt</code> file or to run
<code>cmake .</code> again by hand.


<a name="cmakeadvanced.setup_target"></a>
<h3><code>DEAL_II_SETUP_TARGET</code> revisited</h3>

<p class="todo"> Well, write this! </p>


<a name="cmakeadvanced.cached_variables"></a>
<h3><code>DEAL_II_INITIALIZE_CACHED_VARIABLES</code> revisited</h3>

<p class="todo"> Well, write this! </p>


<a name="cmakeadvanced.properties"></a>
<h3>Customizing include directories and compile definitions</h3>

<p class="todo"> Well, write this! </p>


<a name="cmakeadvanced.external_libraries"></a>
<h3>External libraries</h3>

<p class="todo"> Well, write this! </p>


<a name="cmakeadvanced.run"></a>
<h3>The "run" target revisited</h3>

<p class="todo"> Well, write this! </p>


<a name="cmakeadvanced.install"></a>
<h3>Install a project</h3>


<a name="cmakesauto"></a>
<h2>Autopilot style CMakeLists.txt</h2>

<p>
  If you want a make interface similar to the deal.II library and
  its tutorial, namely maker targets for debug and release
  versions, running the code and cleaning, the easiest way to
  write a <code>CMakeLists.txt</code> file may be to use
  an "autopilot" style macro. Here is a minimalistic example for the
  step-1 tutorial program (<a href="CMakeLists.txt.sample1"
			      target="_top">plain text</a> version) that can be used for simple
  projects:
</p>

<pre class="cmake">
FIND_PACKAGE(deal.II 8.0 REQUIRED
  HINTS
    ${DEAL_II_DIR} ../ ../../ $ENV{DEAL_II_DIR}
    # You can specify additional hints for search paths here, e.g.
    # $ENV{HOME}/workspace/deal.II
)

# Set the name of the project and target:
SET(TARGET "step-1")

# Declare all source files the target consists of:
SET(TARGET_SRC
  step-1.cc
  # You can specify additional files here!
)

CMAKE_MINIMUM_REQUIRED(VERSION 2.8.8)
DEAL_II_INITIALIZE_CACHED_VARIABLES()
PROJECT(${TARGET} CXX)
DEAL_II_INVOKE_AUTOPILOT()
</pre>


      This <code>CMakeLists.txt</code> is intended for use with a small
      project and <i>in-source</i> build (i.e., one does not create a separate
      build directory as we recommend for the <acronym>deal.II</acronym> build
      in the <a href="../readme.html#configuration" target="_body">readme
      file</a>). Using this input file, you can run <code>cmake</code> in the
      source directory as follows:

<pre class="sample">
$ cd step-1
$ cmake .

[...]

###
#
#  Successfully set up project  step-1  with  deal.II-99.99.svn30300  found at
#      /usr
#
#  CMAKE_BUILD_TYPE:         Debug
#
#  You can now run
#      $ make                - to compile and link the program
#      $ make run            - to (compile, link and) run the program
#
#      $ make debug          - to switch the build type to Debug
#      $ make release        - to switch the build type to Release
#
#      $ make edit_cache     - to change (cached) configuration variables
#                              and rerun the configure and generate phases of CMake
#
#      $ make strip_comments - strip the source files in this
#                              directory off the documentation comments
#      $ make clean          - to remove the generated executable as well as
#                              all intermediate compilation files
#      $ make runclean       - to remove all output generated by the program
#      $ make distclean      - to clean the directory from _all_ generated
#                              files (includes clean, runclean and the removal
#                              of the generated build system)
#
#      $ make help           - to view this message again
#
#  Have a nice day!
#
###
</pre>

      There are two additional configuration options (in addition to
      <code>TARGET</code> and <code>TARGET_SRC</code>) that can be set via
      variables before <code>DEAL_II_INVOKE_AUTOPILOT()</code> is called
      (<a href="CMakeLists.txt.sample2" target="_top">plain text</a> version):

<pre class="cmake">
# (Optional)
# Specify a list of files (file globs) that will be removed
# with the "make runclean" and "make distclean" targets.
# (If empty, sensible default values will be used.)
SET(CLEAN_UP_FILES
  # a custom list of globs, e.g. *.log *.vtk
)

# (Optional)
# A custom command line that should be invoked by "make run".
# (If empty, ./${TARGET} will be invoked.)
SET(TARGET_RUN
  # a custom command line, e.g. mpirun -np 2 ${TARGET}
)
</pre>


<a name="dealiiconfig"></a>
<h2>  <code>deal.IIConfig.cmake</code> </h2>

<p>
  Importing the deal.IIConfig.cmake file via <code>FIND_PACKAGE</code>
  will set the following variables and macros; all of the form
  <code>DEAL_II_*</code>:
</p>
<pre class="todo">  
A long list with detailed explanation...  
</pre>
  



    <a name="legacy"></a>
    <h2> Legacy Make.global_options </h2>

    <p>
      Before version 8.0, <acronym>deal.II</acronym> used the
      traditional <code>autoconf/make</code> configuration and build
      system. The interaction between these two programs, as well as
      propagation of information from <acronym>deal.II</acronym> to user
      programs happened through a number of files that were generated within
      the <acronym>deal.II</acronym> directory tree.
      The CMake build system sets up the following compatibility files (if
      <code>DEAL_II_COMPONENT_COMPAT_FILES</code> is set, which is default):
      <pre>

    ${CMAKE_INSTALL_PREFIX}
        ./common/Make.global_options
        ./common/scripts/expand_instantiations
        ./common/scripts/make_dependencies
        ./common/scripts/report_features
      </pre>

      Therefore, it should be sufficient to set <code>D</code> in the old
      user Makefiles to:
      <pre>

    D=/path/install/dir
      </pre>
      where <code>/path/install/dir</code> is the directory set up via
      <code>CMAKE_INSTALL_PREFIX</code> (the path
      <acronym>deal.II</acronym> was installed to).
    </p>



    <hr>

    <address>
      <a href="../mail.html" target="body">The deal.II Group</a>
      $Date$
    </address>
  </body>
</html>
