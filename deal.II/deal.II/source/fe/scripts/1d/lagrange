# Maple script to compute much of the data needed to implement the
# family of Lagrange elements in 2d. Expects that the fields denoting
# position and number of support points, etc are already set. Note that
# we assume a bilinear mapping from the unit to the real cell.
#
# $Id$
# Author: Wolfgang Bangerth, 1998



  phi_polynom := array(0..n_functions-1);
  grad_phi_polynom := array(0..n_functions-1);
  grad_grad_phi_polynom := array(0..n_functions-1);
  local_mass_matrix := array(0..n_functions-1, 0..n_functions-1);

  for i from 0 to n_functions-1 do
    # note that the interp function wants vectors indexed from
    #   one and not from zero. 
    values := array(1..n_functions);
    for j from 1 to n_functions do
      values[j] := 0;
    od;  
    values[i+1] := 1;

    shifted_support_points := array (1..n_functions);
    for j from 1 to n_functions do
      shifted_support_points[j] := support_points[j-1];
    od;
    
    phi_polynom[i] := interp (shifted_support_points, values, xi);
    grad_phi_polynom[i] := diff(phi_polynom[i], xi);
    grad_grad_phi_polynom[i] := diff(grad_phi_polynom[i], xi);
  od;

  phi:= proc(i,x) subs(xi=x, phi_polynom[i]); end;


  points[0] := array(0..n_functions-1);
  points[1] := array(0..n_functions-1);
  for i from 0 to n_functions-1 do
    points[0][i] := support_points[i]/2;  
    points[1][i] := support_points[i]/2+1/2;
  od;  

  prolongation := array(0..1,0..n_functions-1, 0..n_functions-1);

  for i from 0 to 1 do
    for j from 0 to n_functions-1 do
      for k from 0 to n_functions-1 do
        prolongation[i,j,k] := phi(k, points[i][j]);
      od;
    od;
  od;


  # to get the restriction (interpolation) matrices, evaluate
  # the basis functions on the child cells at the global
  # interpolation points
  child_phi[0] := proc(i, point)
                    if ((point<0) or (point>1/2)) then
		      0:
		    else
		      phi(i,2*point):
		    fi:
		  end: 
  child_phi[1] := proc(i, point)
                    if ((point<1/2) or (point>1)) then
		      0:
		    else
		      phi(i,2*point-1):
		    fi:
		  end: 
  restriction := array(0..1,0..n_functions-1, 0..n_functions-1);  
  for child from 0 to 1 do
    for j from 0 to n_functions-1 do
      for k from 0 to n_functions-1 do
        restriction[child,j,k] := child_phi[child](k, support_points[j]):
      od:
    od:
  od:

  
  for i from 0 to n_functions-1 do
    for j from 0 to n_functions-1 do
      local_mass_matrix[i,j] := int(phi_polynom[i] * phi_polynom[j] * h,
                                    xi=0..1);
    od;
  od;

