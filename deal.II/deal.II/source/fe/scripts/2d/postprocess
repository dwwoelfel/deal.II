#  Use the following perl scripts to convert the output into a
#  suitable format.
#
#  $Id$
#  Wolfgang Bangerth, 1998
  
perl -pi -e 's/phi_polynom\[(\d+)\] =/case $1: return/g;' *2d_shape_value
perl -pi -e 's/\[(\d+)\]\[(\d+)\]/($1,$2)/g;' *2d_massmatrix
perl -pi -e 's/(t\d+) =/const double $1 =/g;' *2d_massmatrix
perl -pi -e 's/\[(\d+)\]\[(\d+)\]\[(\d+)\]/[$1]($2,$3)/g;' *2d_prolongation
perl -pi -e 's/.*= 0.0;\n//g;' *2d_prolongation
perl -pi -e 's/\[(\d+)\]\[(\d+)\]\[(\d+)\]/[$1]($2,$3)/g;' *2d_restriction
perl -pi -e 's/.*= 0.0;\n//g;' *2d_restriction
perl -pi -e 's/\[(\d+)\]\[(\d+)\]/($1,$2)/g;' *2d_constraints

perl -pi -e 's/^\s*t/const double t/g;' *2d_inverse_jacobian
perl -pi -e 's/x\[(\d)\]/vertices[$1](0)/g;' *2d_inverse_jacobian
perl -pi -e 's/y\[(\d)\]/vertices[$1](1)/g;' *2d_inverse_jacobian
perl -pi -e 's/inverseJacobian/jacobians[point]/g;' *2d_inverse_jacobian
perl -pi -e 's/\[(\d)\]\[(\d)\] =/($1,$2) =/g;' *2d_inverse_jacobian

perl -pi -e 's/^\s*t/const double t/g;' *2d_inverse_jacobian_grad
perl -pi -e 's/x\[(\d)\]/vertices[$1](0)/g;' *2d_inverse_jacobian_grad
perl -pi -e 's/y\[(\d)\]/vertices[$1](1)/g;' *2d_inverse_jacobian_grad
perl -pi -e 's/inverseJacobian/jacobians_grad[point]/g;' *2d_inverse_jacobian_grad

perl -pi -e 's/([^;])\n/$1/g;' *2d_shape_grad
perl -pi -e 's/grad_phi_polynom\[(\d+)\]\[0\] = (.*);/case $1: return Point<2>($2,/g;' *2d_shape_grad
perl -pi -e 's/grad_phi_polynom\[(\d+)\]\[1\] = (.*);/$2);/g;' *2d_shape_grad


#    concatenate all lines for each entry
perl -pi -e 's/([^;])\n/$1/g;' *2d_shape_grad_grad
#    rename the variable
perl -pi -e 's/\s*grad_grad_phi_polynom/return_value/g;' *2d_shape_grad_grad
#    insert 'case' and 'break' statements
perl -pi -e 's/(return_value\[(\d)\]\[0\]\[0\] = .*;)/break;\ncase $2:\n$1/g;' *2d_shape_grad_grad
#    eliminate first index, since that one is caught by the 'case' statement
perl -pi -e 's/return_value\[\d+\]/return_value/g;' *2d_shape_grad_grad
