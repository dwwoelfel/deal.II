#  --------------------------------- For 2d ---------------------------------
#  -- Use the following maple script to generate the basis functions,
#  -- gradients and prolongation matrices as well as the mass matrix.
#  -- Make sure that the files do not exists beforehand, since output
#  -- is appended instead of overwriting previous contents.
#  --
#  -- You should only have to change the very first lines for polynomials
#  -- of higher order.
#  --------------------------------------------------------------------------
#
# $Id$
# Author: Wolfgang Bangerth, 1998

  n_functions      := 25:
  n_face_functions := 5:

  trial_function := (a1 + a2*xi + a3*xi*xi + a4*xi**3 + a5*xi**4) +
                     (b1 + b2*xi + b3*xi*xi + b4*xi**3 + b5*xi**4)*eta +
		     (c1 + c2*xi + c3*xi*xi + c4*xi**3 + c5*xi**4)*eta*eta +
		     (d1 + d2*xi + d3*xi*xi + d4*xi**3 + d5*xi**4)*eta**3 +
		     (e1 + e2*xi + e3*xi*xi + e4*xi**3 + e5*xi**4)*eta**4:
  face_trial_function := a + b*xi + c*xi*xi + d*xi**3 + e*xi**4:
  # note: support_points[i] is a vector which is indexed from
  # one and not from zero!
  support_points := array(0..n_functions-1):
  support_points[0] := [0,0]:
  support_points[1] := [1,0]:
  support_points[2] := [1,1]:
  support_points[3] := [0,1]:
  support_points[4] := [1/4,0]:
  support_points[5] := [2/4,0]:
  support_points[6] := [3/4,0]:
  support_points[7] := [1,1/4]:
  support_points[8] := [1,2/4]:
  support_points[9] := [1,3/4]:
  support_points[10] := [1/4,1]:
  support_points[11] := [2/4,1]:
  support_points[12] := [3/4,1]:
  support_points[13] := [0,1/4]:
  support_points[14] := [0,2/4]:
  support_points[15] := [0,3/4]:
  support_points[16] := [1/4,1/4]:
  support_points[17] := [3/4,1/4]:
  support_points[18] := [3/4,3/4]:
  support_points[19] := [1/4,3/4]:
  support_points[20] := [1/2,1/4]:
  support_points[21] := [3/4,1/2]:
  support_points[22] := [1/2,3/4]:
  support_points[23] := [1/4,1/2]:
  support_points[24] := [1/2,1/2]:

  face_support_points := array(0..n_face_functions-1):
  face_support_points[0] := 0:
  face_support_points[1] := 1:
  face_support_points[2] := 1/4:
  face_support_points[3] := 2/4:
  face_support_points[4] := 3/4:
  constrained_face_support_points := array(0..2*(n_face_functions-2)+1-1):
  constrained_face_support_points[0] := 1/2:
  constrained_face_support_points[1] := 1/8:
  constrained_face_support_points[2] := 2/8:
  constrained_face_support_points[3] := 3/8:
  constrained_face_support_points[4] := 5/8:
  constrained_face_support_points[5] := 6/8:
  constrained_face_support_points[6] := 7/8:


  # do the real work
  read "lagrange":

  
  # write data to files
  print ("writing data to files"):
  readlib(C):
  C(phi_polynom, filename=quartic2d_shape_value):
  C(grad_phi_polynom, filename=quartic2d_shape_grad):
  C(grad_grad_phi_polynom, filename=quartic2d_shape_grad_grad):
  C(prolongation, filename=quartic2d_prolongation):
  C(restriction, filename=quartic2d_restriction):
  C(local_mass_matrix, optimized, filename=quartic2d_massmatrix):
  C(interface_constraints, filename=quartic2d_constraints):
  C(real_points, optimized, filename=quartic2d_real_points):

