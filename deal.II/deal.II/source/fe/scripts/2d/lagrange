# Maple script to compute much of the data needed to implement the
# family of Lagrange elements in 2d. Expects that the fields denoting
# position and number of support points, etc are already set. Note that
# we assume a bilinear mapping from the unit to the real cell.
#
# $Id$
# Author: Wolfgang Bangerth, 1998

  phi_polynom := array(0..n_functions-1):
  grad_phi_polynom := array(0..n_functions-1,0..1):
  grad_grad_phi_polynom := array(0..n_functions-1,0..1,0..1):
  local_mass_matrix := array(0..n_functions-1, 0..n_functions-1):
  prolongation := array(0..3,0..n_functions-1, 0..n_functions-1):
  interface_constraints := array(0..2*(n_face_functions-2)+1-1,
                                 0..n_face_functions-1):
  real_points := array(0..n_functions-1, 0..1);

  print ("Computing basis functions"):
  for i from 0 to n_functions-1 do
    print (i):
    values := array(1..n_functions):
    for j from 1 to n_functions do
      values[j] := 0:
    od:  
    values[i+1] := 1:

    equation_system := {}:
    for j from 0 to n_functions-1 do
      poly := subs(xi=support_points[j][1],
                   eta=support_points[j][2],
		   trial_function):
      if (i=j) then
        equation_system := equation_system union {poly = 1}:
      else	
        equation_system := equation_system union {poly = 0}:
      fi:	
    od:
    
    phi_polynom[i] := subs(solve(equation_system), trial_function):
    grad_phi_polynom[i,0] := diff(phi_polynom[i], xi):
    grad_phi_polynom[i,1] := diff(phi_polynom[i], eta):

    grad_grad_phi_polynom[i,0,0] := diff(phi_polynom[i], xi, xi):
    grad_grad_phi_polynom[i,0,1] := diff(phi_polynom[i], xi, eta):
    grad_grad_phi_polynom[i,1,0] := diff(phi_polynom[i], eta,xi):
    grad_grad_phi_polynom[i,1,1] := diff(phi_polynom[i], eta,eta):
  od:

  phi:= proc(i,x,y) subs(xi=x, eta=y, phi_polynom[i]): end:


  #points on children: let them be indexed one-based, as are
  #the support_points
  points[0] := array(0..n_functions-1, 1..2):
  points[1] := array(0..n_functions-1, 1..2):
  points[2] := array(0..n_functions-1, 1..2):
  points[3] := array(0..n_functions-1, 1..2):
  for i from 0 to n_functions-1 do
    points[0][i,1] := support_points[i][1]/2:
    points[0][i,2] := support_points[i][2]/2:
    
    points[1][i,1] := support_points[i][1]/2+1/2:
    points[1][i,2] := support_points[i][2]/2:

    points[2][i,1] := support_points[i][1]/2+1/2:
    points[2][i,2] := support_points[i][2]/2+1/2:

    points[3][i,1] := support_points[i][1]/2:
    points[3][i,2] := support_points[i][2]/2+1/2:
  od:  

  print ("Computing prolongation matrices"):
  for i from 0 to 3 do
    print ("child", i):
    for j from 0 to n_functions-1 do
      for k from 0 to n_functions-1 do
        prolongation[i,j,k] := phi(k, points[i][j,1], points[i][j,2]):
      od:
    od:
  od:

  print ("Computing restriction matrices"):
  # to get the restriction (interpolation) matrices, evaluate
  # the basis functions on the child cells at the global
  # interpolation points
  child_phi[0] := proc(i, x, y)
                    if ((x>1/2) or (y>1/2)) then
		      0:
		    else
		      phi(i,2*x,2*y):
		    fi:
		  end: 
  child_phi[1] := proc(i, x, y)
                    if ((x<1/2) or (y>1/2)) then
		      0:
		    else
		      phi(i,2*x-1,2*y):
		    fi:
		  end: 
  child_phi[2] := proc(i, x, y)
                    if ((x<1/2) or (y<1/2)) then
		      0:
		    else
		      phi(i,2*x-1,2*y-1):
		    fi:
		  end: 
  child_phi[3] := proc(i, x, y)
                    if ((x>1/2) or (y<1/2)) then
		      0:
		    else
		      phi(i,2*x,2*y-1):
		    fi:
		  end: 
  restriction := array(0..3,0..n_functions-1, 0..n_functions-1):
  for child from 0 to 3 do
    for j from 0 to n_functions-1 do
      for k from 0 to n_functions-1 do
        restriction[child,j,k] := child_phi[child](k,
	                                           support_points[j][1],
						   support_points[j][2]):
      od:
    od:
  od:


  print ("Computing local mass matrix"):
  # tphi are the basis functions of the linear element. These functions
  # are used for the computation of the subparametric transformation from
  # unit cell to real cell.
  # x and y are arrays holding the x- and y-values of the four vertices
  # of this cell in real space. 
  #
  # Since we're already at it and need it anyway, we also compute the
  # Jacobian matrix of the transform and its derivatives. For the
  # question of whether to take the given form or its transpose, refer
  # to the documentation of the FEValues class and the source code
  # documentation of FELinearMapping::fill_fe_values. Also note, that
  # the computed inverse is multiplied to the unit cell gradients
  # *from the right*. 
  x := array(0..3);
  y := array(0..3);
  tphi[0] := (1-xi)*(1-eta):
  tphi[1] := xi*(1-eta):
  tphi[2] := xi*eta:
  tphi[3] := (1-xi)*eta:
  x_real := sum(x[s]*tphi[s], s=0..3):
  y_real := sum(y[s]*tphi[s], s=0..3):
  Jacobian := linalg[matrix](2,2, [[diff(x_real,xi), diff(x_real,eta)],
                                   [diff(y_real,xi), diff(y_real,eta)]]):
  inverseJacobian := linalg[inverse](Jacobian):
  detJ := linalg[det](Jacobian):

  grad_inverseJacobian := array(1..2, 1..2, 1..2):
  for i from 1 to 2 do
    for j from 1 to 2 do
      for k from 1 to 2 do
        if (i=1) then
          grad_inverseJacobian[i,j,k] := diff (inverseJacobian[j,k], xi):
        else 
          grad_inverseJacobian[i,j,k] := diff (inverseJacobian[j,k], eta):
        fi:
      od:
    od:
  od:

  for i from 0 to n_functions-1 do
    print ("line", i):
    for j from 0 to n_functions-1 do
      local_mass_matrix[i,j] := int(int(phi_polynom[i] * phi_polynom[j] * detJ,
                                        xi=0..1), eta=0..1):
    od:
  od:

  print ("computing support points in real space"):
  for i from 0 to n_functions-1 do
    real_points[i,0] := subs(xi=support_points[i][1],
                             eta=support_points[i][2], x_real);
    real_points[i,1] := subs(xi=support_points[i][1],
                             eta=support_points[i][2], y_real);
  od:

  print ("computing interface constraint matrices"):
  # compute the interface constraint matrices. these are the values of the
  # basis functions on the coarse cell's face at the points of the child
  # cell's basis functions on the child faces
  face_phi_polynom := array(0..n_face_functions-1):
  for i from 0 to n_face_functions-1 do
    # note that the interp function wants vectors indexed from
    #   one and not from zero. 
    values := array(1..n_face_functions):
    for j from 1 to n_face_functions do
      values[j] := 0:
    od:  
    values[i+1] := 1:

    shifted_face_support_points := array (1..n_face_functions):
    for j from 1 to n_face_functions do
      shifted_face_support_points[j] := face_support_points[j-1]:
    od:
    
    face_phi_polynom[i] := interp (shifted_face_support_points, values, xi):
  od:

  for i from 0 to 2*(n_face_functions-2)+1-1 do
    for j from 0 to n_face_functions-1 do
      interface_constraints[i,j] := subs(xi=constrained_face_support_points[i],
                                     face_phi_polynom[j]); 
    od:
  od:
