  dim:=3;

  print (`Computing basis functions`);
  phi_polynom := array(0..n_functions-1);
  for i from 0 to n_functions-1 do
    print (i):
    values := array(1..n_functions):
    for j from 1 to n_functions do
      values[j] := 0:
    od:  
    values[i+1] := 1:

    equation_system := {}:
    for j from 0 to n_functions-1 do
      poly := subs(xi=support_points[j][1],
                   eta=support_points[j][2],
		   zeta=support_points[j][3],
		   trial_function):
      if (i=j) then
        equation_system := equation_system union {poly = 1}:
      else	
        equation_system := equation_system union {poly = 0}:
      fi:	
    od:
    
    phi_polynom[i] := subs(solve(equation_system), trial_function);
  od:

  phi:= proc(i,x,y,z) subs(xi=x, eta=y, zeta=z, phi_polynom[i]): end:



  #points on children: let them be indexed one-based, as are
  #the support_points
  #  child_phi[c](i, points[c][j, ])=delta_ij
  points[0] := array(0..n_functions-1, 1..3):
  points[1] := array(0..n_functions-1, 1..3):
  points[2] := array(0..n_functions-1, 1..3):
  points[3] := array(0..n_functions-1, 1..3):
  points[4] := array(0..n_functions-1, 1..3):
  points[5] := array(0..n_functions-1, 1..3):
  points[6] := array(0..n_functions-1, 1..3):
  points[7] := array(0..n_functions-1, 1..3):
  for i from 0 to n_functions-1 do
    points[0][i,1] := support_points[i][1]/2:
    points[0][i,2] := support_points[i][2]/2:
    points[0][i,3] := support_points[i][3]/2:
    
    points[1][i,1] := support_points[i][1]/2+1/2:
    points[1][i,2] := support_points[i][2]/2:
    points[1][i,3] := support_points[i][3]/2:

    points[2][i,1] := support_points[i][1]/2+1/2:
    points[2][i,2] := support_points[i][2]/2:
    points[2][i,3] := support_points[i][3]/2+1/2:

    points[3][i,1] := support_points[i][1]/2:
    points[3][i,2] := support_points[i][2]/2:
    points[3][i,3] := support_points[i][3]/2+1/2:

    points[4][i,1] := support_points[i][1]/2:
    points[4][i,2] := support_points[i][2]/2+1/2:
    points[4][i,3] := support_points[i][3]/2:
    
    points[5][i,1] := support_points[i][1]/2+1/2:
    points[5][i,2] := support_points[i][2]/2+1/2:
    points[5][i,3] := support_points[i][3]/2:

    points[6][i,1] := support_points[i][1]/2+1/2:
    points[6][i,2] := support_points[i][2]/2+1/2:
    points[6][i,3] := support_points[i][3]/2+1/2:

    points[7][i,1] := support_points[i][1]/2:
    points[7][i,2] := support_points[i][2]/2+1/2:
    points[7][i,3] := support_points[i][3]/2+1/2:
  od:  

  # find the prolongation matrices such that
  #  phi(k,x,y,z)|_K_i=prol[i,j,k] child_phi[i](j,x,y,z)
  print (`Computing prolongation matrices`):
  prolongation := array(0..7,0..n_functions-1, 0..n_functions-1):
  for i from 0 to 7 do
    for j from 0 to n_functions-1 do
      for k from 0 to n_functions-1 do
        prolongation[i,j,k] := phi(k, points[i][j,1], points[i][j,2], points[i][j,3]);
      od:
    od:
  od:

  # assemble the local mass matrix (on the unit square)
  # m[i,j]=int_{0..1}int_{0..1}int_{0..1} phi[i]*phi[j] dxdydz
  m := array(1..n_functions, 1..n_functions):
  print (`Assembling mass matrix`):
  for i from 1 to n_functions do
    for j from 1 to n_functions do
      m[i,j] := int(int(int(phi_polynom[i-1] * phi_polynom[j-1], xi=0..1), eta=0..1), zeta=0..1);	
    od:
  od:

  print(`m=`, m);

  # assemble the local mass matrix for child cell 0 
  # m[i,j]=int_{0..0.5}int_{0..0.5}int_{0..0.5} child_phi[0]*child_phi[0] dxdydz
  child_m := array(1..n_functions, 1..n_functions):
  child_m:=linalg[scalarmul](m, 1/2**dim);

  print(`Ausgabe=`);
  print(`child_m=`,child_m);

  # inverte the local mass matrix
  inv_m := linalg[inverse](m):
  print(`inv_m=`, inv_m);
  
  # assembling restriction matrices
  restriction := array(0..7, 0..n_functions-1, 0..n_functions-1):
  restr_child := array(1..n_functions, 1..n_functions):
  prol_child:= array(1..n_functions, 1..n_functions):
  for child from 0 to 7 do
    print(`child=`, child);
    # copy the prologation matrix with a shift 1 and take the transponent
    for i from 1 to n_functions do
      for j from 1 to n_functions do
        prol_child[i,j] := prolongation[child,j-1,i-1]:
      od:
    od:
    restr_child := linalg[multiply](inv_m, prol_child, child_m);
    print(restr_child);
    # copy the restriction of this child with a shift 1
    for i from 1 to n_functions do
      for j from 1 to n_functions do
        restriction[child,i-1,j-1] := restr_child[i,j]:
      od:
    od:
  od:












