#  --------------------------------- For 3d ---------------------------------
#  -- Use the following maple script to generate the basis functions,
#  -- gradients and prolongation matrices as well as the mass matrix.
#  -- Make sure that the files do not exists beforehand, since output
#  -- is appended instead of overwriting previous contents.
#  --
#  -- You should only have to change the very first lines for polynomials
#  -- of higher order.
#
#  --------------------------------------------------------------------------
#
# $Id$
# Author: Wolfgang Bangerth, 1999

  n_functions      := 8:
  n_face_functions := 4:
  n_constraints    := 5:

  trial_function := ((a1 + a2*xi) +
                     (b1 + b2*xi)*eta) +
                    ((d1 + d2*xi) + 
                     (e1 + e2*xi)*eta)*zeta:
  face_trial_function := subs(zeta=0, trial_function):
  # note: support_points[i] is a vector which is indexed from
  # one and not from zero!
  support_points := array(0..n_functions-1):
  support_points[0] := array(1..3, [0,0,0]):
  support_points[1] := array(1..3, [1,0,0]):
  support_points[2] := array(1..3, [1,0,1]):
  support_points[3] := array(1..3, [0,0,1]):
  support_points[4] := array(1..3, [0,1,0]):
  support_points[5] := array(1..3, [1,1,0]):
  support_points[6] := array(1..3, [1,1,1]):
  support_points[7] := array(1..3, [0,1,1]):

  face_support_points := array(0..n_face_functions-1):
  face_support_points[0] := [0,0]:
  face_support_points[1] := [1,0]:
  face_support_points[2] := [1,1]:
  face_support_points[3] := [0,1]:

  # list of functions which are at face 0, used to compute
  # the constraints on a face
  constrained_face_function := array (0..n_face_functions-1):
  # the list of points at which we want the functions at
  # faces to be evaluated
  constrained_face_support_points := array(0..n_constraints-1):
  constrained_face_function[0] := 0:
  constrained_face_function[1] := 1:
  constrained_face_function[2] := 2:
  constrained_face_function[3] := 3:
  constrained_face_support_points[0] := array(0..1, [1/2,1/2]):
  constrained_face_support_points[1] := array(0..1, [1/2,0]):
  constrained_face_support_points[2] := array(0..1, [1,1/2]):
  constrained_face_support_points[3] := array(0..1, [1/2,1]):
  constrained_face_support_points[4] := array(0..1, [0,1/2]):


  # do the real work
  read "lagrange":

  # ... originally taken from another comment, so this does not
  # fit in here too well...
  #
  # Since we're already at it and need it anyway, we also compute the
  # Jacobian matrix of the transform and its derivatives. For the
  # question of whether to take the given form or its transpose, refer
  # to the documentation of the FEValues class and the source code
  # documentation of FELinearMapping::fill_fe_values. Also note, that
  # the computed inverse is multiplied to the unit cell gradients
  # *from the right*. 
  print ("Computing Jacobian matrices"):
  Jacobian := linalg[matrix](3,3, [[diff(x_real,xi), diff(x_real,eta), diff(x_real,zeta)],
                                   [diff(y_real,xi), diff(y_real,eta), diff(y_real,zeta)],
                                   [diff(z_real,xi), diff(z_real,eta), diff(z_real,zeta)]]):
  inverseJacobian := linalg[inverse](Jacobian):
  detJ := linalg[det](Jacobian):

  grad_inverseJacobian := array(1..3, 1..3, 1..3):
  for i from 1 to 3 do
    for j from 1 to 3 do
      for k from 1 to 3 do
        if (i=1) then
          grad_inverseJacobian[i,j,k] := diff (inverseJacobian[j,k], xi):
        else 
          if (i=2) then
            grad_inverseJacobian[i,j,k] := diff (inverseJacobian[j,k], eta):
          else
            grad_inverseJacobian[i,j,k] := diff (inverseJacobian[j,k], zeta):
	  fi:
        fi:
      od:
    od:
  od:


  print ("computing support points in real space"):
  real_points := array(0..n_functions-1, 0..2);
  for i from 0 to n_functions-1 do
    real_points[i,0] := subs(xi=support_points[i][1],
			     eta=support_points[i][2],	
                             zeta=support_points[i][3], x_real);
    real_points[i,1] := subs(xi=support_points[i][1],
                             eta=support_points[i][2],	
                             zeta=support_points[i][3], y_real);
    real_points[i,2] := subs(xi=support_points[i][1],
                             eta=support_points[i][2],	
                             zeta=support_points[i][3], z_real);
  od:


  
  # write data to files
  print ("writing data to files"):
  readlib(C):
  C(phi_polynom,            filename=linear3d_shape_value):
  C(grad_phi_polynom,       filename=linear3d_shape_grad):
  C(grad_grad_phi_polynom,  filename=linear3d_shape_grad_grad):
  C(prolongation,           filename=linear3d_prolongation):
  C(restriction,            filename=linear3d_restriction):
  C(local_mass_matrix,      filename=linear3d_massmatrix):
  C(interface_constraints,  filename=linear3d_constraints):
  C(real_points, optimized, filename=linear3d_real_points):
  # the following two files get much smaller and faster when processed using 'optimized'
  C(inverseJacobian,        optimized, filename=linear3d_inverse_jacobian):
  C(grad_inverseJacobian,   optimized, filename=linear3d_inverse_jacobian_grad):


