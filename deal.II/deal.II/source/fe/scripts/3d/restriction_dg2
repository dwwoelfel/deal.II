#  --------------------------------- For 3d ---------------------------------
#  -- Use the following maple script to generate the restriction matrices
#  -- for DG.
#  -- Make sure that the files do not exists beforehand, since output
#  -- is appended instead of overwriting previous contents.
#  --
#  -- You should only have to change the very first lines for polynomials
#  -- of higher order.
#  --------------------------------------------------------------------------
#
# $Id$
# Author: Ralf Hartmann, 2000

# for DG(2)

  read lagrange_tools:

  n_functions      := 27:

  trial_function := ((a1 + a2*xi + a3*xi*xi) +
                     (b1 + b2*xi + b3*xi*xi)*eta +
                     (c1 + c2*xi + c3*xi*xi)*eta*eta) +
                    ((d1 + d2*xi + d3*xi*xi) + 
                     (e1 + e2*xi + e3*xi*xi)*eta +
                     (f1 + f2*xi + f3*xi*xi)*eta*eta)*zeta +
                    ((g1 + g2*xi + g3*xi*xi) + 
                     (h1 + h2*xi + h3*xi*xi)*eta +
                     (i1 + i2*xi + i3*xi*xi)*eta*eta)*zeta*zeta:
  # note: support_points[i] is a vector which is indexed from
  # one and not from zero!
  #   phi(i,support_points[j])=delta_ij
  support_points := array(0..n_functions-1):

  support_points_fill_vertices (0, support_points):
  support_points_fill_lines (8, 1, support_points):
  support_points[20] := array(1..3, [1/2, 0, 1/2]):  #faces
  support_points[21] := array(1..3, [1/2, 1, 1/2]):
  support_points[22] := array(1..3, [1/2, 1/2, 0]):
  support_points[23] := array(1..3, [1, 1/2, 1/2]):
  support_points[24] := array(1..3, [1/2, 1/2, 1]):
  support_points[25] := array(1..3, [0, 1/2, 1/2]):
  support_points[26] := array(1..3, [1/2, 1/2,1/2]):  #center

  read restriction_dg;

  print (`writing data to files`):
  readlib(C):
  C(restriction, filename=restriction_dg2_txt);











