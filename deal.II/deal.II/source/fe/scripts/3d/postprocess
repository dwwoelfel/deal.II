#  Use the following perl scripts to convert the output into a
#  suitable format.
#
#  $Id$
#  Wolfgang Bangerth, 1998
  
perl -pi -e 's/phi_polynom\[(\d+)\] =/case $1: return/g;' *3d_shape_value

perl -pi -e 's/([^;])\n/$1/g;' *3d_shape_grad
perl -pi -e 's/grad_phi_polynom\[(\d+)\]\[0\] = (.*);/case $1: return Point<3>($2,/g;' *3d_shape_grad
perl -pi -e 's/grad_phi_polynom\[(\d+)\]\[[01]\] = (.*);/$2,/g;' *3d_shape_grad
perl -pi -e 's/grad_phi_polynom\[(\d+)\]\[2\] = (.*);/$2);/g;' *3d_shape_grad


#    concatenate all lines for each entry
perl -pi -e 's/([^;])\n/$1/g;' *3d_shape_grad_grad
#    rename the variable
perl -pi -e 's/\s*grad_grad_phi_polynom/return_value/g;' *3d_shape_grad_grad
#    insert 'case' and 'break' statements
perl -pi -e 's/(return_value\[(\d)\]\[0\]\[0\] = .*;)/break;\ncase $2:\n$1/g;' *3d_shape_grad_grad
#    eliminate first index, since that one is caught by the 'case' statement
perl -pi -e 's/return_value\[\d+\]/return_value/g;' *3d_shape_grad_grad
#    delete lines where only a zero is set, since this already is done in the constructor
perl -pi -e 's/.*= 0.0;\n//g;' *3d_shape_grad_grad


perl -pi -e 's/\[(\d+)\]\[(\d+)\]\[(\d+)\]/[$1]($2,$3)/g;' *3d_prolongation
perl -pi -e 's/.*= 0.0;\n//g;' *3d_prolongation


perl -pi -e 's/\[(\d+)\]\[(\d+)\]\[(\d+)\]/[$1]($2,$3)/g;' *3d_restriction
perl -pi -e 's/.*= 0.0;\n//g;' *3d_restriction


perl -pi -e 's/\[(\d+)\]\[(\d+)\]/($1,$2)/g;' *3d_constraints
perl -pi -e 's/.*= 0.0;\n//g;' *3d_constraints

perl -pi -e 's/([^;])\n/$1/g;' *3d_inverse_jacobian
perl -pi -e 's/^\s*t/              const double t/g;' *3d_inverse_jacobian
perl -pi -e 's/x\[(\d)\]/vertices[$1](0)/g;' *3d_inverse_jacobian
perl -pi -e 's/y\[(\d)\]/vertices[$1](1)/g;' *3d_inverse_jacobian
perl -pi -e 's/z\[(\d)\]/vertices[$1](2)/g;' *3d_inverse_jacobian
perl -pi -e 's/^s*inverseJacobian/              jacobians[point]/g;' *3d_inverse_jacobian
perl -pi -e 's/\[(\d)\]\[(\d)\] =/($1,$2) =/g;' *3d_inverse_jacobian

perl -pi -e 's/([^;])\n/$1/g;' *3d_inverse_jacobian_grad
perl -pi -e 's/^\s*t/              const double t/g;' *3d_inverse_jacobian_grad
perl -pi -e 's/x\[(\d)\]/vertices[$1](0)/g;' *3d_inverse_jacobian_grad
perl -pi -e 's/y\[(\d)\]/vertices[$1](1)/g;' *3d_inverse_jacobian_grad
perl -pi -e 's/z\[(\d)\]/vertices[$1](2)/g;' *3d_inverse_jacobian_grad
perl -pi -e 's/^\s*grad_inverseJacobian/              jacobians_grad[point]/g;' *3d_inverse_jacobian_grad


perl -pi -e 's/^array.*\n//g; s/^\s*\]\)//g; s/^\n//g;' *3d_unit_support_points
perl -pi -e 's/\s+\((\d+)\)/  unit_points[$1]/g;' *3d_unit_support_points
perl -pi -e 's/= \[/= Point<3>(/g; s/\]\s*\n/);\n/g;' *3d_unit_support_points


perl -pi -e 's/real_space_points\[(\d+)\]\[(\d+)\]/support_points[$1]($2)/g;' *3d_real_points
perl -pi -e 's/x\[(\d+)\]/vertices[$1](0)/g; s/y\[(\d+)\]/vertices[$1](1)/g; s/z\[(\d+)\]/vertices[$1](2)/g;' *3d_real_points