/* $Id$ */

#include <basic/data_io.h>
#include <grid/dof.h>
#include <grid/dof_accessor.h>
#include <grid/tria_iterator.h>
#include <grid/tria.h>
#include <map.h>
#include <iostream.h>
#include <algo.h>
#include <time.h>


extern TriaActiveIterator<1,DoFCellAccessor<1> > __dummy566; // wait for gcc2.8
extern TriaActiveIterator<2,DoFCellAccessor<2> > __dummy567;






template <int dim>
DataIn<dim>::DataIn () :
		tria(0) {};



template <int dim>
void DataIn<dim>::attach_triangulation (Triangulation<dim> *t) {
  tria = t;
};



template <int dim>
void DataIn<dim>::read_ucd (istream &in) {
  Assert (tria != 0, ExcNoTriangulationSelected());
  Assert ((1<=dim) && (dim<=2), ExcNotImplemented());


				   // skip comments at start of file
  char c;
  while (in.get(c), c=='#') 
    {
      char line[256];
      in.get (line, 255, '\n'); // ignore rest of line, at most 256 chars
      in.get (c);         // ignore '\n' at end of line.
    };
  
				   // put back first character of
				   // first non-comment line
  in.putback (c);
  
  
  unsigned int n_vertices;
  unsigned int n_cells;
  int dummy;

  in >> n_vertices
     >> n_cells
     >> dummy         // number of data vectors
     >> dummy         // cell data
     >> dummy;        // model data

				   // set up array of vertices
  vector<Point<dim> >     vertices (n_vertices);
				   // set up mapping between numbering
				   // in ucd-file (key) and in the
				   // vertices vector
  map<int,int,less<int> > vertex_indices;
  
  for (unsigned int vertex=0; vertex<n_vertices; ++vertex) 
    {
      int vertex_number;
      double x[3];

				       // read vertex
      in >> vertex_number
	 >> x[0] >> x[1] >> x[2];

				       // store vertex
      for (unsigned int d=0; d<dim; ++d)
	vertices[vertex](d) = x[d];
				       // store mapping; note that
				       // vertices_indices[i] is automatically
				       // created upon first usage
      vertex_indices[vertex_number] = vertex;
    };

				   // set up array of cells
  vector<vector<int> > cells;

  for (unsigned int cell=0; cell<n_cells; ++cell) 
    {
      String cell_type;

      in >> dummy          // cell number
	 >> dummy;         // material id
      in >> cell_type;

      if (((cell_type = "line") && (dim == 1)) ||
	  ((cell_type = "quad") && (dim == 2)))
					 // ignore lines in more than one
					 // dimension, quads in more than
					 // two, and triangles in any dimension
	{
					   // allocate and read indices
	  cells.push_back (vector<int> (1<<dim));
	  for (unsigned int i=0; i<(1<<dim); ++i)
	    in >> cells.back()[i];

					   // transform from ucd to
					   // consecutive numbering
	  for (unsigned int i=0; i<(1<<dim); ++i)
	    if (vertex_indices.find (cells.back()[i]) != vertex_indices.end())
					       // vertex with this index exists
	      cells.back()[i] = vertex_indices[cells.back()[i]];
	    else 
	      {
						 // no such vertex index
		Assert (false, ExcInvalidVertexIndex(cell, cells.back()[i]));
		cells.back()[i] = -1;
	      };
	};
    };

  tria->create_triangulation (vertices, cells);
};







template <int dim>
DataOut<dim>::DataOut () :
		dofs(0) {};



template <int dim>
void DataOut<dim>::attach_dof_handler (DoFHandler<dim> &d) {
  dofs = &d;
};



template <int dim>
void DataOut<dim>::add_data_vector (const dVector &vec,
				    const String  &name,
				    const String  &units) {
  DataEntry new_entry (&vec, name, units);
  data.push_back (new_entry);
};



template <int dim>
void DataOut<dim>::clear_data_vectors () {
  data.erase (data.begin(), data.end());
};



template <int dim>
void DataOut<dim>::write_ucd (ostream &out) const {
  Assert (dofs != 0, ExcNoDoFHandlerSelected());
  Assert (dofs->get_selected_fe().dofs_per_vertex==1,
	  ExcIncorrectDofsPerVertex());
  Assert ((1<=dim) && (dim<=3), ExcNotImplemented());
  
  DoFHandler<dim>::active_cell_iterator cell,
					endc = dofs->end();
  unsigned int n_vertex_dofs;
  
				   // first loop over all cells to
				   // find out how many degrees of
				   // freedom there are located on
				   // vertices
  if (true) 
    {
				       // block this to have local
				       // variables destroyed after
				       // use
      vector<bool> is_vertex_dof (dofs->n_dofs(), false);
      for (cell=dofs->begin_active(); cell!=endc; ++cell)
	for (unsigned int vertex=0; vertex<(1<<dim); ++vertex) 
	  is_vertex_dof[cell->vertex_dof_index(vertex,0)] = true;

      n_vertex_dofs = 0;
      for (unsigned i=0; i!=is_vertex_dof.size(); ++i)
	if (is_vertex_dof[i] == true)
	  ++n_vertex_dofs;
    };
  

				   // write preamble
  if (true) 
    {
				       // block this to have local
				       // variables destroyed after
				       // use
      time_t  time1= time (0);
      tm     *time = localtime(&time1); 
      out << "# This file was generated by the deal.II library." << endl
	  << "# Date =  "
	  << time->tm_year+1900 << "/"
	  << time->tm_mon+1 << "/"
	  << time->tm_mday << endl
	  << "# Time =  "
	  << time->tm_hour << ":" << time->tm_min << ":" << time->tm_sec << endl
	  << "#" << endl
	  << "# For a description of the UCD format see the AVS Developer's guide."
	  << endl;
    };

				   // start with ucd data
  out << n_vertex_dofs << ' '
      << dofs->get_tria().n_active_cells() << ' '
      << data.size() << ' '
      << 0 << ' '                  // no cell data
      << 0                         // no model data
      << endl;
  
				   // write used nodes
  if (true) 
    {
				       // note if a given vertex was
				       // already written
      vector<bool> already_written (dofs->n_dofs(), false);
				       // write vertices
      for (cell=dofs->begin_active(); cell!=endc; ++cell)
	for (unsigned int vertex=0; vertex<(1<<dim); ++vertex) 
	  if (already_written[cell->vertex_dof_index(vertex,0)]==false)
	    {
	      out << cell->vertex_dof_index(vertex,0) // vertex index
		  << "   "; 
	      for (unsigned int d=0; d<dim; ++d)      // vertex coordinates
		out << cell->vertex(vertex)(d) << ' ';
	      for (unsigned int d=dim; d<3; ++d)
		out << 0 << ' ';
	      out << endl;

	      already_written[cell->vertex_dof_index(vertex,0)] = true;
	    };
    };

				   // write cells. Enumerate cells
				   // consecutively (doesn't matter since
				   // we do not use cell data)
  if (true)
    {
      unsigned int c;
      for (cell=dofs->begin_active(), c=0; cell!=endc; ++cell, ++c)
	{
	  out << c << ' '
	      << 1 << "   ";             // material id (unused)
	  switch (dim) 
	    {
	      case 1:  out << "line  "; break;
	      case 2:  out << "quad  "; break;
	      case 3:  out << "hex   "; break;
	    };
	  for (unsigned int vertex=0; vertex<(1<<dim); ++vertex)
	    out << cell->vertex_dof_index(vertex,0) << ' ';
	  out << endl;
	};
    };

				   // if data given: write data, else
				   // only write grid
  if (data.size() != 0)
    {
      out << data.size() << "    ";    // number of vectors
      for (unsigned int i=0; i!=data.size(); ++i)
	out << 1 << ' ';               // number of components;
				       // only 1 supported presently
      out << endl;
      
      for (unsigned int i=0; i<data.size(); ++i)
	out << data[i].name << ',' << data[i].units << endl;
      
      for (cell=dofs->begin_active(); cell!=endc; ++cell)
	for (unsigned int vertex=0; vertex<(1<<dim); ++vertex)
	  {
	    out << cell->vertex_dof_index(vertex,0) << "   ";
	    for (unsigned int i=0; i!=data.size(); ++i)
	      out << (*data[i].data)(cell->vertex_dof_index(vertex,0)) << ' ';
	    out << endl;
	  };
    };
				   // no cell data
				   // no model data
};



template <int dim>
void DataOut<dim>::write_gnuplot (ostream &out) const {
  Assert (dofs != 0, ExcNoDoFHandlerSelected());
  Assert ((1<=dim) && (dim<=3), ExcNotImplemented());

  if (dim==1)
    Assert (dofs->get_selected_fe().dofs_per_vertex==1,
	    ExcIncorrectDofsPerVertex());

  DoFHandler<dim>::active_cell_iterator cell;
  DoFHandler<dim>::active_cell_iterator endc = dofs->end();

  for (cell=dofs->begin_active(); cell!=endc; ++cell) 
    {
      switch (dim) 
	{
	  case 1:
						 // one dimension: write
						 // left vertex, right vertex
						 // and data values
		for (unsigned int vertex=0; vertex<2; ++vertex) 
		  {
		    out << cell->vertex(vertex)
			<< "   ";
		    for (unsigned int i=0; i!=data.size(); ++i)
		      out << (*data[i].data)(cell->vertex_dof_index(vertex,0))
			  << ' ';
		    out << endl;
		  };
		
		break;

	  case 2:
						 // two dimension: output
						 // grid and data as a sequence
						 // of lines in 3d
		for (unsigned int vertex=0; vertex<4; ++vertex) 
		  {
		    out << cell->vertex(vertex) << "   ";
		    for (unsigned int i=0; i!=data.size(); ++i)
		      out << (*data[i].data)(cell->vertex_dof_index(vertex,0))
			  << ' ';
		    out << endl;
		  };
						 // first vertex again
		out << cell->vertex(0) << "   ";
		for (unsigned int i=0; i!=data.size(); ++i)
		  out << (*data[i].data)(cell->vertex_dof_index(0,0))
		      << ' ';
		out << endl
		    << endl
		    << endl;      // end of cell; two newlines, since this
						 // stops continuous drawing
						 // of lines

		break;

	  case 3:
		Assert (false, ExcNotImplemented());
	};
    };
};

      


//explicite instantiations
template class DataIn<1>;
template class DataIn<2>;
template class DataOut<1>;
template class DataOut<2>;
