/* $Id$ */


#include <basic/data_out_base.h>
#include <iomanip>
#include <ctime>



template <int dim>
DataOutBase::Patch::Patch () :
		n_subdivisions (0)
				 // all the rest has a constructor of its own
{};




template <int dim>
void DataOutBase::write_gnuplot (const vector<Patch<dim> > &patches,
				 const vector<string>      &data_names,
				 ostream                   &out) 
{
  const unsigned int n_data_sets = data_names.size();
  
  				   // write preamble
  if (true) 
    {
				       // block this to have local
				       // variables destroyed after
				       // use
      const time_t  time1= time (0);
      const tm     *time = localtime(&time1); 
      out << "# This file was generated by the deal.II library." << endl
	  << "# Date =  "
	  << time->tm_year+1900 << "/"
	  << time->tm_mon+1 << "/"
	  << time->tm_mday << endl
	  << "# Time =  "
	  << time->tm_hour << ":"
	  << setw(2) << time->tm_min << ":"
	  << setw(2) << time->tm_sec << endl
	  << "#" << endl
	  << "# For a description of the GNUPLOT format see the GNUPLOT manual."
	  << endl
	  << "#" << endl
	  << "# ";
      
      switch (dim) 
	{
	  case 1:
		out << "<x> ";
		break;
	  case 2:
		out << "<x> <y> ";
		break;
	  case 3:
		out << "<x> <y> <z> ";
		break;
		
	  default:
		Assert (false, ExcNotImplemented());
	};

      for (unsigned int i=0; i<data_names.size(); ++i)
	out << '<'
	    << data_names[i]
	    << "> ";
      out << endl;      
    };


				   // loop over all patches
  for (typename vector<Patch<dim> >::const_iterator patch=patches.begin();
       patch != patches.end(); ++patch)
    {
      const unsigned int n_subdivisions = patch->n_subdivisions;
      
      Assert (patch->data.m() == n_data_sets,
	      ExcUnexpectedNumberOfDatasets (patch->data.m(), n_data_sets));
      Assert (patch->data.n() == (dim==1 ?
				  n_subdivisions+1 :
				  (dim==2 ?
				   (n_subdivisions+1)*(n_subdivisions+1) :
				   (dim==3 ?
				    (n_subdivisions+1)*(n_subdivisions+1)*(n_subdivisions+1) :
				    0))),
	      ExcInvalidDatasetSize (patch->data.n(), n_subdivisions+1));

      switch (dim)
	{
	  case 1:
	  {      
	    for (unsigned int i=0; i<n_subdivisions+1; ++i) 
	      {
						 // compute coordinates for
						 // this patch point
		out << ((patch->vertices[1] * i / n_subdivisions) +
			(patch->vertices[0] * (n_subdivisions-i) / n_subdivisions))
		    << ' ';

		for (unsigned int data_set=0; data_set<n_data_sets; ++data_set)
		  out << patch->data(data_set,i) << ' ';

		out << endl;
	      };

					     // end of patch
	    out << endl
		<< endl;
	    
	    break;
	  };
	   
	  case 2:
	  {
	    for (unsigned int j=0; j<n_subdivisions+1; ++j) 
	      {
		for (unsigned int i=0; i<n_subdivisions+1; ++i)
		  {
		    const double x_frac = i * 1./n_subdivisions,
				 y_frac = j * 1./n_subdivisions;
		    
						     // compute coordinates for
						     // this patch point
		    out << (((patch->vertices[1] * x_frac) +
			     (patch->vertices[0] * (1-x_frac)) * y_frac) +
			    ((patch->vertices[2] * x_frac) +
			     (patch->vertices[3] * (1-x_frac)) * (1-y_frac)))
			<< ' ';
		    
		    for (unsigned int data_set=0; data_set<n_data_sets; ++data_set)
		      out << patch->data(data_set,j*(n_subdivisions+1) + i) << ' ';

		    out << endl;
		  };

						 // end of row in patch
		out << endl;
	      };

					     // end of patch
	    out << endl;

	    break;
	  };

	  case 3:
	  {
	    Assert (false, ExcNotImplemented());
	  };

	  default:
		Assert (false, ExcNotImplemented());
	};
    };
};





  
// explicit instantiations
template
void DataOutBase::write_gnuplot (const vector<Patch<deal_II_dimension> > &patches,
				 const vector<string>                    &data_names,
				 ostream                                 &out);
template DataOutBase::Patch<deal_II_dimension>::Patch ();
