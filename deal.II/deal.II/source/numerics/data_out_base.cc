/* $Id$ */


#include <basic/data_out_base.h>
#include <iomanip>
#include <ctime>



// egcs does not understand this at present.
//
// template <int dim>
// DataOut::Patch<dim>::Patch () :
// 		n_subdivisions (0)
// 				 // all the rest has a constructor of its own
// {};



DataOutBase::UcdFlags::UcdFlags (const bool write_preamble) :
		write_preamble (write_preamble)
{};




template <int dim>
void DataOutBase::write_ucd (const vector<Patch<dim> > &patches,
			     const vector<string>      &data_names,
			     const UcdFlags            &flags,
			     ostream                   &out) 
{
  AssertThrow (out, ExcIO());

  const unsigned int n_data_sets = data_names.size();
  
				   // first count the number of cells
				   // and cells for later use
  unsigned int n_cells = 0,
	       n_nodes = 0;
  for (vector<Patch<dim> >::const_iterator patch=patches.begin();
       patch!=patches.end(); ++patch)
    switch (dim)
      {
	case 1:
	      n_cells += patch->n_subdivisions;
	      n_nodes += patch->n_subdivisions+1;
	      break;
	case 2:
	      n_cells += patch->n_subdivisions *
			 patch->n_subdivisions;
	      n_nodes += (patch->n_subdivisions+1) *
			 (patch->n_subdivisions+1);
	      break;
	case 3:
	      n_cells += patch->n_subdivisions *
			 patch->n_subdivisions *
			 patch->n_subdivisions;
	      n_nodes += (patch->n_subdivisions+1) *
			 (patch->n_subdivisions+1) *
			 (patch->n_subdivisions+1);
	      break;
	default:
	      Assert (false, ExcNotImplemented());
      };

				   ///////////////////////
				   // preamble
  if (flags.write_preamble)
    {
      time_t  time1= time (0);
      tm     *time = localtime(&time1); 
      out << "# This file was generated by the deal.II library." << endl
	  << "# Date =  "
	  << time->tm_year+1900 << "/"
	  << time->tm_mon+1 << "/"
	  << time->tm_mday << endl
	  << "# Time =  "
	  << time->tm_hour << ":"
	  << setw(2) << time->tm_min << ":"
	  << setw(2) << time->tm_sec << endl
	  << "#" << endl
	  << "# For a description of the UCD format see the AVS Developer's guide."
	  << endl
	  << "#" << endl;
    };

				   // start with ucd data
  out << n_nodes << ' '
      << n_cells << ' '
      << n_data_sets << ' '
      << 0 << ' '                  // no cell data at present
      << 0                         // no model data
      << endl;

				   ///////////////////////////////
				   // first make up the list of used
				   // nodes along with their
				   // coordinates. number them
				   // consecutively starting with 1
				   //
				   // note that we have to print
				   // d=1..3 dimensions
  if (true)
    {
      unsigned int present_node = 1;
      
      for (vector<Patch<dim> >::const_iterator patch=patches.begin();
	   patch!=patches.end(); ++patch)
	{
	  const unsigned int n_subdivisions = patch->n_subdivisions;
	  
					   // if we have nonzero values for
					   // this coordinate
	  switch (dim)
	    {
	      case 1:
	      {
		for (unsigned int i=0; i<n_subdivisions+1; ++i, ++present_node)
		  out << present_node
		      << "   "
		      << ((patch->vertices[1](0) * i / n_subdivisions) +
			  (patch->vertices[0](0) * (n_subdivisions-i) / n_subdivisions))
		      << " 0 0\n";                        // fill with zeroes
		break;
	      };
	       
	      case 2:
	      {
		for (unsigned int i=0; i<n_subdivisions+1; ++i)
		  for (unsigned int j=0; j<n_subdivisions+1; ++j)
		    {
		      const double x_frac = i * 1./n_subdivisions,
				   y_frac = j * 1./n_subdivisions;
		      
						       // compute coordinates for
						       // this patch point
		      out << present_node
			  << "  "
			  << (((patch->vertices[1] * x_frac) +
			       (patch->vertices[0] * (1-x_frac))) * (1-y_frac) +
			      ((patch->vertices[2] * x_frac) +
			       (patch->vertices[3] * (1-x_frac))) * y_frac)
			  << " 0\n";                   // fill with zeroes

		      ++present_node;
		    };
	      
		break;
	      };
	       
	      case 3:
	      {
		for (unsigned int i=0; i<n_subdivisions+1; ++i)
		  for (unsigned int j=0; j<n_subdivisions+1; ++j)
		    for (unsigned int k=0; k<n_subdivisions+1; ++k)
		      {
							 // note the broken
							 // design of hexahedra
							 // in deal.II, where
							 // first the z-component
							 // is counted up, before
							 // increasing the y-
							 // coordinate
			const double x_frac = i * 1./n_subdivisions,
				     y_frac = k * 1./n_subdivisions,
				     z_frac = j * 1./n_subdivisions;
			
							 // compute coordinates for
							 // this patch point
			out << present_node
			    << "  "
			    << ((((patch->vertices[1] * x_frac) +
				  (patch->vertices[0] * (1-x_frac))) * (1-y_frac) +
				 ((patch->vertices[2] * x_frac) +
				  (patch->vertices[3] * (1-x_frac))) * y_frac)   * (1-z_frac) +
				(((patch->vertices[5] * x_frac) +
				  (patch->vertices[4] * (1-x_frac))) * (1-y_frac) +
				 ((patch->vertices[6] * x_frac) +
				  (patch->vertices[7] * (1-x_frac))) * y_frac)   * z_frac)
			    << endl;
			
			++present_node;
		      };
	      
		break;
	      };
	       
	      default:
		    Assert (false, ExcNotImplemented());
	    };
	};

				       // note that we number starting with 1!
      Assert (present_node == n_nodes+1,
	      ExcInternalError());
    };

				   /////////////////////////////////////////
				   // write cell. number them consecutively,
				   // starting with 1
  if (true)
    {
      unsigned int present_cell = 1;      
      unsigned int first_vertex_of_patch = 0;
      
      for (vector<Patch<dim> >::const_iterator patch=patches.begin();
	   patch!=patches.end(); ++patch)
	{
	  const unsigned int n_subdivisions = patch->n_subdivisions;
	  
					   // write out the cells making
					   // up this patch
	  switch (dim)
	    {
	      case 1:
	      {
		for (unsigned int i=0; i<n_subdivisions; ++i, ++present_cell)
		  out << present_cell
		      << " 0  line  "        // set material id to 0
		      << first_vertex_of_patch+i+1 << ' '
		      << first_vertex_of_patch+i+1+1 << endl;
		break;
	      };
	       
	      case 2:
	      {
		for (unsigned int i=0; i<n_subdivisions; ++i)
		  for (unsigned int j=0; j<n_subdivisions; ++j)
		    {
		      out << present_cell
			  << " 0  quad  "    // set material id to 0
			  << first_vertex_of_patch+i*(n_subdivisions+1)+j+1 << ' '
			  << first_vertex_of_patch+(i+1)*(n_subdivisions+1)+j+1 << ' '
			  << first_vertex_of_patch+(i+1)*(n_subdivisions+1)+j+1+1 << ' '
			  << first_vertex_of_patch+i*(n_subdivisions+1)+j+1+1
			  << endl;
		      ++present_cell;
		    };
		break;
	      };
	       
	      case 3:
	      {
		for (unsigned int i=0; i<n_subdivisions; ++i)
		  for (unsigned int j=0; j<n_subdivisions; ++j)
		    for (unsigned int k=0; k<n_subdivisions; ++k)
		      {
			out << present_cell
			    << " 0  hex  "    // set material id to 0
							   // note: vertex indices start with 1!
			    << first_vertex_of_patch+(i*(n_subdivisions+1)+j      )*(n_subdivisions+1)+k  +1 << ' '
			    << first_vertex_of_patch+((i+1)*(n_subdivisions+1)+j  )*(n_subdivisions+1)+k  +1 << ' '
			    << first_vertex_of_patch+((i+1)*(n_subdivisions+1)+j+1)*(n_subdivisions+1)+k  +1 << ' '
			    << first_vertex_of_patch+(i*(n_subdivisions+1)+j+1    )*(n_subdivisions+1)+k  +1 << ' '
			    << first_vertex_of_patch+(i*(n_subdivisions+1)+j      )*(n_subdivisions+1)+k+1+1 << ' '
			    << first_vertex_of_patch+((i+1)*(n_subdivisions+1)+j  )*(n_subdivisions+1)+k+1+1 << ' '
			    << first_vertex_of_patch+((i+1)*(n_subdivisions+1)+j+1)*(n_subdivisions+1)+k+1+1 << ' '
			    << first_vertex_of_patch+(i*(n_subdivisions+1)+j+1    )*(n_subdivisions+1)+k+1+1 << ' '
			    << endl;
			++present_cell;
		      };
		break;
	      };

	      default:
		    Assert (false, ExcNotImplemented());
	    };
	  
	  
					   // finally update the number
					   // of the first vertex of this patch
	  switch (dim)
	    {
	      case 1:
		    first_vertex_of_patch += n_subdivisions+1;
		    break;
	      case 2:
		    first_vertex_of_patch += (n_subdivisions+1) *
					     (n_subdivisions+1);
		    break;
	      case 3:
		    first_vertex_of_patch += (n_subdivisions+1) *
					     (n_subdivisions+1) *
					     (n_subdivisions+1);
		    break;
	      default:
		    Assert (false, ExcNotImplemented());
	    };
	};
      out << endl;

				       // note that we number starting with 1!
      Assert (present_cell == n_cells+1,
	      ExcInternalError());
    };


				   /////////////////////////////
				   // now write data
  if (n_data_sets != 0)
    {      
      out << n_data_sets << "    ";    // number of vectors
      for (unsigned int i=0; i<n_data_sets; ++i)
	out << 1 << ' ';               // number of components;
				       // only 1 supported presently
      out << endl;

      for (unsigned int data_set=0; data_set<n_data_sets; ++data_set)
	out << data_names[data_set]
	    << ",dimensionless"      // no units supported at present
	    << endl;
      
      
				       // loop over all patches
      unsigned int present_node = 1;
      for (typename vector<Patch<dim> >::const_iterator patch=patches.begin();
	   patch != patches.end(); ++patch)
	{
	  const unsigned int n_subdivisions = patch->n_subdivisions;
      
	  Assert (patch->data.m() == n_data_sets,
		  ExcUnexpectedNumberOfDatasets (patch->data.m(), n_data_sets));
	  Assert (patch->data.n() == (dim==1 ?
				      n_subdivisions+1 :
				      (dim==2 ?
				       (n_subdivisions+1)*(n_subdivisions+1) :
				       (dim==3 ?
					(n_subdivisions+1)*(n_subdivisions+1)*(n_subdivisions+1) :
					0))),
		  ExcInvalidDatasetSize (patch->data.n(), n_subdivisions+1));

	  switch (dim)
	    {
	      case 1:
	      {      
		for (unsigned int i=0; i<n_subdivisions+1; ++i, ++present_node) 
		  {
		    out << present_node
			<< "  ";
		    for (unsigned int data_set=0; data_set<n_data_sets; ++data_set)
		      out << patch->data(data_set,i) << ' ';

		    out << endl;
		  };
	    
		break;
	      };
	   
	      case 2:
	      {
		for (unsigned int i=0; i<n_subdivisions+1; ++i)
		  for (unsigned int j=0; j<n_subdivisions+1; ++j)
		    {
		      out << present_node
			  << "  ";
		      for (unsigned int data_set=0; data_set<n_data_sets; ++data_set)
			out << patch->data(data_set,i*(n_subdivisions+1) + j) << ' ';

		      out << endl;

		      ++present_node;
		    };

		break;
	      };

	      case 3:
	      {
		for (unsigned int i=0; i<n_subdivisions+1; ++i)
		  for (unsigned int j=0; j<n_subdivisions+1; ++j)
		    for (unsigned int k=0; k<n_subdivisions+1; ++k)
		      {
			out << present_node
			    << "  ";
			for (unsigned int data_set=0; data_set<n_data_sets; ++data_set)
			  out << patch->data(data_set,
					     (i*(n_subdivisions+1)+j)*(n_subdivisions+1)+k)
			      << ' ';
			
			out << endl;
			
			++present_node;
		      };

		break;
	      };

	      default:
		    Assert (false, ExcNotImplemented());
	    };
	};  
    };

				   // no model data

				   // assert the stream is still ok
  AssertThrow (out, ExcIO());
};



template <int dim>
void DataOutBase::write_gnuplot (const vector<Patch<dim> > &patches,
				 const vector<string>      &data_names,
				 const GnuplotFlags        &/*flags*/,
				 ostream                   &out) 
{
  AssertThrow (out, ExcIO());
  
  const unsigned int n_data_sets = data_names.size();
  
  				   // write preamble
  if (true) 
    {
				       // block this to have local
				       // variables destroyed after
				       // use
      const time_t  time1= time (0);
      const tm     *time = localtime(&time1); 
      out << "# This file was generated by the deal.II library." << endl
	  << "# Date =  "
	  << time->tm_year+1900 << "/"
	  << time->tm_mon+1 << "/"
	  << time->tm_mday << endl
	  << "# Time =  "
	  << time->tm_hour << ":"
	  << setw(2) << time->tm_min << ":"
	  << setw(2) << time->tm_sec << endl
	  << "#" << endl
	  << "# For a description of the GNUPLOT format see the GNUPLOT manual."
	  << endl
	  << "#" << endl
	  << "# ";
      
      switch (dim) 
	{
	  case 1:
		out << "<x> ";
		break;
	  case 2:
		out << "<x> <y> ";
		break;
	  case 3:
		out << "<x> <y> <z> ";
		break;
		
	  default:
		Assert (false, ExcNotImplemented());
	};

      for (unsigned int i=0; i<data_names.size(); ++i)
	out << '<'
	    << data_names[i]
	    << "> ";
      out << endl;      
    };


				   // loop over all patches
  for (typename vector<Patch<dim> >::const_iterator patch=patches.begin();
       patch != patches.end(); ++patch)
    {
      const unsigned int n_subdivisions = patch->n_subdivisions;
      
      Assert (patch->data.m() == n_data_sets,
	      ExcUnexpectedNumberOfDatasets (patch->data.m(), n_data_sets));
      Assert (patch->data.n() == (dim==1 ?
				  n_subdivisions+1 :
				  (dim==2 ?
				   (n_subdivisions+1)*(n_subdivisions+1) :
				   (dim==3 ?
				    (n_subdivisions+1)*(n_subdivisions+1)*(n_subdivisions+1) :
				    0))),
	      ExcInvalidDatasetSize (patch->data.n(), n_subdivisions+1));

      switch (dim)
	{
	  case 1:
	  {      
	    for (unsigned int i=0; i<n_subdivisions+1; ++i) 
	      {
						 // compute coordinates for
						 // this patch point
		out << ((patch->vertices[1] * i / n_subdivisions) +
			(patch->vertices[0] * (n_subdivisions-i) / n_subdivisions))
		    << ' ';

		for (unsigned int data_set=0; data_set<n_data_sets; ++data_set)
		  out << patch->data(data_set,i) << ' ';

		out << endl;
	      };

					     // end of patch
	    out << endl
		<< endl;
	    
	    break;
	  };
	   
	  case 2:
	  {
	    for (unsigned int i=0; i<n_subdivisions+1; ++i)
	      {
		for (unsigned int j=0; j<n_subdivisions+1; ++j)
		  {
		    const double x_frac = i * 1./n_subdivisions,
				 y_frac = j * 1./n_subdivisions;
		    
						     // compute coordinates for
						     // this patch point
		    out << (((patch->vertices[1] * x_frac) +
			     (patch->vertices[0] * (1-x_frac))) * (1-y_frac) +
			    ((patch->vertices[2] * x_frac) +
			     (patch->vertices[3] * (1-x_frac))) * y_frac)
			<< ' ';
		    
		    for (unsigned int data_set=0; data_set<n_data_sets; ++data_set)
		      out << patch->data(data_set,i*(n_subdivisions+1) + j) << ' ';

		    out << endl;
		  };

						 // end of row in patch
		out << endl;
	      };

					     // end of patch
	    out << endl;

	    break;
	  };

	  case 3:
	  {
					     // for all grid points: draw
					     // lines into all positive
					     // coordinate directions if
					     // there is another grid point
					     // there
	    for (unsigned int i=0; i<n_subdivisions+1; ++i)
	      for (unsigned int j=0; j<n_subdivisions+1; ++j)
		for (unsigned int k=0; k<n_subdivisions+1; ++k)
		  {
						     // note the broken
						     // design of hexahedra
						     // in deal.II, where
						     // first the z-component
						     // is counted up, before
						     // increasing the y-
						     // coordinate
		    const double x_frac = i * 1./n_subdivisions,
				 y_frac = k * 1./n_subdivisions,
				 z_frac = j * 1./n_subdivisions;

						     // compute coordinates for
						     // this patch point
		    const Point<dim> this_point
		      = ((((patch->vertices[1] * x_frac) +
			   (patch->vertices[0] * (1-x_frac))) * (1-y_frac) +
			  ((patch->vertices[2] * x_frac) +
			   (patch->vertices[3] * (1-x_frac))) * y_frac)   * (1-z_frac) +
			 (((patch->vertices[5] * x_frac) +
			   (patch->vertices[4] * (1-x_frac))) * (1-y_frac) +
			  ((patch->vertices[6] * x_frac) +
			   (patch->vertices[7] * (1-x_frac))) * y_frac)   * z_frac);

						     // line into positive x-direction
						     // if possible
		    if (i < n_subdivisions)
		      {
							 // write point here
							 // and its data
			out << this_point;
			for (unsigned int data_set=0; data_set<n_data_sets; ++data_set)
			  out  << ' '
			       << patch->data(data_set,
					      (i*(n_subdivisions+1) + j)*(n_subdivisions+1)+k);
			out << endl;
			
							 // write point there
							 // and its data
			const double x_frac_new = x_frac + 1./n_subdivisions;
			out << ((((patch->vertices[1] * x_frac_new) +
				  (patch->vertices[0] * (1-x_frac_new))) * (1-y_frac) +
				 ((patch->vertices[2] * x_frac_new) +
				  (patch->vertices[3] * (1-x_frac_new))) * y_frac)   * (1-z_frac) +
				(((patch->vertices[5] * x_frac_new) +
				  (patch->vertices[4] * (1-x_frac_new))) * (1-y_frac) +
				 ((patch->vertices[6] * x_frac_new) +
				  (patch->vertices[7] * (1-x_frac_new))) * y_frac)   * z_frac);
			for (unsigned int data_set=0; data_set<n_data_sets; ++data_set)
			  out  << ' '
			       << patch->data(data_set,
					      ((i+1)*(n_subdivisions+1) + j)*(n_subdivisions+1)+k);
			out << endl;

							 // end of line
			out << endl
			    << endl;
		      };
		    
						     // line into positive y-direction
						     // if possible
		    if (j < n_subdivisions)
		      {
							 // write point here
							 // and its data
			out << this_point;
			for (unsigned int data_set=0; data_set<n_data_sets; ++data_set)
			  out  << ' '
			       << patch->data(data_set,
					      (i*(n_subdivisions+1) + j)*(n_subdivisions+1)+k);
			out << endl;
			
							 // write point there
							 // and its data
			const double z_frac_new = z_frac + 1./n_subdivisions;
			out << ((((patch->vertices[1] * x_frac) +
				  (patch->vertices[0] * (1-x_frac))) * (1-y_frac) +
				 ((patch->vertices[2] * x_frac) +
				  (patch->vertices[3] * (1-x_frac))) * y_frac)   * (1-z_frac_new) +
				(((patch->vertices[5] * x_frac) +
				  (patch->vertices[4] * (1-x_frac))) * (1-y_frac) +
				 ((patch->vertices[6] * x_frac) +
				  (patch->vertices[7] * (1-x_frac))) * y_frac)   * z_frac_new);
			for (unsigned int data_set=0; data_set<n_data_sets; ++data_set)
			  out  << ' '
			       << patch->data(data_set,
					      (i*(n_subdivisions+1) + (j+1))*(n_subdivisions+1)+k);
			out << endl;

							 // end of line
			out << endl
			    << endl;
		      };

						     // line into positive z-direction
						     // if possible
		    if (k < n_subdivisions)
		      {
							 // write point here
							 // and its data
			out << this_point;
			for (unsigned int data_set=0; data_set<n_data_sets; ++data_set)
			  out  << ' '
			       << patch->data(data_set,
					      (i*(n_subdivisions+1) + j)*(n_subdivisions+1)+k);
			out << endl;
			
							 // write point there
							 // and its data
			const double y_frac_new = y_frac + 1./n_subdivisions;
			out << ((((patch->vertices[1] * x_frac) +
				  (patch->vertices[0] * (1-x_frac))) * (1-y_frac_new) +
				 ((patch->vertices[2] * x_frac) +
				  (patch->vertices[3] * (1-x_frac))) * y_frac_new)   * (1-z_frac) +
				(((patch->vertices[5] * x_frac) +
				  (patch->vertices[4] * (1-x_frac))) * (1-y_frac_new) +
				 ((patch->vertices[6] * x_frac) +
				  (patch->vertices[7] * (1-x_frac))) * y_frac_new)   * z_frac);
			for (unsigned int data_set=0; data_set<n_data_sets; ++data_set)
			  out  << ' '
			       << patch->data(data_set,
					      (i*(n_subdivisions+1) + j)*(n_subdivisions+1)+k+1);
			out << endl;

							 // end of line
			out << endl
			    << endl;
		      };		    
			
		  };

	    break;
	  };

	  default:
		Assert (false, ExcNotImplemented());
	};
    };

  AssertThrow (out, ExcIO());
};



template <int dim>
void DataOutBase::write_povray (const vector<Patch<dim> > &/*patches*/,
				const vector<string>      &/*data_names*/,
				const PovrayFlags         &/*flags*/,
				ostream                   &/*out*/) 
{
  Assert (false, ExcNotImplemented());
};



template <int dim>
void DataOutBase::write_eps (const vector<Patch<dim> > &/*patches*/,
			     const vector<string>      &/*data_names*/,
			     const EpsFlags            &/*flags*/,
			     ostream                   &/*out*/) 
{
  Assert (false, ExcNotImplemented());
};



template <int dim>
void DataOutBase::write_gmv (const vector<Patch<dim> > &patches,
			     const vector<string>      &data_names,
			     const GmvFlags            &/*flags*/,
			     ostream                   &out) 
{
  AssertThrow (out, ExcIO());

  const unsigned int n_data_sets = data_names.size();
  
				   ///////////////////////
				   // preamble
  out << "gmvinput ascii"
      << endl
      << endl;

				   // first count the number of cells
				   // and cells for later use
  unsigned int n_cells = 0,
	       n_nodes = 0;
  for (vector<Patch<dim> >::const_iterator patch=patches.begin();
       patch!=patches.end(); ++patch)
    switch (dim)
      {
	case 1:
	      n_cells += patch->n_subdivisions;
	      n_nodes += patch->n_subdivisions+1;
	      break;
	case 2:
	      n_cells += patch->n_subdivisions *
			 patch->n_subdivisions;
	      n_nodes += (patch->n_subdivisions+1) *
			 (patch->n_subdivisions+1);
	      break;
	case 3:
	      n_cells += patch->n_subdivisions *
			 patch->n_subdivisions *
			 patch->n_subdivisions;
	      n_nodes += (patch->n_subdivisions+1) *
			 (patch->n_subdivisions+1) *
			 (patch->n_subdivisions+1);
	      break;
	default:
	      Assert (false, ExcNotImplemented());
      };


				   ///////////////////////////////
				   // first make up a list of used
				   // vertices along with their
				   // coordinates
				   //
				   // note that we have to print
				   // d=1..3 dimensions
  out << "nodes " << n_nodes << endl;
  for (unsigned int d=1; d<=3; ++d)
    {
      for (vector<Patch<dim> >::const_iterator patch=patches.begin();
	   patch!=patches.end(); ++patch)
	{
	  const unsigned int n_subdivisions = patch->n_subdivisions;
	  
					   // if we have nonzero values for
					   // this coordinate
	  if (d<=dim)
	    {
	      switch (dim)
		{
		  case 1:
		  {
		    for (unsigned int i=0; i<n_subdivisions+1; ++i)
		      out << ((patch->vertices[1](0) * i / n_subdivisions) +
			      (patch->vertices[0](0) * (n_subdivisions-i) / n_subdivisions))
			  << ' ';
		    break;
		  };
		   
		  case 2:
		  {
		    for (unsigned int i=0; i<n_subdivisions+1; ++i)
		      for (unsigned int j=0; j<n_subdivisions+1; ++j)
			{
			  const double x_frac = i * 1./n_subdivisions,
				       y_frac = j * 1./n_subdivisions;
			  
							   // compute coordinates for
							   // this patch point
			  out << (((patch->vertices[1](d-1) * x_frac) +
				   (patch->vertices[0](d-1) * (1-x_frac))) * (1-y_frac) +
				  ((patch->vertices[2](d-1) * x_frac) +
				   (patch->vertices[3](d-1) * (1-x_frac))) * y_frac)
			      << ' ';
			};
		    break;
		  };
		   
		  case 3:
		  {
		    for (unsigned int i=0; i<n_subdivisions+1; ++i)
		      for (unsigned int j=0; j<n_subdivisions+1; ++j)
			for (unsigned int k=0; k<n_subdivisions+1; ++k)
			  {
							     // note the broken
							     // design of hexahedra
							     // in deal.II, where
							     // first the z-component
							     // is counted up, before
							     // increasing the y-
							     // coordinate
			    const double x_frac = i * 1./n_subdivisions,
					 y_frac = k * 1./n_subdivisions,
					 z_frac = j * 1./n_subdivisions;
			    
							     // compute coordinates for
							     // this patch point
			    out << ((((patch->vertices[1](d-1) * x_frac) +
				      (patch->vertices[0](d-1) * (1-x_frac))) * (1-y_frac) +
				     ((patch->vertices[2](d-1) * x_frac) +
				      (patch->vertices[3](d-1) * (1-x_frac))) * y_frac)   * (1-z_frac) +
				    (((patch->vertices[5](d-1) * x_frac) +
				      (patch->vertices[4](d-1) * (1-x_frac))) * (1-y_frac) +
				     ((patch->vertices[6](d-1) * x_frac) +
				      (patch->vertices[7](d-1) * (1-x_frac))) * y_frac)   * z_frac)
				<< ' ';
			  };
	      
		    break;
		  };
		   
		  default:
			Assert (false, ExcNotImplemented());
		};
	    }
	  else
					     // d>dim. write zeros instead
	    {
	      const unsigned int n_points = (dim==1 ?
					     n_subdivisions+1 :
					     (dim==2 ?
					      (n_subdivisions+1) * (n_subdivisions+1) :
					      (dim == 3 ?
					       (n_subdivisions+1) * (n_subdivisions+1) * (n_subdivisions+1) :
					       0)));
	      for (unsigned int i=0; i<n_points; ++i)
		out << "0 ";
	    };
	};
      out << endl;
    };

  out << endl;

				   /////////////////////////////////
				   // now for the cells. note that
				   // vertices are counted from 1 onwards
  if (true)
    {
      out << "cells " << n_cells << endl;
      
	
      unsigned int first_vertex_of_patch = 0;
      
      for (vector<Patch<dim> >::const_iterator patch=patches.begin();
	   patch!=patches.end(); ++patch)
	{
	  const unsigned int n_subdivisions = patch->n_subdivisions;

					   // write out the cells making
					   // up this patch
	  switch (dim)
	    {
	      case 1:
	      {
		for (unsigned int i=0; i<n_subdivisions; ++i)
		  out << "line 2\n  "
		      << first_vertex_of_patch+i+1 << ' '
		      << first_vertex_of_patch+i+1+1 << endl;
		break;
	      };
	       
	      case 2:
	      {
		for (unsigned int i=0; i<n_subdivisions; ++i)
		  for (unsigned int j=0; j<n_subdivisions; ++j)
		    out << "quad 4\n  "
			<< first_vertex_of_patch+i*(n_subdivisions+1)+j+1 << ' '
			<< first_vertex_of_patch+(i+1)*(n_subdivisions+1)+j+1 << ' '
			<< first_vertex_of_patch+(i+1)*(n_subdivisions+1)+j+1+1 << ' '
			<< first_vertex_of_patch+i*(n_subdivisions+1)+j+1+1
			<< endl;
		break;
	      };
	       
	      case 3:
	      {
		for (unsigned int i=0; i<n_subdivisions; ++i)
		  for (unsigned int j=0; j<n_subdivisions; ++j)
		    for (unsigned int k=0; k<n_subdivisions; ++k)
		      {
			out << "hex 8\n   "
							   // note: vertex indices start with 1!
			    << first_vertex_of_patch+(i*(n_subdivisions+1)+j      )*(n_subdivisions+1)+k  +1 << ' '
			    << first_vertex_of_patch+((i+1)*(n_subdivisions+1)+j  )*(n_subdivisions+1)+k  +1 << ' '
			    << first_vertex_of_patch+((i+1)*(n_subdivisions+1)+j+1)*(n_subdivisions+1)+k  +1 << ' '
			    << first_vertex_of_patch+(i*(n_subdivisions+1)+j+1    )*(n_subdivisions+1)+k  +1 << ' '
			    << first_vertex_of_patch+(i*(n_subdivisions+1)+j      )*(n_subdivisions+1)+k+1+1 << ' '
			    << first_vertex_of_patch+((i+1)*(n_subdivisions+1)+j  )*(n_subdivisions+1)+k+1+1 << ' '
			    << first_vertex_of_patch+((i+1)*(n_subdivisions+1)+j+1)*(n_subdivisions+1)+k+1+1 << ' '
			    << first_vertex_of_patch+(i*(n_subdivisions+1)+j+1    )*(n_subdivisions+1)+k+1+1 << ' '
			    << endl;
		      };
		break;
	      };

	      default:
		    Assert (false, ExcNotImplemented());
	    };
	  
	  
					   // finally update the number
					   // of the first vertex of this patch
	  switch (dim)
	    {
	      case 1:
		    first_vertex_of_patch += n_subdivisions+1;
		    break;
	      case 2:
		    first_vertex_of_patch += (n_subdivisions+1) *
					     (n_subdivisions+1);
		    break;
	      case 3:
		    first_vertex_of_patch += (n_subdivisions+1) *
					     (n_subdivisions+1) *
					     (n_subdivisions+1);
		    break;
	      default:
		    Assert (false, ExcNotImplemented());
	    };
	};
      out << endl;
    };

				   ///////////////////////////////////////
				   // data output.
  out << "variable" << endl;

				   // since here as with the vertex
				   // coordinates the order is a bit
				   // unpleasant (first all data of
				   // variable 1, then variable 2, etc)
				   // we have to copy them a bit around
				   //
				   // note that we copy vectors when
				   // looping over the patches since we
				   // have to write them one variable
				   // at a time and don't want to use
				   // more than one loop
  if (true)
    {
      vector<vector<double> > data_vectors (n_data_sets,
					    vector<double> (n_nodes));
				       // loop over all patches
      unsigned int next_value = 0;
      for (typename vector<Patch<dim> >::const_iterator patch=patches.begin();
	   patch != patches.end(); ++patch)
	{
	  const unsigned int n_subdivisions = patch->n_subdivisions;
	  
	  Assert (patch->data.m() == n_data_sets,
		  ExcUnexpectedNumberOfDatasets (patch->data.m(), n_data_sets));
	  Assert (patch->data.n() == (dim==1 ?
				      n_subdivisions+1 :
				      (dim==2 ?
				       (n_subdivisions+1)*(n_subdivisions+1) :
				       (dim==3 ?
					(n_subdivisions+1)*(n_subdivisions+1)*(n_subdivisions+1) :
					0))),
		  ExcInvalidDatasetSize (patch->data.n(), n_subdivisions+1));
	  
	  switch (dim)
	    {
	      case 1:
	      {      
		for (unsigned int i=0; i<n_subdivisions+1; ++i, ++next_value) 
		  for (unsigned int data_set=0; data_set<n_data_sets; ++data_set)
		    data_vectors[data_set][next_value] = patch->data(data_set,i);
		
		break;
	      };
		     
	      case 2:
	      {
		for (unsigned int i=0; i<n_subdivisions+1; ++i)
		  for (unsigned int j=0; j<n_subdivisions+1; ++j)
		    {
		      for (unsigned int data_set=0; data_set<n_data_sets; ++data_set)
			data_vectors[data_set][next_value]
			  = patch->data(data_set,i*(n_subdivisions+1) + j);
		      ++next_value;
		    };
		
		break;
	      };
	       
	      case 3:
	      {
		for (unsigned int i=0; i<n_subdivisions+1; ++i)
		  for (unsigned int j=0; j<n_subdivisions+1; ++j)
		    for (unsigned int k=0; k<n_subdivisions+1; ++k)
		      {
			for (unsigned int data_set=0; data_set<n_data_sets; ++data_set)
			  data_vectors[data_set][next_value]
			    = patch->data(data_set,
					  (i*(n_subdivisions+1)+j)*(n_subdivisions+1)+k);
			++next_value;
		      };

		break;
	      };
	       
	      default:
		    Assert (false, ExcNotImplemented());
	    };
	};

				       // now write the data vectors to #out#
				       // the '1' means: node data (as opposed
				       // to cell data, which we do not
				       // support explicitely here)
      for (unsigned int data_set=0; data_set<n_data_sets; ++data_set)
	{
	  out << data_names[data_set] << " 1" << endl;
	  copy(data_vectors[data_set].begin(),
	       data_vectors[data_set].end(),
	       ostream_iterator<double>(out, " "));
	  out << endl
	      << endl;
	};
    };
  
  
				   // end of variable section
  out << "endvars" << endl;
  
				   // end of output
  out << "endgmv"
      << endl;
  
				   // assert the stream is still ok
  AssertThrow (out, ExcIO());
};





/* --------------------------- class DataOutInterface ---------------------- */


template <int dim>
void DataOutInterface<dim>::write_ucd (ostream &out) const 
{
  DataOutBase::write_ucd (get_patches(), get_dataset_names(),
			  ucd_flags, out);
};



template <int dim>
void DataOutInterface<dim>::write_gnuplot (ostream &out) const 
{
  DataOutBase::write_gnuplot (get_patches(), get_dataset_names(),
			      gnuplot_flags, out);
};



template <int dim>
void DataOutInterface<dim>::write_povray (ostream &out) const 
{
  DataOutBase::write_povray (get_patches(), get_dataset_names(),
			     povray_flags, out);
};



template <int dim>
void DataOutInterface<dim>::write_eps (ostream &out) const 
{
  DataOutBase::write_eps (get_patches(), get_dataset_names(),
			  eps_flags, out);
};



template <int dim>
void DataOutInterface<dim>::write_gmv (ostream &out) const 
{
  DataOutBase::write_gmv (get_patches(), get_dataset_names(),
			  gmv_flags, out);
};



template <int dim>
void DataOutInterface<dim>::write (ostream &out,
				   const OutputFormat output_format) const {
  switch (output_format) 
    {
      case ucd:
	    write_ucd (out);
	    break;
	    
      case gnuplot:
	    write_gnuplot (out);
	    break;
	    
      case povray:
	    write_povray (out);
	    break;
	    
      case eps:
	    write_eps(out);
	    break;
	    
      case gmv:
	    write_gmv (out);
	    break;
	    
      default:
	    Assert (false, ExcNotImplemented());
    };
};



template <int dim>
void DataOutInterface<dim>::set_flags (const UcdFlags &flags) 
{
  ucd_flags = flags;
};



template <int dim>
void DataOutInterface<dim>::set_flags (const GnuplotFlags &flags) 
{
  gnuplot_flags = flags;
};



template <int dim>
void DataOutInterface<dim>::set_flags (const PovrayFlags &flags) 
{
  povray_flags = flags;
};



template <int dim>
void DataOutInterface<dim>::set_flags (const EpsFlags &flags) 
{
  eps_flags = flags;
};



template <int dim>
void DataOutInterface<dim>::set_flags (const GmvFlags &flags) 
{
  gmv_flags = flags;
};



template <int dim>
string DataOutInterface<dim>::default_suffix (const OutputFormat output_format) 
{
  switch (output_format) 
    {
      case ucd:
	    return ".inp";
	    
      case gnuplot: 
	    return ".gnuplot";
	    
      case povray: 
	    return ".pov";
	    
      case eps: 
	    return ".eps";

      case gmv:
	    return ".gmv";
	    
      default: 
	    Assert (false, ExcNotImplemented()); 
	    return "";
    };
};
  


template <int dim>
DataOutInterface<dim>::OutputFormat
DataOutInterface<dim>::parse_output_format (const string &format_name) {
  if (format_name == "ucd")
    return ucd;

  if (format_name == "gnuplot")
    return gnuplot;

  if (format_name == "povray")
    return povray;

  if (format_name == "eps")
    return eps;

  if (format_name == "gmv")
    return gmv;
  
  AssertThrow (false, ExcInvalidState ());

				   // return something invalid
  return OutputFormat(-1);
};



template <int dim>
string DataOutInterface<dim>::get_output_format_names () {
  return "ucd|gnuplot|povray|eps|gmv";
};





  
// explicit instantiations. functions in DataOutBase are instantiated by
// the respective functions in DataOut_Interface
template class DataOutInterface<deal_II_dimension>;
