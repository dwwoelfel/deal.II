=================================================================
====== Things to be done for the deal.II library ================
=================================================================

Remove the comment signs in the monitor_* functions in tria.cc
  as early as possible. These were inserted, since at home the
  program did some strange things in the reserve_memory
  functions (allocated more memory than told), such that the
  memory checks failed.


Write monitors to control whether enough memory was allocated for
  the vectors (i.e. after a process, whether size()==capacity()).
  (for DoF)


Write Triangulation::mesh_function.


Unify CellAccessor<1> and <2> by renaming
    LineAccessor<dim> -> SubstructAccessor<dim,1>
    QuadAccessor<dim> -> SubstructAccessor<dim,2>
  and deriving CellAccessor<dim> from SubstructAccessor<dim,dim>
  Do the same with DoFLineAccessor and DoFQuadAccessor
  

Remove gcc2.8 workaround with DoFSubstructAccessor for general <dim>


Check usage of vector<>s: functions should assume that the objects have
  the right size already.


Update DoFHandler::distribute_cell_to_dof_vector for higher order
  elements (it can presently only handle elements with the only dofs
  on the vertices).


Remove FiniteElementData<>::operator == and let it be generated
  implicitely.


Look at the fill_fe_values functions for possible optimizations
  since this is one of the most often called functions.


Change <iostream> to <ostream> in grid/point.h and
  grid/tria_iterator.h when this becomes possible.


Fill in docs for the timer class. Hopefully finally find a way to
  let it measure times larger than half an hour.


Use a correct strategy to output the reduction rate for adaptively
  refined grids in examples/error-estimation


In VectorTools::project_boundary_values, no condensation of sparsity
  structures, matrices and right hand sides or distribution of
  solution vectors is performed. This is ok for dim<3 because then
  there are no constrained nodes on the boundary, but is not
  acceptable for higher dimensions. Fix this.


Re-enable printing of a preamble to ucd files in data_io.cc. This
  was disabled because DEALVISION couldn't handle these.


Triangulation prepare_* functions:
  Document that multiple loops of preparation for refinement and
  coarsening do not interact, so smoothing may only be optimal if
  #prepare_*# are called intermittently until nothing more changed.

  Document the behaviour of #prepare_*# and of the return value.


Check all places where condensation of matrices/vectors and
  application of boundary values takes place. I am not sure about
  the right order in which they have to be applied, but in 2D there
  is no difference since constrained dofs cannot be on the boundary.
  Problems with the order will therefore not show up in 2D but may
  become apparent in 3D, so keep this in mind for the implementation
  of the 3D library.


Revert istrstream(p.c_str()) to istrstream(p) when possible
  (parameter_handler.cc)


Fully implement the POVRAY format, i.e. use textures, a better angle
  of view, etc. The present implementation is only a rudimentary hack.


Remove the workaround with the BoundaryHelper class which was
  introduced to work around a problem in the egcs-19980803 snapshot
  (previous ones worked flawless)


Check the pattern matching in the parameter handler module using
  the C++ exception handling mechanism rather than Asserts, since
  this should be on also when debug mode is off.


I suppose the [mg_]get_dof_values really belongs to the
  [MG]Line/QuadAccessor classes, but now it is in the
  [MG]CellAccessor. Correct this some time.


FeValues: add flexibility for update flags


No support points for non-Lagrangian elements? Check for Langrange in
interpolation?


Implement the random distortion in Triangulation for hanging nodes
  also. Hanging nodes need to be reset to the correct mean value
  at the end, which is simple for 2D but difficult for 3D. Maybe take
  a look at how we get to the original location of the point in the
  execute_refinement function and copy the relevant lines.


Review DoFCellAccessor<dim>::get_interpolated_dof_values: it may be
  necessary to write not the non-zero values, but those for which
  the corresponding row of the transfer (restriction) matrix
  has nonzero entries. This also catches those zeroes which should
  really be written but are not because the nodal value was zero.


Add tests in Triangulation<3>::create_triangulation for faces (quads)
  which are entered twice: once and once again in a rotated or
  mirrored direction.


Implement boundary information for Triangulation<3>::create_triangulation


Better estimates for DoFHandler<3>::max_couplings_between_dofs


Check optimized code with -Winline and act accordingly. Unfortunately,
  most warnings are from the STL.


Look at the hyper-L and hyper-ball code in 3d. I suspect the cubes are
  turned inside out, but I haven't the time right now to look at this.
  The hypercube is fixed, however.


Change the vector<int> in 'void DoFQuadAccessor::get_dof_indices(
	vector<int> &dof_indices) const' in a vector<unsigned int> and
	catch the Error dof_index==-1 inside of this function


Remove that pseudo-template clutter in the lower parts of
        dof_accessor.[templates.]cc marked by comments.


Remove the flag -fno-vtable-thunks if egcs's bug is removed someday.


Add support for MGTransferPrebuilt and MGSmoother if a user wants
  to solve exactly on another than the coarsest grid. In this case,
  some matrices and other arrays need not be computed.


Unify lots of code of the two Cuthill-McKee dof renumbering functions
  in numerics/dof_renumbering.cc. This should be rather
  straightforward, since all the unified code needs to get is a
  sparsity structure, possibly compressed and return a vector
  of numbers. Simple task.


Maybe single out the epsgrid from DataOut and the write_gnuplot from 
  Triangulation<dim> to a single class like the DataOut class which
  does only write grids, without any data.


In 'KellyErrorEstimator' add new argument 'const vector<double> weight_
components' for using the error indicators of all components of a 
system in a linear combination. This vector must have the size of the
number of components and includes the weights. This could replace the 
old argument 'const unsigned int selected_component'.


Update documentation on Boundaries in Triangulation<dim> (Guido!)


Fix MGTransferPrebuilt::build_matrices, think about diagonals in
square sparse matrices.


In GridOut::write_ucd, a vector of vertices is built along with
  another vector stating which of these are used. These are actually
  the same arrays as exist already in the triangulation, but I did not
  want to write just another access function. However, someone should
  take a look whether re-building these arrays is a large wast of
  computing time and memory, or whether it is justifiable.


Fix a potential problem with viewing angles in 3d Eps GridOut (see
  comment)


Move the GridOut::EpsFlags<3>::EpsFlags constructor into the
  appropriate .cc-file if the compiler supports this. Same
  applies to DataOut::Patch<dim>


Remove the hack in Make_forward_declarations when using gcc2.95. See
  the cvs diffs of 1.6 to 1.7 for the reason.


Move the TriaNumberCache into the Triangulation class once the
  compiler supports this (gcc2.95 does not allow this at present)
  
