Remove the comment signs in the monitor_* functions in tria.cc
  as early as possible. These were inserted, since at home the
  program did some strange things in the reserve_memory
  functions (allocated more memory than told), such that the
  memory checks failed.


Write monitors to control whether enough memory was allocated for
  the vectors (i.e. after a process, whether size()==capacity()).
  (for DoF)


Write Triangulation::mesh_function.


Unify CellAccessor<1> and <2> by renaming
    LineAccessor<dim> -> SubstructAccessor<dim,1>
    QuadAccessor<dim> -> SubstructAccessor<dim,2>
  and deriving CellAccessor<dim> from SubstructAccessor<dim,dim>
  Do the same with DoFLineAccessor and DoFQuadAccessor


Make AssemblerData a local class to Assembler again if gcc2.8 supports it.


Let ParameterHandler and DataIn/Out throw exceptions. Make more tests
  on the input. Same for output: check whether file could be created etc.
  

Remove gcc2.8 workaround with DoFSubstructAccessor


Check usage of vector<>s: functions should assume that the objects have
  the right size already.


Update DataIO for ucd i/o of boundary flags and material values:
  is it correct if for the number of elements I give the number
  of cells + number of faces with boundary id .neq. 0 ? Or must
  I give the number of cells?


Update DoFHandler::distribute_cell_to_dof_vector for higher order
  elements (it can presently only handle elements with the only dofs
  on the vertices).


Remove FiniteElementData<>::operator == and let it be generated
  implicitely.


Look at the fill_fe_values functions for possible optimizations
  since this is one of the most often called functions.


Try to find out what happens if DoFAccessor::get_dof_values is
  called for a non-active object: what about dof numbers
  on non-active lines/quads? Are they all -1? Can we check for
  that. The problem is that we can't really check for activity
  for faces and the like, since they may have children but be
  part of active cells anyway.


Change <iostream> to <ostream> in grid/point.h and
  grid/tria_iterator.h when this becomes possible.


Fill in docs for the timer class.


Use a correct strategy to output the reduction rate for adaptively
  refined grids in examples/error-estimation


In VectorTools::project_boundary_values, no condensation of sparsity
  structures, matrices and right hand sides or distribution of
  solution vectors is performed, This is ok for dim<3 because then
  there are no constrained nodes on the boundary, but is not
  acceptable for higher dimensions. Fix this.


Remove the this-> coding in tria_iterator.templates.h. These were
  introduced in order to avoid an internal compiler error in an
  egcs  snapshot.


Re-enable printing of a preamble to ucd files in data_io.cc.


Implement coarsening of grids and update docs for that. Note the
  difference between refinement and coarsening: refinement
  deliberately adds additional refinment flags to keep consistency
  and thus refining all cells which were flagged for refinement.
  Coarsening on the contrary never deletes additional cells.
  Update algo section in tria docs for new smoothing strategies.

  Document that multiple loops of preparation for refinement and
  coarsening do not interact, so smoothing may only be optimal if
  #prepare_*# are called intermittently until nothing more changed.

  Document the behaviour of #prepare_*# and of the return value.


Check all places where condensation of matrices/vectors and
  application of boundary values takes place. I am not sure about
  the right order in which they have to be applied, but in 2D there
  is no difference since constrained dofs cannot be on the boundary.
  Problems with the order will therefore not show up in 2D but may
  become apparent in 3D, so keep this in mind for the implementation
  of the 3D library.


Revert istrstream(p.c_str()) to istrstream(p) when possible
  (parameter_handler.cc)


Fully implement the POVRAY format, i.e. use textures, a better angle
  of view, etc. The present implementation is only a rudimentary hack.


Review the restriction matrices. I'm not really sure about their
  meaning and how they are defined, so they may be wrong for linear
  elements and they are not implemented at all for quadratic ones.


Remove the workaround with the BoundaryHelper class which was
  introduced to work around a problem in the egcs-19980803 snapshot
  (previous ones worked flawless)


Check the pattern matching in the parameter handler module using
  the C++ exception handling mechanism rather than Asserts, since
  this should be on also when debug mode is off.


I suppose the [mg_]get_dof_values really belongs to the
  [MG]Line/QuadAccessor classes, but now it is in the
  [MG]CellAccessor. Correct this some time.

Let all the reinit functions in /lac free their memory, if reinit
  is called with the given dimension is zero. If so, check all deal.II files
  for use of reinit. (At present, new dimension==0 is not allowed.)
  [Done for dFMatrix and dVector; still to be done for the other
  classes.]

Use unsigned integers for the colnums array in dSMatrixStruct. This
  would enhance safety since colnum=-1 would no longer point to a
  valid address. How do you mark non-used columns? (gk)

Let dSMatrixStruct::compress free the memory of colnums which is
  no longer needed.

FeValues: add flexibility for update flags

Remove all fe& in vectors.h

No support points for non-Lagrangian elements? Check for Langrange in
interpolation?


Implement the random distortion in Triangulation for hanging nodes
  also. Hanging nodes need to be reset to the correct mean value
  at the end, which is simple for 2D but difficult for 3D. Maybe take
  a look at how we get to the original location of the point in the
  execute_refinement function and copy the relevant lines.


Review DoFCellAccessor<dim>::get_interpolated_dof_values: it may be
  necessary to write not the non-zero values, but those for which
  the corresponding row of the transfer (restriction) matrix
  has nonzero entries. This also catches those zeroes which should
  really be written but are not because the nodal value was zero.