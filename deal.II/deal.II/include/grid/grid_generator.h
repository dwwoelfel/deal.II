//---------------------------------------------------------------------------
//    $Id$
//    Version: $Name$
//
//    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006 by the deal.II authors
//
//    This file is subject to QPL and may not be  distributed
//    without copyright and license information. Please refer
//    to the file deal.II/doc/license.html for the  text  and
//    further information on this license.
//
//---------------------------------------------------------------------------
#ifndef __deal2__grid_generator_h
#define __deal2__grid_generator_h


#include <base/config.h>
#include <base/exceptions.h>
#include <base/point.h>
#include <base/table.h>
#include <map>

DEAL_II_NAMESPACE_OPEN

template <int dim> class Triangulation;
template <typename number> class Vector;
template <typename number> class SparseMatrix;


/**
 * This class offers triangulations of some standard domains such as hypercubes,
 * hyperball and the like. Following is a list of domains that can be generated
 * by the functions of this class:
 * <ul>
 *    <li> Hypercube:
 *       the GridGenerator::hyper_cube function produces the unit line
 *       segment, unit square, or unit cube:
 *
 *      @image html hyper_cubes.png
 * 
 *    <li> Generalized L-shape domain:
 *      using the GridGenerator::hyper_L (tria, a,b) function produces
 *      the hypercube with the interval $[a,b]$ without the hypercube
 *      made out of the interval $[(a+b)/2,b]$. Let, for example, be $a=-1$
 *      and $b=1$, then the hpyer-L in two dimensions is the region
 *      $[-1,1]^2 - [0,1]^2$. To create a hyper-L in one dimension results in
 *      an error. The function is also implemented for three space dimensions
 *      and produces the following domain (not completely to scale, the
 *      cut-out part should have exactly half the edge length of the entire
 *      cube):
 *
 *      @image html hyper_l.png
 *
 *    <li> Hyper ball:
 *      You get the circle or ball (or generalized: hyperball) around
 *      origin @p p and with radius @p r by calling
 *      GridGenerator::hyper_ball (tria, p, r). The circle is
 *      triangulated by five cells, the ball by seven cells. The
 *      diameter of the center cell is chosen so that the aspect ratio
 *      of the boundary cells after one refinement is minimized in
 *      some way. To create a hyperball in one dimension results in an
 *      error.
 *
 *      Do not forget to also attach a suitable boundary approximation object
 *      to the triangulation object you passed to this function if you later want
 *      the triangulation to be refined at the outer boundaries.
 *
 *    <li> Half Hyper ball:
 *      You get half of the circle or sphere generated by Hyper ball.
 *      with center @p p and with radius @p r by calling
 *      GridGenerator::half_hyper_ball (tria, p, r). The half-circle is 
 *      triangulated by four cells, while the half-sphere is triangulated by
 *	six cells. The diameter of the center cell is
 *      chosen to be the same as for the Hyper ball class. 
 *      To create a half-hyperball in one dimension results in
 *      an error.
 *
 *      Do not forget to also attach a suitable boundary approximation object
 *      to the triangulation object you passed to this function if you later want
 *      the triangulation to be refined at the outer boundaries. Both classes
 *      HalfHyperBallBoundary and HyperBallBoundary will provide a valid 
 *	boundary object.
 *
 *    <li> Hyper shell: A hyper shell is the region between two hyper
 *      sphere with the same origin. Therefore, it is a ring in two
 *      spatial dimensions. To triangulation it, call the function
 *      GridGenerator::hyper_shell (tria, origin, inner_radius, outer_radius, N),
 *      where the center of the spheres as well as
 *      the inner and outer radius of the two spheres are given as
 *      shown.
 *
 *      The parameter @p N denotes how many cells are to be used for
 *      this coarse triangulation. It defaults to zero, which tells
 *      the function to chose the number itself; this, then, is done
 *      such that the aspect ration of the resulting cells is as small
 *      as possible. However, it should be mentioned that this
 *      function does not work very well if the inner radius is much
 *      smaller than the outer radius since only one layer of cells is
 *      used in the radial direction.
 *
 *      You need to attach a boundary object to the triangulation. A
 *      suitable boundary class is provided as HyperSphereBoundary
 *      in the library.
 *
 *    <li> Half shells: This is a variant of the preceding domain,
 *      where only one half of the shell is taken, defined by the first
 *      coordinate having non-negative values. This class is useful in
 *      computations with rotational symmetry, as then a 3d shell can be
 *      modeled by a 2d half shell.
 *
 *    <li> Slit domain: The slit domain is a variant of the hyper cube
 *      domain. In two spatial dimensions, it is a square into which a
 *      slit is sawed; if the initial square is though to be composed
 *      of four smaller squares, then two of them are not connected
 *      even though they are neighboring each other. Analogously, into
 *      the cube in three spatial dimensions, a half-plane is sawed,
 *      disconnecting four of the eight child-cubes from one of their
 *      neighbors.  
 * 
 *    <li> Hyper cube with cylindrical hole: This domain is a square on
 *      the xy plane times the interval [0,L] with a cylindrical hole
 *      in the middle. The parameters that can be set are the internal
 *      radius, the external radius (inteded as the radius of the
 *      biggest enclosed cylinder), the depth of the structure (used
 *      only in three dimensions), and the number of repetitions along
 *      the z direction.
 *
 *	 @image html cubes_hole.png
 *	 
 * </ul>
 *
 * Some of these functions receive a flag @p colorize. If this is
 * set, parts of the boundary receive different boundary numbers,
 * allowing them to be distinguished by application programs. See the
 * documentation of the functions for details.
 * 
 * Additionally this class provides a function
 * (@p laplace_transformation) that smoothly transforms a grid
 * according to given new boundary points. This can be used to
 * transform (simple-shaped) grids to a more complicated ones, like a
 * shell onto a grid of an airfoil, for example.
 *
 * @ingroup grid
 * @author Wolfgang Bangerth, Ralf Hartmann, Guido Kanschat, Stefan Nauber, Joerg Weimar, Yaqi Wang, 1998, 1999, 2000, 2001, 2002, 2003, 2006.
 */
class GridGenerator
{
  public:
    				     /**
				      * Initialize the given
				      * triangulation with a hypercube
				      * (line in 1D, square in 2D,
				      * etc) consisting of exactly one
				      * cell. The hypercube volume is
				      * the tensor product interval
				      * <i>[left,right]<sup>dim</sup></i>
				      * in the present number of
				      * dimensions, where the limits
				      * are given as arguments. They
				      * default to zero and unity,
				      * then producing the unit
				      * hypercube.
				      *
				      * See also
				      * subdivided_hyper_cube() for a
				      * coarse mesh consisting of
				      * several cells. See
				      * hyper_rectangle(), if
				      * different lengths in different
				      * ordinate directions are
				      * required.
				      *
				      * @note The triangulation needs to be
				      * void upon calling this
				      * function.
				      */
    template <int dim>
    static void hyper_cube (Triangulation<dim> &tria,
			    const double        left = 0.,
			    const double        right= 1.);

    				     /**
				      * Same as hyper_cube(), but
				      * with the difference that not
				      * only one cell is created but
				      * each coordinate direction is
				      * subdivided into
				      * @p repetitions cells. Thus,
				      * the number of cells filling
				      * the given volume is
				      * <tt>repetitions<sup>dim</sup></tt>.
				      *
				      * @note The triangulation needs to be
				      * void upon calling this
				      * function.
				      */
    template <int dim>
    static void subdivided_hyper_cube (Triangulation<dim> &tria,
                                       const unsigned int  repetitions,
                                       const double        left = 0.,
                                       const double        right= 1.);

    				     /**
				      * Create a coordinate-parallel
				      * parallelepiped from the two
				      * diagonally opposite corner
				      * points @p p1 and @p p2.
				      *
				      * If the @p colorize flag is
				      * set, the
				      * @p boundary_indicators of the
				      * surfaces are assigned, such
				      * that the lower one in
				      * @p x-direction is 0, the
				      * upper one is 1. The indicators
				      * for the surfaces in
				      * @p y-direction are 2 and 3,
				      * the ones for @p z are 4 and
				      * 5.
				      * 
				      * The triangulation needs to be
				      * void upon calling this
				      * function.
				      */
    template <int dim>
    static void hyper_rectangle (Triangulation<dim> &tria,
				 const Point<dim>   &p1,
				 const Point<dim>   &p2,
				 const bool          colorize = false);

				     /**
				      * Create a coordinate-parallel
				      * parallelepiped from the two
				      * diagonally opposite corner
				      * points @p p1 and @p p2. In
				      * dimension @p i,
				      * <tt>repetitions[i]</tt> cells are
				      * generated.
				      * 
				      * To get cells with an aspect
				      * ratio different from that of
				      * the domain, use different
				      * numbers of subdivisions in
				      * different coordinate
				      * directions. The minimum number
				      * of subdivisions in each
				      * direction is
				      * 1. @p repetitions is a list
				      * of integers denoting the
				      * number of subdivisions in each
				      * coordinate direction.
				      * 
				      * If the @p colorize flag is
				      * set, the
				      * @p boundary_indicators of the
				      * surfaces are assigned, such
				      * that the lower one in
				      * @p x-direction is 0, the
				      * upper one is 1. The indicators
				      * for the surfaces in
				      * @p y-direction are 2 and 3,
				      * the ones for @p z are 4 and
				      * 5.
				      *
				      * @note The triangulation needs to be
				      * void upon calling this
				      * function.
				      *
				      * @note For an example of the
				      * use of this function see the
				      * @ref step_22 "step-22"
				      * tutorial program.
				      */
    template <int dim>
    static
    void
    subdivided_hyper_rectangle (Triangulation<dim>              &tria,
				const std::vector<unsigned int> &repetitions,
				const Point<dim>                &p1,
				const Point<dim>                &p2,
				const bool                       colorize=false);

				     /**
				      * Like the previous
				      * function. However, here the
				      * second argument does not
				      * denote the number of
				      * subdivisions in each
				      * coordinate direction, but a
				      * sequence of step sizes for
				      * each coordinate direction. The
				      * domain will therefore be
				      * subdivided into
				      * <code>step_sizes[i].size()</code>
				      * cells in coordinate direction
				      * <code>i</code>, with widths
				      * <code>step_sizes[i][j]</code>
				      * for the <code>j</code>th cell.
				      *
				      * This function is therefore the
				      * right one to generate graded
				      * meshes where cells are
				      * concentrated in certain areas,
				      * rather than a uniformly
				      * subdivided mesh as the
				      * previous function generates.
				      *
				      * The step sizes have to add up
				      * to the dimensions of the hyper
				      * rectangle specified by the
				      * points @p p1 and @p p2.
				      */
    template <int dim>
    static
    void
    subdivided_hyper_rectangle(Triangulation<dim>              &tria,
			       const std::vector<std::vector<double> > &step_sizes,
			       const Point<dim>                &p_1,
			       const Point<dim>                &p_2,
			       const bool                       colorize);

				     /**
				      * Like the previous function, but with
				      * the following twist: the @p
				      * material_id argument is a
				      * dim-dimensional array that, for each
				      * cell, indicates which material_id
				      * should be set. In addition, and this
				      * is the major new functionality, if the
				      * material_id of a cell is <tt>(unsigned
				      * char)(-1)</tt>, then that cell is
				      * deleted from the triangulation,
				      * i.e. the domain will have a void
				      * there.
				      */
    template <int dim>
    static
    void
    subdivided_hyper_rectangle (Triangulation<dim>                       &tria,
				const std::vector< std::vector<double> > &spacing,
				const Point<dim>                         &p,
				const Table<dim,unsigned char>           &material_id,
				const bool                                colorize=false);
    
				     /**
				      * A parallelogram. The first
				      * corner point is the
				      * origin. The <tt>dim</tt>
				      * adjacent points are the
				      * one-dimensional subtensors of
				      * the tensor provided and
				      * additional points will be sums
				      * of these two vectors.
				      * Colorizing is done according
				      * to hyper_rectangle().
				      *
				      * @note This function is
				      * implemented in 2d only.
				      *
				      * @note The triangulation needs to be
				      * void upon calling this
				      * function.
				      */
    template <int dim>
    static void
    parallelogram(Triangulation<dim>&  tria,
		  const Tensor<2,dim>& corners,
		  const bool           colorize=false);
		  
			      
				     /**
				      * Hypercube with a layer of
				      * hypercubes around it. The
				      * first two parameters give the
				      * lower and upper bound of the
				      * inner hypercube in all
				      * coordinate directions.
				      * @p thickness marks the size of
				      * the layer cells.
				      *
				      * If the flag colorize is set,
				      * the outer cells get material
				      * id's according to the
				      * following scheme: extending
				      * over the inner cube in
				      * (+/-) x-direction: 1/2. In y-direction
				      * 4/8, in z-direction 16/32. The cells
				      * at corners and edges (3d) get
				      * these values bitwise or'd.
				      *
				      * Presently only available in 2d
				      * and 3d.
				      *
				      * @note The triangulation needs to be
				      * void upon calling this
				      * function.
				      */
    template <int dim>
    static void enclosed_hyper_cube (Triangulation<dim> &tria,
	 			     const double      left = 0.,
				     const double      right= 1.,
				     const double      thickness = 1.,
				     const bool        colorize = false);
    
				     /**
				      * Initialize the given
				      * triangulation with a
				      * hyperball, i.e. a circle or a
				      * ball.  See the general
				      * documentation for a more
				      * concise description. The
				      * center of the hyperball
				      * default to the origin, the
				      * radius defaults to unity.
				      *
				      * The triangulation needs to be
				      * void upon calling this
				      * function.
				      *
				      * This function is declared to
				      * exist for triangulations of
				      * all space dimensions, but
				      * throws an error if called in
				      * 1d.
				      *
				      * @note The triangulation needs to be
				      * void upon calling this
				      * function.
				      */    
    template <int dim>
    static void hyper_ball (Triangulation<dim> &tria,
			    const Point<dim>   &center = Point<dim>(),
			    const double      radius = 1.);

				     /**
				      * Create a cylinder around the
				      * x-axis.  The cylinder extends
				      * from <tt>x=-half_length</tt> to
				      * <tt>x=+half_length</tt> and its
				      * projection into the
				      * @p yz-plane is a circle of
				      * radius @p radius.
				      *
				      * In two dimensions, the
				      * cylinder is a rectangle from
				      * <tt>x=-half_length</tt> to
				      * <tt>x=+half_length</tt> and
				      * from <tt>y=-radius</tt> to
				      * <tt>y=radius</tt>.
				      *
				      * The boundaries are colored
				      * according to the following
				      * scheme: 0 for the hull of the
				      * cylinder, 1 for the left hand
				      * face and 2 for the right hand
				      * face.
				      *
				      * @note The triangulation needs to be
				      * void upon calling this
				      * function.
				      */
    template <int dim>
    static void cylinder (Triangulation<dim> &tria,
			  const double      radius = 1.,
			  const double      half_length = 1.);
    
				     /**
				      * Initialize the given
				      * triangulation with a hyper-L
				      * consisting of exactly
				      * <tt>2^dim-1</tt> cells. See the
				      * general documentation for a
				      * description of the
				      * L-region. The limits default
				      * to minus unity and unity.
				      *
				      * The triangulation needs to be
				      * void upon calling this
				      * function.
				      *
				      * This function is declared to
				      * exist for triangulations of
				      * all space dimensions, but
				      * throws an error if called in
				      * 1d.
				      *
				      * @note The triangulation needs to be
				      * void upon calling this
				      * function.
				      */
    template <int dim>
    static void hyper_L (Triangulation<dim> &tria,
			 const double      left = -1.,
			 const double      right= 1.);
    
                                     /**
				      * Initialize the given
				      * Triangulation with a hypercube
				      * with a slit. In each
				      * coordinate direction, the
				      * hypercube extends from @p left
				      * to @p right.
				      *
				      * In 2d, the split goes in
				      * vertical direction from
				      * <tt>x=(left+right)/2,
				      * y=left</tt> to the center of
				      * the square at
				      * <tt>x=y=(left+right)/2</tt>.
				      *
				      * In 3d, the 2d domain is just
				      * extended in the
				      * <i>z</i>-direction, such that
				      * a plane cuts the lower half of
				      * a rectangle in two.
				      
				      * This function is declared to
				      * exist for triangulations of
				      * all space dimensions, but
				      * throws an error if called in
				      * 1d.
				      *
				      * @note The triangulation needs to be
				      * void upon calling this
				      * function.
				      */
    template <int dim>
    static void hyper_cube_slit (Triangulation<dim> &tria,
				 const double      left = 0.,
				 const double      right= 1.,
				 const bool colorize = false);
    
				     /**
				      * Produce a hyper-shell,
				      * i.e. the space between two
				      * circles in two space
				      * dimensions and the region
				      * between two spheres in 3d,
				      * with given inner and outer
				      * radius and a given number of
				      * elements for this initial
				      * triangulation. If the number
				      * of initial cells is zero (as
				      * is the default), then it is
				      * computed adaptively such that
				      * the resulting elements have
				      * the least aspect ratio.
				      *
				      * The triangulation needs to be
				      * void upon calling this
				      * function.
				      *
				      * This function is declared to
				      * exist for triangulations of
				      * all space dimensions, but
				      * throws an error if called in
				      * 1d. It is also currently not
				      * implemented in 3d.
				      *
				      * @note The triangulation needs to be
				      * void upon calling this
				      * function.
				      */
    template <int dim>
    static void hyper_shell (Triangulation<dim>   &tria,
			     const Point<dim>     &center,
			     const double        inner_radius,
			     const double        outer_radius,
			     const unsigned int  n_cells = 0);
    
				     /**
				      * Produce a domain that is the space
				      * between two cylinders in 3d, with
				      * given length, inner and outer radius
				      * and a given number of elements for
				      * this initial triangulation. If @p
				      * n_radial_cells is zero (as is the
				      * default), then it is computed
				      * adaptively such that the resulting
				      * elements have the least aspect
				      * ratio. The same holds for @p
				      * n_axial_cells.
				      *
				      * @note Although this function
				      * is declared as a template, it
				      * does not make sense in 1D and
				      * 2D.
				      *
				      * @note The triangulation needs
				      * to be void upon calling this
				      * function.
				      */
    template <int dim>
    static void cylinder_shell (Triangulation<dim>   &tria,
                                const double        length,
                                const double        inner_radius,
                                const double        outer_radius,
                                const unsigned int  n_radial_cells = 0,
                                const unsigned int  n_axial_cells = 0);

				     /**
				      * This class produces a half hyper-ball,
				      * which contains four elements in 2d and
				      * 6 in 3d. The orientation is such that 
				      * the cutting plane is the x=0.
				      *
				      * The triangulation needs to be
				      * void upon calling this
				      * function.
				      *
				      * The boundary indicators for the final 
				      * triangulation are 0 for the curved boundary and
				      * 1 for the cut plane. 
				      *
				      * The appropriate
				      * boundary class is 
				      * HalfHyperBallBoundary, or HyperBallBoundary.
				      * 
				      * @note The triangulation needs to be
				      * void upon calling this
				      * function.
				      */
    template <int dim>
    static void half_hyper_ball (Triangulation<dim> &tria,
				 const Point<dim>   &center = Point<dim>(),
				 const double      radius = 1.);

				     /**
				      * Produce a half hyper-shell,
				      * i.e. the space between two
				      * circles in two space
				      * dimensions and the region
				      * between two spheres in 3d,
				      * with given inner and outer
				      * radius and a given number of
				      * elements for this initial
				      * triangulation.  However,
				      * opposed to the previous
				      * function, it does not produce
				      * a whole shell, but only one
				      * half of it, namely that part
				      * for which the first component
				      * is restricted to non-negative
				      * values. The purpose of this
				      * class is to enable
				      * computations for solutions
				      * which have rotational
				      * symmetry, in which case the
				      * half shell in 2d represents a
				      * shell in 3d.
				      *
				      * If the number of
				      * initial cells is zero (as is
				      * the default), then it is
				      * computed adaptively such that
				      * the resulting elements have
				      * the least aspect ratio.
				      *
				      * The triangulation needs to be
				      * void upon calling this
				      * function.
				      *
				      * At present, this function only
				      * exists in 2d.
				      *
				      * @note The triangulation needs to be
				      * void upon calling this
				      * function.
				      */
    template <int dim>
    static void half_hyper_shell (Triangulation<dim>   &tria,
				  const Point<dim>     &center,
				  const double        inner_radius,
				  const double        outer_radius,
				  const unsigned int  n_cells = 0);
    
				     /** 
				      * This class produces a square
				      * on the @p xy-plane with a
				      * circular hole in the middle,
				      * times the interval @p [0.L]
				      * (only in 3d). It is
				      * implemented in 2d and 3d, and
				      * takes the following arguments:
				      * 
				      * - @p inner_radius: size of the
                                      *    internal hole 
				      * - @p  outer_radius: size of the
                                      *    biggest enclosed cylinder
				      * - @p L: extension on the @p z-direction
				      * - @p repetitions: number of subdivisions
				      *      along the @p z-direction
				      * - @p colorize: wether to assign different 
				      *     boundary indicators to different faces.
				      *    The colors are given in lexycografical 
				      *    ordering for the flat faces (0 to 3 in 2d, 
				      *    0 to 5 in 3d) plus the curved hole 
				      *    (4 in 2d, and 6 in 3d).
				      *    If @p colorize is set to false, then flat faces 
				      *    get the number 0 and the hole gets number 1.
				      */
    template<int dim>
    static void hyper_cube_with_cylindrical_hole (Triangulation<dim> &triangulation, 
						const double inner_radius = .25,
						const double outer_radius = .5,
						const double L = .5,
						const unsigned int repetition = 1,
						const bool colorize = false);

				     /**
				      * Produce a ring of cells in 3D that is
				      * cut open, twisted and glued together
				      * again. This results in a kind of
				      * moebius-loop.
				      *
				      * @param tria        The triangulation to be worked on.
				      * @param n_cells     The number of cells in the loop. Must be greater than 4.
				      * @param n_rotations The number of rotations (Pi/2 each) to be performed before glueing the loop together.
				      * @param R           The radius of the circle, which forms the middle line of the torus containing the loop of cells. Must be greater than @p r.
				      * @param r           The radius of the cylinder bend together as loop.
				      */
    static void moebius (Triangulation<3>&  tria,
			 const unsigned int   n_cells,
			 const unsigned int   n_rotations,
			 const double         R,
			 const double         r);
    
				     /**
				      * This function transformes the
				      * @p Triangulation @p tria
				      * smoothly to a domain that is
				      * described by the boundary
				      * points in the map
				      * @p new_points. This map maps
				      * the point indices to the
				      * boundary points in the
				      * transformed domain.
				      *
				      * Note, that the
				      * @p Triangulation is changed
				      * in-place, therefore you don't
				      * need to keep two
				      * triangulations, but the given
				      * triangulation is changed
				      * (overwritten).
				      *
				      * In 1d, this function is not
				      * currently implemented.
				      */
    template <int dim>
    static void laplace_transformation (Triangulation<dim> &tria,
					const std::map<unsigned int,Point<dim> > &new_points);

				     /**
				      * Exception
				      */
    DeclException0 (ExcInvalidRadii);
                                     /**
                                      * Exception
                                      */
    DeclException1 (ExcInvalidRepetitions,
                    int,
                    << "The number of repetitions " << arg1
                    << " must be >=1.");
				     /**
				      * Exception
				      */
    DeclException1 (ExcInvalidRepetitionsDimension,
                    int,
                    << "The vector of repetitions  must have " 
		    << arg1 <<" elements.");

  private:
				     /**
				      * Perform the action specified
				      * by the @p colorize flag of
				      * the hyper_rectangle()
				      * function of this class.
				      */
    template <int dim>
    static void colorize_hyper_rectangle (Triangulation<dim> &tria);

				     /**
				      * Declaration of the above
				      * function for 1d.
				      */
    static void colorize_hyper_rectangle (Triangulation<1> &tria);
    
				     /**
				      * Perform the action specified
				      * by the @p colorize flag of
				      * the
				      * subdivided_hyper_rectangle()
				      * function of this class. This
				      * function is singled out
				      * because it is dimension
				      * specific.
				      */
    template <int dim>
    static
    void
    colorize_subdivided_hyper_rectangle (Triangulation<dim> &tria,
					 const Point<dim>   &p1,
					 const Point<dim>   &p2,
					 const double        epsilon);

				     /**
				      * Declaration of the above
				      * function for 1d.
				      */
    static
    void
    colorize_subdivided_hyper_rectangle (Triangulation<1> &tria,
					 const Point<1>   &p1,
					 const Point<1>   &p2,
					 const double      epsilon);

				     /**
				      * Solve the Laplace equation for
				      * @p laplace_transformation
				      * function for one of the
				      * @p dim space
				      * dimensions. Externalized into
				      * a function of its own in order
				      * to allow parallel execution.
				      */
    static
    void
    laplace_solve (const SparseMatrix<double>          &S,
		   const std::map<unsigned int,double> &m,
		   Vector<double>                      &u);
};



DEAL_II_NAMESPACE_CLOSE

#endif
