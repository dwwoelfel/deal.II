//---------------------------------------------------------------------------
//    $Id$
//    Version: $Name$
//
//    Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010, 2011, 2012 by the deal.II authors
//
//    This file is subject to QPL and may not be  distributed
//    without copyright and license information. Please refer
//    to the file deal.II/doc/license.html for the  text  and
//    further information on this license.
//
//---------------------------------------------------------------------------



for (X : TRIANGULATION_AND_DOFHANDLERS; deal_II_dimension : DIMENSIONS ; deal_II_space_dimension : SPACE_DIMENSIONS)
{
  
#if deal_II_dimension <= deal_II_space_dimension
  namespace GridTools \{

  template
    unsigned int
    find_closest_vertex (const X &,
			 const Point<deal_II_space_dimension> &);

  template
    std::vector<X::active_cell_iterator>
    find_cells_adjacent_to_vertex(const X &,
				  const unsigned int);
  template
    X::active_cell_iterator
    find_active_cell_around_point (const X &,
				   const Point<deal_II_space_dimension> &p);

  template
    std::pair<X::active_cell_iterator, Point<deal_II_dimension> >
    find_active_cell_around_point (const Mapping<deal_II_dimension, deal_II_space_dimension> &,
				   const X &,
				   const Point<deal_II_space_dimension> &);

  template
    std::list<std::pair<X::cell_iterator, X::cell_iterator> >
    get_finest_common_cells (const X &mesh_1,
  			     const X &mesh_2);


  template
    bool
    have_same_coarse_mesh (const X &mesh_1,
			   const X &mesh_2);

  \}

  #endif
}


for (deal_II_dimension : DIMENSIONS; deal_II_space_dimension :  SPACE_DIMENSIONS)
  {
#if deal_II_dimension <= deal_II_space_dimension
    namespace GridTools \{

    template
      double
      diameter
      (const Triangulation<deal_II_dimension, deal_II_space_dimension> &);

    template
      double
      volume
      (const Triangulation<deal_II_dimension, deal_II_space_dimension> &,
       const Mapping<deal_II_dimension, deal_II_space_dimension> &);
    
    template
      void delete_unused_vertices (std::vector<Point<deal_II_space_dimension> > &,
				   std::vector<CellData<deal_II_dimension> > &,
				   SubCellData &);

    template
      void delete_duplicated_vertices (std::vector<Point<deal_II_space_dimension> > &,
				       std::vector<CellData<deal_II_dimension> > &,
				       SubCellData &,
				       std::vector<unsigned int> &,
				       double);

    template
      void shift<deal_II_dimension> (const Point<deal_II_space_dimension> &,
						Triangulation<deal_II_dimension, deal_II_space_dimension> &);

    template
      void scale<deal_II_dimension> (const double,
				     Triangulation<deal_II_dimension, deal_II_space_dimension> &);

    template
      void get_face_connectivity_of_cells
      (const Triangulation<deal_II_dimension, deal_II_space_dimension> &triangulation,
       SparsityPattern          &cell_connectivity);


    template
      void partition_triangulation (const unsigned int,
			       Triangulation<deal_II_dimension, deal_II_space_dimension> &);
    
    template
      void partition_triangulation (const unsigned int,
				    const SparsityPattern &,
				    Triangulation<deal_II_dimension, deal_II_space_dimension> &);

    template
      std::pair<hp::DoFHandler<deal_II_dimension, deal_II_space_dimension>::active_cell_iterator,
		Point<deal_II_dimension> >
      find_active_cell_around_point
      (const hp::MappingCollection<deal_II_dimension, deal_II_space_dimension> &,
       const hp::DoFHandler<deal_II_dimension, deal_II_space_dimension> &,
       const Point<deal_II_space_dimension> &);
    

    
    template
      void get_subdomain_association (const Triangulation<deal_II_dimension, deal_II_space_dimension>  &,
				      std::vector<types::subdomain_id_t> &);

    template
    unsigned int count_cells_with_subdomain_association(
      const Triangulation<deal_II_dimension, deal_II_space_dimension> &,
      const types::subdomain_id_t);
    
    template
      double
      minimal_cell_diameter (const Triangulation<deal_II_dimension, deal_II_space_dimension> &triangulation);
    
    template
      double
      maximal_cell_diameter (const Triangulation<deal_II_dimension, deal_II_space_dimension> &triangulation);

    template
      void
      create_union_triangulation (
	const Triangulation<deal_II_dimension, deal_II_space_dimension> &triangulation_1,
	const Triangulation<deal_II_dimension, deal_II_space_dimension> &triangulation_2,
	Triangulation<deal_II_dimension, deal_II_space_dimension>       &result);
#if deal_II_dimension == deal_II_space_dimension  
    template
      Triangulation<deal_II_dimension,deal_II_space_dimension>::DistortedCellList
      fix_up_distorted_child_cells
      (const Triangulation<deal_II_dimension,deal_II_space_dimension>::DistortedCellList &distorted_cells,
       Triangulation<deal_II_dimension,deal_II_space_dimension> &triangulation);

#endif
    
    \}
#endif


    
  }




for (deal_II_dimension : DIMENSIONS; deal_II_space_dimension :  SPACE_DIMENSIONS; Container : TRIANGULATION_AND_DOFHANDLER_TEMPLATES)
  {
#if deal_II_dimension <= deal_II_space_dimension
#if deal_II_dimension != 1
    namespace GridTools \{

      template
	std::map<  Container<deal_II_dimension-1,deal_II_space_dimension>::cell_iterator,
		   Container<deal_II_dimension,deal_II_space_dimension>::face_iterator>
      extract_boundary_mesh (const Container<deal_II_dimension, deal_II_space_dimension> &mesh,
			     Container<deal_II_dimension-1,deal_II_space_dimension>  &boundary_mesh,
			     const std::set<types::boundary_id_t> &boundary_ids);
      \}
#endif
#endif

  }


for (X : TRIANGULATION_AND_DOFHANDLERS; deal_II_dimension : DIMENSIONS ; deal_II_space_dimension : SPACE_DIMENSIONS)
{
#if deal_II_dimension <= deal_II_space_dimension
  namespace GridTools \{

    template
    std::map<X::cell_iterator, X::cell_iterator>
    collect_periodic_cell_pairs(const X::cell_iterator &,
                                const X::cell_iterator &,
                                const types::boundary_id_t,
                                int,
                                const Tensor<1,deal_II_space_dimension> &);

    template
    std::map<X::cell_iterator, X::cell_iterator>
    collect_periodic_cell_pairs (const X&,
                                 const types::boundary_id_t,
                                 int,
                                 const Tensor<1,deal_II_space_dimension> &);


  \}
  #endif
}

